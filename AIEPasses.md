<!-- Autogenerated by mlir-tblgen; don't manually edit -->
### `-aie-assign-buffer-addresses`: Assign memory locations for buffers in each tile
Buffers in a tile generally have an address that does not significantly
matter in the design.  Hence, most of the time we can instantiate
aie.buffer operations without an address.  This pass determines
updates each aie.buffer operation without an address to have a
well-defined address.  This enables later passes to have a
consistent view of the memory map of a system.
### `-aie-assign-lock-ids`: Assigns the lockIDs of locks that do not have IDs.
Assigns the lockIDs of locks that do not have IDs.
### `-aie-create-cores`: Create CoreOp, MemOp, and FlowOp of AIE dialect
Lower toplevel 'call' operations with implicit data movement into
aie.core, aie.mem, and aie.flow operations with explicit data
movement.  The tile tile associated with the operations is inferred
based on the aie.x and aie.y attributes of the call operation. e.g.:
```
func.func @aie_task(%arg0: memref<256xi32>, %arg1: i32) -> () {
  ...
  return
}
%a = constant 0 : i32
func.call @aie_task(%buf, %a) { aie.x = 1, aie.y = 1 } : (memref<256xi32>, i32) -> ()

```
will result in:
```
%0 = AIE.tile(1, 1)
%1 = AIE.buffer(%0) : memref<256xi32>
%2 = AIE.buffer(%0) : memref<1xi32>
%c0_i32 = constant 0 : i32
%5 = AIE.core(%0) {
  ...
}
```
In this case, each argument to aie_task results in an explicit buffer accessed by the core.

### `-aie-create-locks`: Generate physical lock ops from logical lock (token) ops
Tokens represent high-level buffer synchronization through a sequence of
pipeline stages.  This pass lowers token operations into physical aie.lock
operations.
### `-aie-create-packet-flows`: Route aie.packetflow operations through switchboxes
Replace each aie.packetflow operation with an equivalent set of aie.switchbox and aie.wire
operations.  
### `-aie-create-pathfinder-flows`: Route aie.flow operations through switchboxes with Pathfinder algorithm
Replace each aie.flow operation with an equivalent set of aie.switchbox and aie.wire
operations. Uses Pathfinder congestion-aware algorithm. 
### `-aie-find-flows`: Recover flows from switchbox configuration
Under normal circumstances, every configured aie.switchbox operation
should contribute to describing an end-to-end flow from one point
to another.  These flows may be circuit-switched flows (represented
by aie.flow) or a packet-switched connection (represensted by
aie.packetflow).  This pass is primarily used for testing automatic
routing.
### `-aie-herd-routing`: Lowering herds with place and route ops to AIE cores, mems, and switchboxes
An experimental pass which elaborates herd operations (e.g. aie.herd, aie.iter, aie.select)
into an explicit representation (e.g. aie.core, aie.mem, etc.).
### `-aie-localize-locks`: Convert global locks to a core-relative index
An individual lock can be referenced by 4 different AIE cores.  However, each individual core
accesses the lock through a different 'lock address space'.  This pass converts a lock in the
conceptual global address space into a local index.  e.g.:
```
%lock = AIE.lock(%tile, 2)
AIE.core(%tile) {
  AIE.useLock(%lock, "Acquire", 1)
}
```
becomes
```
AIE.core(%tile) {
  %lockindex = arith.constant ? : index
  AIE.useLock(%lockindex, "Acquire", 1)
}
```
### `-aie-lower-broadcast-packet`: Replace combination of broadcast and packet-switch by packet-flow
Replace combination of broadcast and packet-switch by packet-flow  
### `-aie-lower-memcpy`: Lower aie.memcpy operations to Flows and DMA programs
aie.memcpy operations are an experimental high-level abstraction which
move data from one buffer to another.
This pass lowers them into appropriate aie.flow and aie.mem operations.
### `-aie-lower-multicast`: Lower AIE.multicast operation to AIE.flow operations
This pass replaces AIE.multicast operation with the equivalent number of AIE.flow 
operations. The lowered AIE.flow operations have the same source port but different
destinations.
### `-aie-normalize-address-spaces`: Remove non-default address spaces
Early in the flow, it is convenient to represent multiple memories using different
address spaces.  However, after outlining code for AIE engines, the core itself only
has access to a single address space.  To avoid confusion, this pass normalizes
any address spaces remaining in the code, converting them to the default address
space.
### `-aie-objectFifo-stateful-transform`: Instantiate the buffers and locks of aie.objectFifo.createObjectFifo operations
Replace each aie.objectFifo.createObjectFifo operation with aie.buffer and aie.lock operations in the 
producer tile. Convert aie.objectFifo.acquire, aie.objectFifo.release and aie.objectFifo.subviewAccess
operations into useLock operations by keeping track of acquire/release operations on each objectFifo by
each process.

If the producer and consumer tiles of an aie.objectFifo.createObjectFifo operation are not adjacent, the 
pass also establised aie.flow and aie.dma operations to enable communication between the tiles.

Extend the body of each loop that contains operations on objectFifos such that it is unrolled
based on the number of elements in the objectFifos. If the number of iterations of the loop 
cannot be divided pefectly by the unrolling factor, the pass duplicates the loop body after 
the original loop.
### `-aie-register-objectFifos`: Generate acquire/release patterns for producer/consumer processes registered to an objectFifo
Generate acquire/release patterns in the CoreOps of associated cores for each 
aie.objectFifo.registerProcess operation. Patterns are generated as for loops
of different sizes depending on input patterns.
### `-aie-standard-lowering`: Lowering operations in AIE cores' regions to Standard
Outline code inside AIE.core operations into the llvm dialect.
BufferOp operations are converted to a GlobalMemrefOp and references to
those buffers are converted to GetGlobalMemrefOp.  Other AIE operations
inside the cores are generally lowered to appropriate function intrinsics.
Other AIE operations (e.g. CoreOp, TileOp, LockOp) outside the core are removed.

Optionally, tileCol and tileRow can specify a single core to export


#### Options
```
-tilecol : X coordinate of tile to generate code for
-tilerow : Y coordinate of tile to generate code for
```
### `-aie-vector-opt`: optimize vector instructions for AIE
After super-vectorization, some additional optimizations are important
for improving QOR and enabling lowering to LLVM.
