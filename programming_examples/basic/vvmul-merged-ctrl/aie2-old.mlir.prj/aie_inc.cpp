
// This file was auto-generated by aiecc.py --aie-generate-xaie.

#ifndef MLIR_AIE_QUIET
#define __mlir_aie_verbose(x) x
#else
#define __mlir_aie_verbose(x)
#endif

// The following is a wrapper for the common "if(call() != 0) return 1" pattern.
// Use this only in functions that return int. If the call this wrapper is used
// on does not succeed, the expanded code will exit out of the function
// containing this macro with an error code.
#define __mlir_aie_try(x) do { \
  AieRC ret = (x); \
  if(ret != XAIE_OK) { \
    return x; \
  } \
} while(0)

static XAie_DmaDimDesc *__mlir_aie_alloc_dim_desc(size_t ndims) {
  XAie_DmaDimDesc *ret = NULL;
  ret = (XAie_DmaDimDesc *)calloc(sizeof(XAie_DmaDimDesc), ndims);
  if(NULL == ret) {
    __mlir_aie_verbose(fprintf(stderr, "Allocating DmaDimDesc failed.\n"));
  }
  return ret;
}

aie_libxaie_ctx_t* mlir_aie_init_libxaie() {
  aie_libxaie_ctx_t *ctx = new aie_libxaie_ctx_t;
  if (!ctx)
    return 0;
  ctx->AieConfigPtr.AieGen = XAIE_DEV_GEN_AIEML;
  ctx->AieConfigPtr.BaseAddr = 0x20000000000;
  ctx->AieConfigPtr.ColShift = 25;
  ctx->AieConfigPtr.RowShift = 20;
  ctx->AieConfigPtr.NumRows = 6;
  ctx->AieConfigPtr.NumCols = 1;
  ctx->AieConfigPtr.ShimRowNum = 0;
  ctx->AieConfigPtr.MemTileRowStart = 1;
  ctx->AieConfigPtr.MemTileNumRows = 1;
  //  ctx->AieConfigPtr.ReservedRowStart = XAIE_RES_TILE_ROW_START;
  //  ctx->AieConfigPtr.ReservedNumRows  = XAIE_RES_TILE_NUM_ROWS;
  ctx->AieConfigPtr.AieTileRowStart = 2;
  ctx->AieConfigPtr.AieTileNumRows = 4;
  ctx->AieConfigPtr.PartProp = {0};
  ctx->DevInst = {0};
  return ctx;
}

int mlir_aie_configure_cores(aie_libxaie_ctx_t* ctx) {
__mlir_aie_try(XAie_CoreReset(&(ctx->DevInst), XAie_TileLoc(0,2)));
__mlir_aie_try(XAie_CoreDisable(&(ctx->DevInst), XAie_TileLoc(0,2)));
for (int l = 0; l < 16; ++l)
  __mlir_aie_try(XAie_LockRelease(&(ctx->DevInst), XAie_TileLoc(0,2), XAie_LockInit(l, 0x0), 0));
{
AieRC RC = XAie_LoadElf(&(ctx->DevInst), XAie_TileLoc(0,2), (const char*)"core_0_2.elf",0);
if (RC != XAIE_OK)
    __mlir_aie_verbose(fprintf(stderr, "Failed to load elf for Core[%d,%d], ret is %d\n", 0, 2, RC));
assert(RC == XAIE_OK);
}
return XAIE_OK;
} // mlir_aie_configure_cores

int mlir_aie_start_cores(aie_libxaie_ctx_t* ctx) {
__mlir_aie_try(XAie_CoreUnreset(&(ctx->DevInst), XAie_TileLoc(0,2)));
__mlir_aie_try(XAie_CoreEnable(&(ctx->DevInst), XAie_TileLoc(0,2)));
return XAIE_OK;
} // mlir_aie_start_cores

int mlir_aie_configure_dmas(aie_libxaie_ctx_t* ctx) {
return XAIE_OK;
} // mlir_aie_configure_dmas

int mlir_aie_initialize_locks(aie_libxaie_ctx_t* ctx) {
__mlir_aie_try(XAie_LockSetValue(&(ctx->DevInst), XAie_TileLoc(0,2), XAie_LockInit(0, 1)));
__mlir_aie_try(XAie_LockSetValue(&(ctx->DevInst), XAie_TileLoc(0,2), XAie_LockInit(1, 0)));
__mlir_aie_try(XAie_LockSetValue(&(ctx->DevInst), XAie_TileLoc(0,2), XAie_LockInit(2, 1)));
__mlir_aie_try(XAie_LockSetValue(&(ctx->DevInst), XAie_TileLoc(0,2), XAie_LockInit(3, 0)));
__mlir_aie_try(XAie_LockSetValue(&(ctx->DevInst), XAie_TileLoc(0,1), XAie_LockInit(0, 1)));
__mlir_aie_try(XAie_LockSetValue(&(ctx->DevInst), XAie_TileLoc(0,1), XAie_LockInit(1, 0)));
__mlir_aie_try(XAie_LockSetValue(&(ctx->DevInst), XAie_TileLoc(0,1), XAie_LockInit(2, 1)));
__mlir_aie_try(XAie_LockSetValue(&(ctx->DevInst), XAie_TileLoc(0,1), XAie_LockInit(3, 0)));
return XAIE_OK;
} // mlir_aie_initialize_locks
int mlir_aie_configure_switchboxes(aie_libxaie_ctx_t* ctx) {
  int x, y;
// Core Stream Switch column 0 row 0
x = 0;
y = 0;
__mlir_aie_try(XAie_StrmPktSwMstrPortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 2, /* drop_header */ XAIE_SS_PKT_DONOT_DROP_HEADER, /* arbiter */ 0, /* MSelEn */ 0x1));
__mlir_aie_try(XAie_StrmPktSwMstrPortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 0, /* drop_header */ XAIE_SS_PKT_DONOT_DROP_HEADER, /* arbiter */ 4, /* MSelEn */ 0x8));
__mlir_aie_try(XAie_StrmPktSwMstrPortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), NORTH, 1, /* drop_header */ XAIE_SS_PKT_DONOT_DROP_HEADER, /* arbiter */ 2, /* MSelEn */ 0x8));
__mlir_aie_try(XAie_StrmPktSwMstrPortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), NORTH, 4, /* drop_header */ XAIE_SS_PKT_DONOT_DROP_HEADER, /* arbiter */ 3, /* MSelEn */ 0x8));
__mlir_aie_try(XAie_StrmPktSwMstrPortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), CTRL, 0, /* drop_header */ XAIE_SS_PKT_DONOT_DROP_HEADER, /* arbiter */ 5, /* MSelEn */ 0x8));
__mlir_aie_try(XAie_StrmPktSwSlavePortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 3));
__mlir_aie_try(XAie_StrmPktSwSlaveSlotEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 3, /* slot */ 0, /* packet */ XAie_PacketInit(27,0), /* mask */ 0x1F, /* msel */ 3, /* arbiter */ 2));
__mlir_aie_try(XAie_StrmPktSwSlavePortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 3));
__mlir_aie_try(XAie_StrmPktSwSlaveSlotEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 3, /* slot */ 1, /* packet */ XAie_PacketInit(2,0), /* mask */ 0x6, /* msel */ 3, /* arbiter */ 3));
__mlir_aie_try(XAie_StrmPktSwSlavePortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 3));
__mlir_aie_try(XAie_StrmPktSwSlaveSlotEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 3, /* slot */ 2, /* packet */ XAie_PacketInit(15,0), /* mask */ 0x1F, /* msel */ 3, /* arbiter */ 5));
__mlir_aie_try(XAie_StrmPktSwSlavePortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), CTRL, 0));
__mlir_aie_try(XAie_StrmPktSwSlaveSlotEnable(&(ctx->DevInst), XAie_TileLoc(x,y), CTRL, 0, /* slot */ 0, /* packet */ XAie_PacketInit(15,0), /* mask */ 0x1F, /* msel */ 3, /* arbiter */ 4));
__mlir_aie_try(XAie_StrmPktSwSlavePortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), NORTH, 2));
__mlir_aie_try(XAie_StrmPktSwSlaveSlotEnable(&(ctx->DevInst), XAie_TileLoc(x,y), NORTH, 2, /* slot */ 0, /* packet */ XAie_PacketInit(2,0), /* mask */ 0x1F, /* msel */ 0, /* arbiter */ 0));
// Core Stream Switch column 0 row 1
x = 0;
y = 1;
__mlir_aie_try(XAie_StrmPktSwMstrPortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), DMA, 0, /* drop_header */ XAIE_SS_PKT_DROP_HEADER, /* arbiter */ 2, /* MSelEn */ 0x1));
__mlir_aie_try(XAie_StrmPktSwMstrPortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), DMA, 1, /* drop_header */ XAIE_SS_PKT_DROP_HEADER, /* arbiter */ 3, /* MSelEn */ 0x1));
__mlir_aie_try(XAie_StrmPktSwMstrPortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 2, /* drop_header */ XAIE_SS_PKT_DONOT_DROP_HEADER, /* arbiter */ 0, /* MSelEn */ 0x1));
__mlir_aie_try(XAie_StrmPktSwMstrPortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), NORTH, 1, /* drop_header */ XAIE_SS_PKT_DONOT_DROP_HEADER, /* arbiter */ 5, /* MSelEn */ 0x8));
__mlir_aie_try(XAie_StrmPktSwMstrPortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), NORTH, 5, /* drop_header */ XAIE_SS_PKT_DONOT_DROP_HEADER, /* arbiter */ 1, /* MSelEn */ 0x1));
__mlir_aie_try(XAie_StrmPktSwMstrPortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), CTRL, 0, /* drop_header */ XAIE_SS_PKT_DONOT_DROP_HEADER, /* arbiter */ 4, /* MSelEn */ 0x8));
__mlir_aie_try(XAie_StrmPktSwSlavePortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 1));
__mlir_aie_try(XAie_StrmPktSwSlaveSlotEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 1, /* slot */ 0, /* packet */ XAie_PacketInit(27,0), /* mask */ 0x1F, /* msel */ 3, /* arbiter */ 5));
__mlir_aie_try(XAie_StrmPktSwSlavePortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 4));
__mlir_aie_try(XAie_StrmPktSwSlaveSlotEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 4, /* slot */ 0, /* packet */ XAie_PacketInit(26,0), /* mask */ 0x1F, /* msel */ 3, /* arbiter */ 4));
__mlir_aie_try(XAie_StrmPktSwSlavePortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 4));
__mlir_aie_try(XAie_StrmPktSwSlaveSlotEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 4, /* slot */ 1, /* packet */ XAie_PacketInit(3,0), /* mask */ 0x1F, /* msel */ 0, /* arbiter */ 2));
__mlir_aie_try(XAie_StrmPktSwSlavePortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), DMA, 1));
__mlir_aie_try(XAie_StrmPktSwSlaveSlotEnable(&(ctx->DevInst), XAie_TileLoc(x,y), DMA, 1, /* slot */ 0, /* packet */ XAie_PacketInit(2,0), /* mask */ 0x1F, /* msel */ 0, /* arbiter */ 0));
__mlir_aie_try(XAie_StrmPktSwSlavePortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), NORTH, 0));
__mlir_aie_try(XAie_StrmPktSwSlaveSlotEnable(&(ctx->DevInst), XAie_TileLoc(x,y), NORTH, 0, /* slot */ 0, /* packet */ XAie_PacketInit(1,0), /* mask */ 0x1F, /* msel */ 0, /* arbiter */ 3));
__mlir_aie_try(XAie_StrmPktSwSlavePortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), DMA, 0));
__mlir_aie_try(XAie_StrmPktSwSlaveSlotEnable(&(ctx->DevInst), XAie_TileLoc(x,y), DMA, 0, /* slot */ 0, /* packet */ XAie_PacketInit(0,0), /* mask */ 0x1F, /* msel */ 0, /* arbiter */ 1));
// Core Stream Switch column 0 row 2
x = 0;
y = 2;
__mlir_aie_try(XAie_StrmPktSwMstrPortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), DMA, 0, /* drop_header */ XAIE_SS_PKT_DROP_HEADER, /* arbiter */ 0, /* MSelEn */ 0x1));
__mlir_aie_try(XAie_StrmPktSwMstrPortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 0, /* drop_header */ XAIE_SS_PKT_DONOT_DROP_HEADER, /* arbiter */ 1, /* MSelEn */ 0x1));
__mlir_aie_try(XAie_StrmPktSwMstrPortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), CTRL, 0, /* drop_header */ XAIE_SS_PKT_DONOT_DROP_HEADER, /* arbiter */ 5, /* MSelEn */ 0x8));
__mlir_aie_try(XAie_StrmPktSwSlavePortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 1));
__mlir_aie_try(XAie_StrmPktSwSlaveSlotEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 1, /* slot */ 0, /* packet */ XAie_PacketInit(27,0), /* mask */ 0x1F, /* msel */ 3, /* arbiter */ 5));
__mlir_aie_try(XAie_StrmPktSwSlavePortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), DMA, 0));
__mlir_aie_try(XAie_StrmPktSwSlaveSlotEnable(&(ctx->DevInst), XAie_TileLoc(x,y), DMA, 0, /* slot */ 0, /* packet */ XAie_PacketInit(1,0), /* mask */ 0x1F, /* msel */ 0, /* arbiter */ 1));
__mlir_aie_try(XAie_StrmPktSwSlavePortEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 5));
__mlir_aie_try(XAie_StrmPktSwSlaveSlotEnable(&(ctx->DevInst), XAie_TileLoc(x,y), SOUTH, 5, /* slot */ 0, /* packet */ XAie_PacketInit(0,0), /* mask */ 0x1F, /* msel */ 0, /* arbiter */ 0));
// ShimMux column 0 row 0
// NOTE ShimMux always connects from the south as directions are defined relative to the tile stream switch
x = 0;
y = 0;
__mlir_aie_try(XAie_EnableShimDmaToAieStrmPort(&(ctx->DevInst), XAie_TileLoc(x,y), 3));
__mlir_aie_try(XAie_EnableAieToShimDmaStrmPort(&(ctx->DevInst), XAie_TileLoc(x,y), 2));
return XAIE_OK;
} // mlir_aie_configure_switchboxes

int mlir_aie_configure_cascade(aie_libxaie_ctx_t* ctx) {
return XAIE_OK;
} // mlir_aie_configure_cascade

// buffer objFifo_in1_cons_buff_0 with unsupported type memref<64x64xi8>;
// buffer objFifo_in1_cons_buff_1 with unsupported type memref<64x64xi8>;
// buffer objFifo_out1_buff_0 with unsupported type memref<64x64xi8>;
// buffer objFifo_out1_buff_1 with unsupported type memref<64x64xi8>;
int mlir_aie_acquire_objFifo_in1_cons_prod_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 0;
  return XAie_LockAcquire(&(ctx->DevInst), XAie_TileLoc(0,2), XAie_LockInit(id,value), timeout);
}
int mlir_aie_release_objFifo_in1_cons_prod_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 0;
  return XAie_LockRelease(&(ctx->DevInst), XAie_TileLoc(0,2), XAie_LockInit(id,value), timeout);
}
int mlir_aie_acquire_objFifo_in1_cons_cons_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 1;
  return XAie_LockAcquire(&(ctx->DevInst), XAie_TileLoc(0,2), XAie_LockInit(id,value), timeout);
}
int mlir_aie_release_objFifo_in1_cons_cons_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 1;
  return XAie_LockRelease(&(ctx->DevInst), XAie_TileLoc(0,2), XAie_LockInit(id,value), timeout);
}
int mlir_aie_acquire_objFifo_out1_prod_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 2;
  return XAie_LockAcquire(&(ctx->DevInst), XAie_TileLoc(0,2), XAie_LockInit(id,value), timeout);
}
int mlir_aie_release_objFifo_out1_prod_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 2;
  return XAie_LockRelease(&(ctx->DevInst), XAie_TileLoc(0,2), XAie_LockInit(id,value), timeout);
}
int mlir_aie_acquire_objFifo_out1_cons_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 3;
  return XAie_LockAcquire(&(ctx->DevInst), XAie_TileLoc(0,2), XAie_LockInit(id,value), timeout);
}
int mlir_aie_release_objFifo_out1_cons_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 3;
  return XAie_LockRelease(&(ctx->DevInst), XAie_TileLoc(0,2), XAie_LockInit(id,value), timeout);
}
int mlir_aie_acquire_objFifo_in0_cons_prod_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 0;
  return XAie_LockAcquire(&(ctx->DevInst), XAie_TileLoc(0,1), XAie_LockInit(id,value), timeout);
}
int mlir_aie_release_objFifo_in0_cons_prod_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 0;
  return XAie_LockRelease(&(ctx->DevInst), XAie_TileLoc(0,1), XAie_LockInit(id,value), timeout);
}
int mlir_aie_acquire_objFifo_in0_cons_cons_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 1;
  return XAie_LockAcquire(&(ctx->DevInst), XAie_TileLoc(0,1), XAie_LockInit(id,value), timeout);
}
int mlir_aie_release_objFifo_in0_cons_cons_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 1;
  return XAie_LockRelease(&(ctx->DevInst), XAie_TileLoc(0,1), XAie_LockInit(id,value), timeout);
}
int mlir_aie_acquire_objFifo_out0_prod_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 2;
  return XAie_LockAcquire(&(ctx->DevInst), XAie_TileLoc(0,1), XAie_LockInit(id,value), timeout);
}
int mlir_aie_release_objFifo_out0_prod_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 2;
  return XAie_LockRelease(&(ctx->DevInst), XAie_TileLoc(0,1), XAie_LockInit(id,value), timeout);
}
int mlir_aie_acquire_objFifo_out0_cons_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 3;
  return XAie_LockAcquire(&(ctx->DevInst), XAie_TileLoc(0,1), XAie_LockInit(id,value), timeout);
}
int mlir_aie_release_objFifo_out0_cons_lock(aie_libxaie_ctx_t* ctx, int value, int timeout) {
  const int id = 3;
  return XAie_LockRelease(&(ctx->DevInst), XAie_TileLoc(0,1), XAie_LockInit(id,value), timeout);
}
