//===- ADFGenerateCppGraph.cpp ---------------------------------------*- C++ -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2021 Xilinx Inc.
//
//===----------------------------------------------------------------------===//

#include <iostream>
#include <unordered_map>
#include <vector>
#include "mlir/IR/Attributes.h"
#include "mlir/Dialect/StandardOps/IR/Ops.h"
#include "mlir/IR/BuiltinOps.h"
#include "mlir/Pass/Pass.h"
#include "aie/Dialect/ADF/ADFDialect.h"


using namespace mlir;
using namespace xilinx;
using namespace xilinx::ADF;

struct GraphInfo {
  std::string graphName;
  std::string graphInputName;
  std::string graphOutputName;
  bool isStream;
  std::string dataAccessMechanism;
  uint32_t windowSize;
  // maps kernel symbol to kernel cnt, kcnt is used for adf c++ kernel instantiation name
  // std::unordered_map<std::string, std::string> kernelSymbol2KernelCntName; 
  std::unordered_map<std::string, std::string> kernelSymbol2KernelCntName; 
  std::unordered_map<std::string, int> kernelName2InputPortOrders; 
  std::unordered_map<std::string, int> kernelName2OutputPortOrders; 
};


struct ADFGenerateCppGraphPass : public ADFGenerateCppGraphBase<ADFGenerateCppGraphPass> { GraphInfo info;
  uint32_t netCnt = 0;
  bool kernelHeaderDumped = false;

  // Entry point for the pass.
  void runOnOperation() override {
    Operation *op = getOperation();

    // should have a better way in llvm/mlir
    for (Region &region : op->getRegions()) {
      for (Block &block : region.getBlocks()) {
        int kcnt = 1;
        for (Operation &op : block.getOperations()) {
          if (op.getName().getStringRef() == "builtin.func") {
            dumpKernelFunctions(&op);

            // collect and initialize some kernel info 
            if (auto attr = op.getAttrOfType<StringAttr>("sym_name")) {
              std::string s = attr.getValue().str();
              info.kernelSymbol2KernelCntName[s] = "k" + std::to_string(kcnt);
              kcnt++;
              info.kernelName2InputPortOrders[s] = 0; //initialize
              info.kernelName2OutputPortOrders[s] = 0; //initialize
            }

          } else if (op.getName().getStringRef() == "ADF.graph") {
            // printOperation(&op);
            assert(!op.getAttrs().empty());
            if (auto attr = op.getAttrOfType<StringAttr>("graph_name")) {
              info.graphName = attr.getValue().str();
            }

            if (auto attr = op.getAttrOfType<StringAttr>("graph_input_name")) {
              info.graphInputName = attr.getValue().str();
            }

            if (auto attr = op.getAttrOfType<StringAttr>("graph_output_name")) {
              info.graphOutputName = attr.getValue().str();
            }

            dumpClassUpperSkeleton();  
            processGraphOpInfo(&op); 
          }
        }
      }
    }
    llvm::outs() << "-----------------------------------------------------------------------------\n\n\n\n\n";
  }


  void dumpKernelFunctions(Operation *kernelOp) {
    if (!kernelHeaderDumped) {
      llvm::outs() << "\n\n-------------Generated by ADFGenerateCppGraph pass, don't edit!-------------\n";
      llvm::outs() << "----------------- kernel.h -----------------------------------------------------\n" ;
      llvm::outs() << "#ifndef FUNCTION_KERNELS_H\n";
      llvm::outs() << "#define FUNCTION_KERNELS_H\n\n";
      kernelHeaderDumped = true;
    }

    if (auto attr = kernelOp->getAttrOfType<StringAttr>("sym_name")) {
      std::string kernel_name = attr.getValue().str();
      llvm::outs() << "void " << kernel_name << "(";
    }


    if (auto argAttrs = kernelOp->getAttrOfType<ArrayAttr>("arg_attrs")) {
      auto inCnt = 0;
      for (Attribute argAttr : argAttrs) {
        llvm::outs() << "input_";
        DictionaryAttr dictAttr = argAttr.cast<DictionaryAttr>();
        if (auto attr = dictAttr.get("ADF.data_access")) {
          auto dataAccessStr = attr.dyn_cast<StringAttr>().getValue().str();
          llvm::outs() << dataAccessStr << "_";
        }
        if (auto attr = dictAttr.get("ADF.blk_form")) {
          auto blk_form = attr.dyn_cast<StringAttr>().getValue().str();
          llvm::outs() << blk_form;
        }
        if (auto attr = dictAttr.get("ADF.blk_unit")) {
          auto blk_unit = attr.dyn_cast<IntegerAttr>().getValue().getZExtValue();
          llvm::outs() << blk_unit 
                       << " * "
                       << "in"
                       << inCnt
                       << ", ";
        }
        inCnt++;
      }
    }

    if (auto resAttrs = kernelOp->getAttrOfType<ArrayAttr>("res_attrs")) {
      auto outCnt = 0;
      llvm::outs() << "output_";
      for (Attribute resAttr : resAttrs) {
        DictionaryAttr dictAttr = resAttr.cast<DictionaryAttr>();
        if (auto attr = dictAttr.get("ADF.data_access")) {
          auto dataAccessStr = attr.dyn_cast<StringAttr>().getValue().str();
          llvm::outs() << dataAccessStr << "_";
        }
        if (auto attr = dictAttr.get("ADF.blk_form")) {
          auto blk_form = attr.dyn_cast<StringAttr>().getValue().str();
          llvm::outs() << blk_form;
        }
        if (auto attr = dictAttr.get("ADF.blk_unit")) {
          auto blk_unit = attr.dyn_cast<IntegerAttr>().getValue().getZExtValue();
          llvm::outs() << blk_unit 
                       << " * "
                       << "out"
                       << outCnt
                       << ");\n\n";
        }
        outCnt++;
      }
    }

  }

  void dumpClassUpperSkeleton() {
    llvm::outs() << "#endif\n"; //FIXME: better arrangement for kernel.h ending?
    llvm::outs() << "-----------------------------------------------------------------------------\n\n\n\n\n";
    llvm::outs() << "\n\n------------- Generated by ADFGenerateCppGraph pass, don't edit! -------------\n";
    llvm::outs() << "----------------- "; 
    llvm::outs() << info.graphName; 
    llvm::outs() << ".cpp -----------------------------------------------\n";
    llvm::outs() << "#include <adf.h>\n";
    llvm::outs() << "#include \"kernels.h\"\n";
    llvm::outs() << "using namespace adf;\n";
    llvm::outs() << "class " << info.graphName << "Graph : public graph {\n";
    llvm::outs() << "private:\n";
    for (const auto &itr : info.kernelSymbol2KernelCntName) {
      llvm::outs() << "  kernel "
                   << itr.second 
                   << ";\n";

    }

    llvm::outs() << "\npublic:\n";
    llvm::outs() << "  input_port " 
                 << info.graphInputName
                 << ";\n";
    llvm::outs() << "  output_port " 
                 << info.graphOutputName
                 << ";\n";
    llvm::outs() << "\n  "
                 << info.graphName
                 << "Graph() {\n";
    // initialize the kernel instances in the adf c++ graph
    for (const auto &itr : info.kernelSymbol2KernelCntName) {
      llvm::outs()  << "    "
                    << itr.second 
                    << " = kernel::create("
                    << itr.first
                    << ");\n";
    }

    llvm::outs() << "\n";
  }

  void processGraphOpInfo(Operation *graphOp) {
    for (Region &region : graphOp->getRegions()) {
      for (Block &block : region.getBlocks()) {
        for (Operation &op : block.getOperations()) {
          if (op.getName().getStringRef() == "ADF.create_ginp") {
            ArrayAttr argAttrs = op.getAttrOfType<ArrayAttr>("value");
            info.isStream = argAttrs[0].cast<IntegerAttr>().getValue().getZExtValue();
            if (info.isStream) {
              info.dataAccessMechanism = "stream";
              info.windowSize = argAttrs[1].cast<IntegerAttr>().getValue().getZExtValue();
              assert(info.windowSize == -1);
            } else {
              info.dataAccessMechanism = "window";
              info.windowSize = argAttrs[1].cast<IntegerAttr>().getValue().getZExtValue();
            }

            visitOpResultUsers (&op, true);
          } else if (op.getName().getStringRef() == "ADF.create_kernel") {
            visitOpResultUsers (&op, false);
          } else if (op.getName().getStringRef() == "ADF.create_gout") {
            ;
            // the graph output should have no users in adf, do nothing here 
          }
        } // all op visited

        llvm::outs() << "  }\n";
        llvm::outs() << "}\n\n";

      }
    }
  }


  void visitOpResultUsers (Operation *driverOp, bool DriverIsGraphInput) {
    if (DriverIsGraphInput) {
      for (auto indexedResult : llvm::enumerate(driverOp->getResults())) {
        Value result = indexedResult.value();
        for (Operation *userOp : result.getUsers()) {
          if (userOp->getName().getStringRef() == "ADF.create_kernel") {
            if (auto attr = userOp->getAttrOfType<FlatSymbolRefAttr>("callee")) {
              std::string s = attr.getValue().str();
              std::string userKernelName = info.kernelSymbol2KernelCntName[s];
              int kInpPortOrders = info.kernelName2InputPortOrders[s]++;
              llvm::outs()   << "    connect<"
                             << info.dataAccessMechanism;
              if (info.isStream) {
                llvm::outs() << "> n";
              } else {
                llvm::outs() << "<" 
                             << info.windowSize 
                             << ">> n";
              }          
              llvm::outs()   << netCnt 
                             <<  " ("  
                             << info.graphInputName 
                             << ", "
                             << userKernelName
                             << ".in["
                             << kInpPortOrders
                             <<"]);\n"; // todo: use kport_cnt
            }
            netCnt++;
          } 

          // todo: kernel should not drive graph input, add an mlir verifier condition
        }
      }
    } else { // the driver is another Kernel
      // step-1: get driver kernel name 
      std::string driverKernelName;
      
      int kOutPortOrders;
      if (auto attr = driverOp->getAttrOfType<FlatSymbolRefAttr>("callee")) {
        std::string s = attr.getValue().str();
        driverKernelName = info.kernelSymbol2KernelCntName[s];
        kOutPortOrders = info.kernelName2OutputPortOrders[s]++;
      }

      // step-2: get all the users and print out the c++
      for (auto indexedResult : llvm::enumerate(driverOp->getResults())) {
        Value result = indexedResult.value();
        for (Operation *userOp : result.getUsers()) {
          if (userOp->getName().getStringRef() == "ADF.create_kernel") {
            if (auto attr = userOp->getAttrOfType<FlatSymbolRefAttr>("callee")) {
              std::string s = attr.getValue().str();
              auto userKernelName = info.kernelSymbol2KernelCntName[s];
              int  kInpPortOrders = info.kernelName2InputPortOrders[s]++;
              llvm::outs()   << "    connect<"
                             << info.dataAccessMechanism;
              if (info.isStream) {
                llvm::outs() << "> n";
              } else {
                llvm::outs() << "<" 
                             << info.windowSize 
                             << ">> n";
              }          
              llvm::outs()   << netCnt 
                             <<  " ("  
                             << driverKernelName
                             << ".out["
                             << kOutPortOrders
                             << "]"
                             << ", "
                             << userKernelName
                             << ".in["
                             << kInpPortOrders
                             << "]);\n"; 
            }
            netCnt++;
          } else if (userOp->getName().getStringRef() == "ADF.create_gout") {
            llvm::outs()   << "    connect<"
                           << info.dataAccessMechanism;
            if (info.isStream) {
              llvm::outs() << "> n";
            }  else {
              llvm::outs() << "<" 
                           << info.windowSize 
                           << ">> n";
            }          
            llvm::outs()   << netCnt 
                           <<  " ("  
                           << driverKernelName
                           << ".out["
                           << kOutPortOrders
                           << "]"
                           << ", "
                           << info.graphOutputName
                           << ");\n"; 
            netCnt++;
          }

          // todo: kernel should not drive graph input, add an mlir verifier condition
        }
      }
    }
  }

  void printOperation(Operation *op) {
    // Print the operation itself and some of its properties
    printIndent() << "visiting op: '" << op->getName() << "' with "
                  << op->getNumOperands() << " operands and "
                  << op->getNumResults() << " results\n";
    // Print the operation attributes
    if (!op->getAttrs().empty()) {
      printIndent() << op->getAttrs().size() << " attributes:\n";
      for (NamedAttribute attr : op->getAttrs())
        printIndent() << " - '" << attr.first << "' : '" << attr.second
                      << "'\n";
    }
  }

  /// Manages the indentation as we traverse the IR nesting.
  int indent;
  struct IdentRAII {
    int &indent;
    IdentRAII(int &indent) : indent(indent) {}
    ~IdentRAII() { --indent; }
  };
  void resetIndent() { indent = 0; }
  IdentRAII pushIndent() { return IdentRAII(++indent); }

  llvm::raw_ostream &printIndent() {
    for (int i = 0; i < indent; ++i)
      llvm::outs() << "  ";
    return llvm::outs();
  }
};


std::unique_ptr<OperationPass<ModuleOp>>
xilinx::ADF::createADFGenerateCppGraphPass() {
  return std::make_unique<ADFGenerateCppGraphPass>();
}