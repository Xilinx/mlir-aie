//===- AIETargetCDO.cpp -----------------------------------------*- C++ -*-===//
//
// Copyright (C) 2023, Advanced Micro Devices, Inc. All rights reserved.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "AIETargetShared.h"
#include "AIETargets.h"

#include "aie/Dialect/AIE/IR/AIEDialect.h"
#include "aie/Dialect/AIEX/IR/AIEXDialect.h"

#include "mlir/IR/Attributes.h"
#include "mlir/IR/IRMapping.h"
#include "mlir/Pass/Pass.h"
#include "mlir/Tools/mlir-translate/MlirTranslateMain.h"

#include "llvm/ADT/StringExtras.h"
#include "llvm/IR/Module.h"

using namespace mlir;
using namespace xilinx;
using namespace xilinx::AIE;
using namespace xilinx::AIEX;

namespace xilinx {
namespace AIE {

int maxCol{0}, minCol{0};
static std::string numColsStr() { return std::to_string(1 + maxCol - minCol); }

static std::string cdoGenFileHeader() {
  std::string str;
  llvm::raw_string_ostream rss(str);
  rss << "/********************************************* Disclaimer "
         "*********************************************/\n"
      << "/* This file is generated by aie-translate. */\n"
      << "/* Changes to this file may cause incorrect behavior. */\n"
      << "\n"
      << "/************************** Constants/Macros "
         "*****************************/\n"
      << "#define HW_GEN                   XAIE_DEV_GEN_AIEML\n"
      << "#define XAIE_NUM_ROWS            6\n"
      << "#define XAIE_NUM_COLS            5\n"
      << "#define XAIE_BASE_ADDR           0x40000000\n"
      << "#define XAIE_COL_SHIFT           25\n"
      << "#define XAIE_ROW_SHIFT           20\n"
      << "#define XAIE_SHIM_ROW            0\n"
      << "#define XAIE_MEM_TILE_ROW_START  1\n"
      << "#define XAIE_MEM_TILE_NUM_ROWS   1\n"
      << "#define XAIE_AIE_TILE_ROW_START  2\n"
      << "#define XAIE_AIE_TILE_NUM_ROWS   4\n"
      << "#define FOR_WRITE                0\n"
      << "#define FOR_READ                 1\n"
      << "#define XAIE_PARTITION_BASE_ADDR 0x0\n"
      << "\n"
      << "/***************************** Includes "
         "*********************************/\n"
      << "//#include <fstream>\n"
      << "extern \"C\"\n"
      << "{\n"
      << "  #include <xaiengine.h>\n"
      << "}\n"
      << "//#include \"adf/adf_api/AIEControlConfig.h\"\n\n"
      << "#define __mlir_aie_try(x) x\n"
      << "static XAie_DmaDimDesc *__mlir_aie_alloc_dim_desc(size_t ndims) {\n"
      << "  XAie_DmaDimDesc *ret = NULL;\n"
      << "  ret = (XAie_DmaDimDesc *)calloc(sizeof(XAie_DmaDimDesc), ndims);\n"
      << "  if(NULL == ret) {\n"
      << "    fprintf(stderr, \"Allocating DmaDimDesc failed.\\n\");\n"
      << "  }\n"
      << "  return ret;\n"
      << "}\n";
  return str;
}

static std::string cdoGenFileFooter() {
  std::string str;
  llvm::raw_string_ostream rss(str);
  rss << "\n\n  class InitializeAIEControl\n"
      << "  {\n"
      << "  public:\n"
      << "    InitializeAIEControl()\n"
      << "    {\n"
      << "      XAie_SetupConfig(ConfigPtr, HW_GEN, XAIE_BASE_ADDR, "
         "XAIE_COL_SHIFT,\n"
      << "                       XAIE_ROW_SHIFT, XAIE_NUM_COLS, "
         "XAIE_NUM_ROWS,\n"
      << "                       XAIE_SHIM_ROW, XAIE_MEM_TILE_ROW_START,\n"
      << "                       XAIE_MEM_TILE_NUM_ROWS, "
         "XAIE_AIE_TILE_ROW_START,\n"
      << "                       XAIE_AIE_TILE_NUM_ROWS);\n"
      << "\n"
      << "      XAie_SetupPartitionConfig(&DevInst, XAIE_PARTITION_BASE_ADDR, "
         "1, "
      << numColsStr() << ");\n"
      << "\n"
      << "      XAie_CfgInitialize(&(DevInst), &ConfigPtr);\n"
      << "\n"
      << "#if defined(__AIESIM__)\n"
      << "#if defined(__CDO__)\n"
      << "      XAie_SetIOBackend(&(DevInst), XAIE_IO_BACKEND_CDO); // Set "
         "aiengine driver library to run for CDO Mode\n"
      << "      XAie_UpdateNpiAddr(&(DevInst), 0x0);\n"
      << "#else\n"
      << "      //AIE driver currently error out XAie_UpdateNpiAddr for "
         "AIESIM\n"
      << "#endif\n"
      << "#else\n"
      << "      XAie_UpdateNpiAddr(&(DevInst), 0x0);\n"
      << "#endif\n"
      << "\n"
      << "#if defined(__AIESIM__) && !defined(__CDO__)\n"
      << "      XAie_TurnEccOff(&DevInst);\n"
      << "#endif\n"
      << "\n"
      << "#if defined(__AIESIM__) && !defined(__CDO__)\n"
      << "      extern unsigned ess_debug;\n"
      << "#else\n"
      << "      unsigned ess_debug = false;\n"
      << "#endif\n"
      << "\n"
      << "#ifdef __EXCLUDE_PL_CONTROL__\n"
      << "      bool exclude_pl_control = true;\n"
      << "#else\n"
      << "      bool exclude_pl_control = false;\n"
      << "#endif\n"
      << "\n"
      << "#ifdef __CDO__\n"
      << "      int trace_config_stream_option = 2;\n"
      << "#else\n"
      << "      int trace_config_stream_option = 0;\n"
      << "#endif\n"
      << "    }\n"
      << "  } initAIEControl;\n\n";
  return str;
}

mlir::LogicalResult AIETranslateToCDO(ModuleOp m, raw_ostream &output) {
  StringRef enable = "XAIE_ENABLE";
  StringRef disable = "XAIE_DISABLE";
  StringRef deviceInstRef = "&DevInst";

  DeviceOp targetOp = *(m.getOps<DeviceOp>().begin());
  auto &target_model = targetOp.getTargetModel();

  output << cdoGenFileHeader();
  output << "XAie_InstDeclare(DevInst, &ConfigPtr);   // Declare global device "
            "instance\n\n";

  //---------------------------------------------------------------------------
  // ppgraph_load_elf
  //---------------------------------------------------------------------------
  output << "bool ppgraph_load_elf(const std::string& work_path, "
            "std::vector<std::string>& elfInfoPath)\n{\n";
  output << "std::string work_dir = (work_path.empty() ?  \"Work\" : "
            "work_path);\n";

  // Load the corresponding ELF file, if necessary.
  for (auto tileOp : targetOp.getOps<TileOp>()) {
    int col = tileOp.colIndex();
    int row = tileOp.rowIndex();
    minCol = std::min(col, minCol);
    maxCol = std::max(col, maxCol);
    if (tileOp.isShimNOCorPLTile()) {
      // Resets no needed with V2 kernel driver
    } else {
      if (auto coreOp = tileOp.getCoreOp()) {
        std::string fileName;
        if (auto fileAttr = coreOp->getAttrOfType<StringAttr>("elf_file")) {
          fileName = std::string(fileAttr.getValue());
        } else {
          fileName = std::string("core_") + std::to_string(col) + "_" +
                     std::to_string(row) + ".elf";
        }
        output << "{\n"
               << "if (XAie_LoadElf(" << deviceInstRef << ", "
               << tileLocStr(col, row) << ", "
               << "(work_dir + \"/" << fileName
               << "\").c_str(), XAIE_ENABLE) != XAIE_OK)\n{\n";
        output
            << "    std::cerr << \"ERROR: Failed to load elf for core(%d,%d)\""
            << " << std::endl;\n    return false;\n}\n"
            << "}\n";
      }
    }
  }
  output << "    return true;\n";
  output << "} // ppgraph_load_elf\n\n";

  //---------------------------------------------------------------------------
  // ppgraph_core_enable
  //---------------------------------------------------------------------------
  output << "void ppgraph_core_enable()\n{\n";
  // Start execution of all the cores.
  for (auto tileOp : targetOp.getOps<TileOp>()) {
    int col = tileOp.colIndex();
    int row = tileOp.rowIndex();
    if (!tileOp.isShimTile()) {
      if (auto coreOp = tileOp.getCoreOp()) {
        output << "XAie_CoreEnable(" << deviceInstRef << ", "
               << tileLocStr(col, row) << ");\n";
      }
    }
  }
  output << "    return;\n";
  output << "} // ppgraph_core_enable\n\n";

  //---------------------------------------------------------------------------
  // enableErrorHandling
  //---------------------------------------------------------------------------
  output << "void enableErrorHandling()\n{\n";
  output << "    XAie_ErrorHandlingInit(" << deviceInstRef << ");\n";
  output << "} // enableErrorHandling\n\n";

  //---------------------------------------------------------------------------
  // ppgraph_init
  //---------------------------------------------------------------------------
  output << "void ppgraph_init(const std::string& work_path)\n{\n";

  for (auto tileOp : targetOp.getOps<TileOp>()) {
    int col = tileOp.colIndex();
    int row = tileOp.rowIndex();
    if (!tileOp.isShimTile()) {
      if (auto coreOp = tileOp.getCoreOp()) {
        output << "XAie_CoreReset(" << deviceInstRef << ", "
               << tileLocStr(col, row) << ");\n";
        output << "XAie_CoreUnreset(" << deviceInstRef << ", "
               << tileLocStr(col, row) << ");\n";
        // Set locks to zero
        output << "for (int l=0; l<16; l++)\n"
               << "  XAie_LockSetValue(" << deviceInstRef << ", "
               << tileLocStr(col, row) << ", XAie_LockInit(l, 0));\n";
      }
    }
  }

  // Set locks with explicit initializers
  for (auto lockOp : targetOp.getOps<LockOp>()) {
    auto tileOp = lockOp.getTileOp();
    int col = tileOp.colIndex();
    int row = tileOp.rowIndex();
    auto id = lockOp.getLockID();
    auto init = lockOp.getInit();
    if (id && init) {
      output << "XAie_LockSetValue(" << deviceInstRef << ", "
             << tileLocStr(col, row) << ", XAie_LockInit(" << *id << ", "
             << *init << "));\n";
    }
  }

  // DMA configuration
  // AieRC XAie_DmaDescInit(XAie_DevInst *DevInst, XAie_DmaDesc *DmaDesc,
  // XAie_LocType Loc); AieRC XAie_DmaSetLock(XAie_DmaDesc *DmaDesc, XAie_Lock
  // Acq, XAie_Lock Rel); AieRC XAie_DmaSetPkt(XAie_DmaDesc *DmaDesc,
  // XAie_Packet Pkt); AieRC XAie_DmaSetOutofOrderBdId(XAie_DmaDesc *DmaDesc, u8
  // OutofOrderBdId); AieRC XAie_DmaSetDoubleBuffer(XAie_DmaDesc *DmaDesc, u64
  // Addr, XAie_Lock Acq, XAie_Lock Rel); AieRC XAie_DmaSetAddrLen(XAie_DmaDesc
  // *DmaDesc, u64 Addr, u32 Len); AieRC XAie_DmaSetMultiDimAddr(XAie_DmaDesc
  // *DmaDesc, XAie_DmaTensor *Tensor, u64 Addr, u32 Len); AieRC
  // XAie_DmaEnableCompression(XAie_DmaDesc *DmaDesc); AieRC
  // XAie_DmaSetNextBd(XAie_DmaDesc *DmaDesc, u8 NextBd, u8 EnableNextBd); AieRC
  // XAie_DmaEnableBd(XAie_DmaDesc *DmaDesc); AieRC
  // XAie_DmaDisableBd(XAie_DmaDesc *DmaDesc); AieRC XAie_DmaSetAxi(XAie_DmaDesc
  // *DmaDesc, u8 Smid, u8 BurstLen, u8 Qos,u8 Cache, u8 Secure); AieRC
  // XAie_DmaSetInterleaveEnable(XAie_DmaDesc *DmaDesc, u8 DoubleBuff, u8
  // IntrleaveCount, u16 IntrleaveCurr); AieRC XAie_DmaWriteBd(XAie_DevInst
  // *DevInst, XAie_DmaDesc *DmaDesc, XAie_LocType Loc, u8 BdNum);

  // AieRC XAie_DmaChannelResetAll(XAie_DevInst *DevInst, XAie_LocType Loc,
  // XAie_DmaChReset Reset); AieRC XAie_DmaChannelReset(XAie_DevInst *DevInst,
  // XAie_LocType Loc, u8 ChNum, XAie_DmaDirection Dir, XAie_DmaChReset Reset);
  // AieRC XAie_DmaChannelPauseStream(XAie_DevInst *DevInst, XAie_LocType Loc,
  // u8 ChNum, XAie_DmaDirection Dir, u8 Pause); AieRC
  // XAie_DmaChannelPauseMem(XAie_DevInst *DevInst, XAie_LocType Loc, u8 ChNum
  // XAie_DmaDirection Dir, u8 Pause); AieRC XAie_DmaChannelConfig(XAie_DevInst
  // *DevInst, XAie_DmaDesc *DmaDesc, XAie_LocType Loc, u8 ChNum,
  // XAie_DmaDirection Dir, u8 RepeatCount, u8 EnTokenIssue, u8 ControllerId);
  // AieRC XAie_DmaChannelPushBdToQueue(XAie_DevInst *DevInst, XAie_LocType Loc,
  // u8 ChNum, XAie_DmaDirection Dir, u8 BdNum); AieRC
  // XAie_DmaChannelEnable(XAie_DevInst *DevInst, XAie_LocType Loc, u8 ChNum,
  // XAie_DmaDirection Dir); AieRC XAie_DmaChannelDisable(XAie_DevInst *DevInst,
  // XAie_LocType Loc, u8 ChNum, XAie_DmaDirection Dir);
  for (auto memOp : targetOp.getOps<MemOp>()) {
    int col = memOp.colIndex();
    int row = memOp.rowIndex();

    DenseMap<Block *, int> blockMap;
    DenseMap<Block *, int> channelMap;

    for (auto &block : memOp.getBody()) {
      for (auto op : block.getOps<DMAStartOp>()) {
        int chNum = op.getChannelIndex();
        channelMap[&block] = chNum;
        auto dest = op.getDest();
        while (dest) {
          channelMap[dest] = chNum;
          dest = dest->getSuccessors()[0];
          if (channelMap.count(dest))
            dest = nullptr;
        }
      }
    }

    // Assign each block a BD number
    int evenBdNum = 0;
    int oddBdNum = 24;
    for (auto &block : memOp.getBody()) {
      if (block.getOps<DMABDOp>().empty())
        continue;
      assert(channelMap.count(&block));
      if (target_model.isMemTile(col, row) && channelMap[&block] & 1)
        blockMap[&block] = oddBdNum++;
      else
        blockMap[&block] = evenBdNum++;
    }

    for (auto &block : memOp.getBody()) {
      bool foundBdPacket = false;
      int packetType = 0;
      int packetID = 0;
      bool foundBd = false;
      int lenA = 0;
      int lenB = 0;
      int bytesA = 0;
      int bytesB = 0;
      int offsetA = 0;
      int BaseAddrA = 0;
      bool hasA = false;
      bool hasB = false;
      StringRef bufA = "0";
      StringRef bufB = "0";
      StringRef AbMode = disable;
      //      StringRef FifoMode = disable; // FIXME: when to enable FIFO mode?
      int ndims = 0;
      ArrayRef<BDDimLayoutAttr> dims;
      for (auto op : block.getOps<DMABDOp>()) {
        foundBd = true;
        ShapedType bufferType =
            op.getBuffer().getType().cast<::mlir::MemRefType>();
        if (op.isA()) {
          BaseAddrA =
              cast<AIE::BufferOp>(op.getBuffer().getDefiningOp()).address();
          lenA = op.getLenValue();
          bytesA = bufferType.getElementTypeBitWidth() / 8;
          offsetA = op.getOffsetValue();
          bufA = "XAIEDMA_TILE_BD_ADDRA";
          hasA = true;
        }
        if (op.isB()) {
          lenB = op.getLenValue();
          bytesB = bufferType.getElementTypeBitWidth() / 8;
          bufB = "XAIEDMA_TILE_BD_ADDRB";
          hasB = true;
        }
        if (op.getDimensions()) {
          dims = *op.getDimensions();
          ndims = dims.size();
        }
      }

      if (hasA && hasB) {
        AbMode = enable;
        if (lenA != lenB)
          llvm::errs() << "ABmode must have matching lengths.\n";
        if (bytesA != bytesB)
          llvm::errs() << "ABmode must have matching element data types.\n";
      }
      int acqValue = 0, relValue = 0;
      StringRef acqEnable = disable;
      StringRef relEnable = disable;
      int acqLockId = 0;
      int relLockId = 0;
      for (auto op : block.getOps<UseLockOp>()) {
        LockOp lock = dyn_cast<LockOp>(op.getLock().getDefiningOp());
        if (op.acquire() || op.acquireGE()) {
          acqEnable = enable;
          acqLockId = lock.getLockIDValue();
          acqValue = op.getLockValue();
          if (op.acquireGE())
            acqValue = -acqValue;
        } else if (op.release()) {
          relEnable = enable;
          relLockId = lock.getLockIDValue();
          relValue = op.getLockValue();
        } else {
          return op.emitOpError("unsupported lock action");
        }
      }

      if (target_model.isMemTile(col, row)) {
        acqLockId += 64;
        relLockId += 64;
        BaseAddrA += 0x80000;
      }

      for (auto op : block.getOps<DMABDPACKETOp>()) {
        foundBdPacket = true;
        packetType = op.getPacketType();
        packetID = op.getPacketID();
      }

      int bdNum = blockMap[&block];
      if (foundBd) {

        // TODO For now, we are going to name each dma desc with loc and bd
        // which we assume is unique. This is strictly not enforced but in
        // practice, this is true
        output << "XAie_DmaDesc " << tileDMAInstStr(col, row, bdNum) << ";\n";
        output << "XAie_DmaDescInit(" << deviceInstRef << ", "
               << tileDMAInstRefStr(col, row, bdNum) << ", "
               << tileLocStr(col, row) << ");\n";
        output << "XAie_DmaSetLock(" << tileDMAInstRefStr(col, row, bdNum)
               << ", "
               << "XAie_LockInit(" << acqLockId << "," << acqValue << "),"
               << "XAie_LockInit(" << relLockId << "," << relValue << "));\n";
        if (0 == ndims) {
          output << "XAie_DmaSetAddrLen(" << tileDMAInstRefStr(col, row, bdNum)
                 << ", /* addrA */ "
                 << "0x" << llvm::utohexstr(BaseAddrA + offsetA) << ", "
                 << " /* len */ " << lenA << " * " << bytesA << ");\n";
        } else {
          generateXAieDmaSetMultiDimAddr(output, ndims, dims, col, row, bdNum,
                                         BaseAddrA, offsetA, lenA, bytesA, "");
        }

        if (block.getNumSuccessors() > 0) {
          Block *nextBlock = block.getSuccessors()[0]; // should have only one
                                                       // successor block
          int nextBdNum = blockMap[nextBlock];
          output << "XAie_DmaSetNextBd(" << tileDMAInstRefStr(col, row, bdNum)
                 << ", "
                 << " /* nextbd */ " << nextBdNum << ", "
                 << " /* enableNextBd */ 1);\n"; // TODO Check if br ^end: to
                                                 // disable this?
        }
        if (foundBdPacket) {
          output << "XAie_DmaSetPkt(" << tileDMAInstRefStr(col, row, bdNum)
                 << ", " << packetStr(packetID, packetType) << ");\n";
        }
        output << "XAie_DmaEnableBd(" << tileDMAInstRefStr(col, row, bdNum)
               << ");\n";
        output << "XAie_DmaWriteBd(" << deviceInstRef << ", "
               << tileDMAInstRefStr(col, row, bdNum) << ", "
               << tileLocStr(col, row) << ", "
               << " /* bd */ " << bdNum << ");\n";
      }
    }

    for (auto &block : memOp.getBody()) {
      for (auto op : block.getOps<DMAStartOp>()) {
        int bdNum = blockMap[op.getDest()];

        llvm::StringRef dmaDir = stringifyDMAChannelDir(op.getChannelDir());
        int chNum = op.getChannelIndex();

        output << "XAie_DmaChannelPushBdToQueue(" << deviceInstRef << ", "
               << tileLocStr(col, row) << ", "
               << "/* ChNum */" << chNum
               << ", "
               // TODO hack until physical dialect changes
               << "/* dmaDir */ DMA_" << dmaDir << ", "
               << "/* BdNum */" << bdNum << ");\n";
        output << "XAie_DmaChannelEnable(" << deviceInstRef << ", "
               << tileLocStr(col, row) << ", "
               << "/* ChNum */ " << chNum
               << ", "
               // TODO hack until physical dialect changes
               << "/* dmaDir */ DMA_" << dmaDir << ");\n";
      }
    }
  }
  for (auto memOp : targetOp.getOps<MemTileDMAOp>()) {
    int col = memOp.colIndex();
    int row = memOp.rowIndex();

    DenseMap<Block *, int> blockMap;
    DenseMap<Block *, int> channelMap;

    for (auto &block : memOp.getBody()) {
      for (auto op : block.getOps<DMAStartOp>()) {
        int chNum = op.getChannelIndex();
        channelMap[&block] = chNum;
        auto dest = op.getDest();
        while (dest) {
          channelMap[dest] = chNum;
          dest = dest->getSuccessors()[0];
          if (channelMap.count(dest))
            dest = nullptr;
        }
      }
    }

    // Assign each block a BD number
    int evenBdNum = 0;
    int oddBdNum = 24;
    for (auto &block : memOp.getBody()) {
      if (block.getOps<DMABDOp>().empty())
        continue;
      assert(channelMap.count(&block));
      if (target_model.isMemTile(col, row) && channelMap[&block] & 1)
        blockMap[&block] = oddBdNum++;
      else
        blockMap[&block] = evenBdNum++;
    }

    for (auto &block : memOp.getBody()) {
      bool foundBdPacket = false;
      int packetType = 0;
      int packetID = 0;
      bool foundBd = false;
      int lenA = 0;
      int lenB = 0;
      int bytesA = 0;
      int bytesB = 0;
      int offsetA = 0;
      int BaseAddrA = 0;
      bool hasA = false;
      bool hasB = false;
      StringRef bufA = "0";
      StringRef bufB = "0";
      StringRef AbMode = disable;
      int ndims = 0;
      ArrayRef<BDDimLayoutAttr> dims;
      //      StringRef FifoMode = disable; // FIXME: when to enable FIFO mode?
      for (auto op : block.getOps<DMABDOp>()) {
        foundBd = true;
        ShapedType bufferType =
            op.getBuffer().getType().cast<::mlir::MemRefType>();
        if (op.isA()) {
          BaseAddrA =
              cast<AIE::BufferOp>(op.getBuffer().getDefiningOp()).address();
          lenA = op.getLenValue();
          bytesA = bufferType.getElementTypeBitWidth() / 8;
          offsetA = op.getOffsetValue();
          bufA = "XAIEDMA_TILE_BD_ADDRA";
          hasA = true;
        }
        if (op.isB()) {
          lenB = op.getLenValue();
          bytesB = bufferType.getElementTypeBitWidth() / 8;
          bufB = "XAIEDMA_TILE_BD_ADDRB";
          hasB = true;
        }
        if (op.getDimensions()) {
          dims = *op.getDimensions();
          ndims = dims.size();
        }
      }

      if (hasA && hasB) {
        AbMode = enable;
        if (lenA != lenB)
          llvm::errs() << "ABmode must have matching lengths.\n";
        if (bytesA != bytesB)
          llvm::errs() << "ABmode must have matching element data types.\n";
      }
      int acqValue = 0, relValue = 0;
      StringRef acqEnable = disable;
      StringRef relEnable = disable;
      int acqLockId = 0;
      int relLockId = 0;
      for (auto op : block.getOps<UseLockOp>()) {
        LockOp lock = dyn_cast<LockOp>(op.getLock().getDefiningOp());
        if (op.acquire() || op.acquireGE()) {
          acqEnable = enable;
          acqLockId = lock.getLockIDValue();
          acqValue = op.getLockValue();
          if (op.acquireGE())
            acqValue = -acqValue;
        } else if (op.release()) {
          relEnable = enable;
          relLockId = lock.getLockIDValue();
          relValue = op.getLockValue();
        } else {
          return op.emitOpError("unsupported lock action");
        }
      }

      if (target_model.isMemTile(col, row)) {
        acqLockId += 64;
        relLockId += 64;
        BaseAddrA += 0x80000;
      }

      for (auto op : block.getOps<DMABDPACKETOp>()) {
        foundBdPacket = true;
        packetType = op.getPacketType();
        packetID = op.getPacketID();
      }

      int bdNum = blockMap[&block];
      if (foundBd) {

        // TODO For now, we are going to name each dma desc with loc and bd
        // which we assume is unique. This is strictly not enforced but in
        // practice, this is true
        output << "XAie_DmaDesc " << tileDMAInstStr(col, row, bdNum) << ";\n";
        output << "XAie_DmaDescInit(" << deviceInstRef << ", "
               << tileDMAInstRefStr(col, row, bdNum) << ", "
               << tileLocStr(col, row) << ");\n";
        output << "XAie_DmaSetLock(" << tileDMAInstRefStr(col, row, bdNum)
               << ", "
               << "XAie_LockInit(" << acqLockId << "," << acqValue << "),"
               << "XAie_LockInit(" << relLockId << "," << relValue << "));\n";

        if (0 == ndims) {
          output << "XAie_DmaSetAddrLen(" << tileDMAInstRefStr(col, row, bdNum)
                 << ", /* addrA */ "
                 << "0x" << llvm::utohexstr(BaseAddrA + offsetA) << ", "
                 << " /* len */ " << lenA << " * " << bytesA << ");\n";
        } else {
          generateXAieDmaSetMultiDimAddr(output, ndims, dims, col, row, bdNum,
                                         BaseAddrA, offsetA, lenA, bytesA, "");
        }

        if (block.getNumSuccessors() > 0) {
          Block *nextBlock = block.getSuccessors()[0]; // should have only one
                                                       // successor block
          int nextBdNum = blockMap[nextBlock];
          output << "XAie_DmaSetNextBd(" << tileDMAInstRefStr(col, row, bdNum)
                 << ", "
                 << " /* nextbd */ " << nextBdNum << ", "
                 << " /* enableNextBd */ 1);\n"; // TODO Check if br ^end: to
                                                 // disable this?
        }
        if (foundBdPacket) {
          output << "XAie_DmaSetPkt(" << tileDMAInstRefStr(col, row, bdNum)
                 << ", " << packetStr(packetID, packetType) << ");\n";
        }
        output << "XAie_DmaEnableBd(" << tileDMAInstRefStr(col, row, bdNum)
               << ");\n";
        output << "XAie_DmaWriteBd(" << deviceInstRef << ", "
               << tileDMAInstRefStr(col, row, bdNum) << ", "
               << tileLocStr(col, row) << ", "
               << " /* bd */ " << bdNum << ");\n";
      }
    }

    for (auto &block : memOp.getBody()) {
      for (auto op : block.getOps<DMAStartOp>()) {
        int bdNum = blockMap[op.getDest()];

        llvm::StringRef dmaDir = stringifyDMAChannelDir(op.getChannelDir());
        int chNum = op.getChannelIndex();

        output << "XAie_DmaChannelPushBdToQueue(" << deviceInstRef << ", "
               << tileLocStr(col, row) << ", "
               << "/* ChNum */" << chNum
               << ", "
               // TODO hack until physical dialect changes
               << "/* dmaDir */ DMA_" << dmaDir << ", "
               << "/* BdNum */" << bdNum << ");\n";
        output << "XAie_DmaChannelEnable(" << deviceInstRef << ", "
               << tileLocStr(col, row) << ", "
               << "/* ChNum */ " << chNum
               << ", "
               // TODO hack until physical dialect changes
               << "/* dmaDir */ DMA_" << dmaDir << ");\n";
      }
    }
  }

  // for (auto op : module.getOps<ExternalBufferOp>()) {
  //   if (op.hasName()) {
  //     output << "static u64 _mlir_aie_external_" << op.name().getValue()
  //            << ";\n";
  //     output << "static bool _mlir_aie_external_set_" << op.name().getValue()
  //            << " = false;\n";

  //    output << "void mlir_aie_external_set_addr_" << op.name().getValue()
  //           << "(u64 addr) {\n"
  //           << "    _mlir_aie_external_set_" << op.name().getValue()
  //           << " = true;\n"
  //           << "    _mlir_aie_external_" << op.name().getValue()
  //           << " = addr;\n"
  //           << "}\n";
  //  }
  //}

  //// ShimDMA Config
  ////  int index = 0;
  // for (auto op : module.getOps<ShimDMAOp>()) {
  //   int col = op.colIndex();
  //   int row = op.rowIndex();

  //  DenseMap<Block *, int> blockMap;

  //  {
  //    // Assign each block a BD number
  //    int bdNum = 0;
  //    for (auto &block : op.getBody()) {
  //      if (!block.getOps<DMABDOp>().empty()) {
  //        blockMap[&block] = bdNum;

  //        uint64_t offset = 0;
  //        for (auto op : block.getOps<DMABDOp>()) {
  //          offset = op.getOffsetValue();
  //          auto buffer = cast<xilinx::AIE::ExternalBufferOp>(
  //              op.getBuffer().getDefiningOp());

  //          output << "u64 mlir_aie_external_get_addr_myBuffer_" << col << row
  //                 << "_" << bdNum << "(void) {\n"
  //                 << "    assert(_mlir_aie_external_set_"
  //                 << buffer.name().getValue() << ");\n"
  //                 << "    return _mlir_aie_external_"
  //                 << buffer.name().getValue() << " + "
  //                 << llvm::utohexstr(offset) << ";\n"
  //                 << "}\n";
  //        }

  //        bdNum++;
  //      }
  //    }
  //  }

  //  output << "void mlir_aie_configure_shimdma_" << col << row << "(" << ctx_p
  //         << ") {\n";
  //  for (auto &block : op.getBody()) {
  //    bool foundBdPacket = false;
  //    int packetType = 0;
  //    int packetID = 0;
  //    bool foundBd = false;
  //    int len = 0;
  //    uint64_t bytes = 0;

  //    for (auto op : block.getOps<DMABDOp>()) {
  //      foundBd = true;
  //      len = op.getLenValue();
  //      ShapedType bufferType =
  //          op.getBuffer().getType().cast<::mlir::MemRefType>();
  //      bytes = bufferType.getElementTypeBitWidth() / 8;
  //    }

  //    int acqValue = 0, relValue = 0;
  //    bool hasLock = false;
  //    StringRef acqEnable = disable;
  //    StringRef relEnable = disable;
  //    int lockID = 0;
  //    for (auto op : block.getOps<UseLockOp>()) {
  //      LockOp lock = dyn_cast<LockOp>(op.getLock().getDefiningOp());
  //      lockID = lock.getLockIDValue();
  //      hasLock = true;
  //      if (op.acquire()) {
  //        acqEnable = enable;
  //        acqValue = op.getLockValue();
  //      } else if (op.release()) {
  //        relEnable = enable;
  //        relValue = op.getLockValue();
  //      }
  //    }

  //    for (auto op : block.getOps<DMABDPACKETOp>()) {
  //      foundBdPacket = true;
  //      packetType = op.getPacketType();
  //      packetID = op.getPacketID();
  //    }

  //    int bdNum = blockMap[&block];
  //    if (foundBd) {
  //      output << "XAie_DmaDesc " << tileDMAInstStr(col, row, bdNum) << ";\n";
  //      output << "XAie_DmaDescInit(" << deviceInstRef << ", "
  //             << tileDMAInstRefStr(col, row, bdNum) << ", "
  //             << tileLocStr(col, row) << ");\n";

  //      if (hasLock)
  //        output << "XAie_DmaSetLock(" << tileDMAInstRefStr(col, row, bdNum)
  //               << ", "
  //               << "XAie_LockInit(" << lockID << "," << acqValue << "),"
  //               << "XAie_LockInit(" << lockID << "," << relValue << "));\n";
  //      output << "XAie_DmaSetAddrLen(" << tileDMAInstRefStr(col, row, bdNum)
  //             << ", "
  //             << " /* addr */ "
  //             //               << "0x" << llvm::utohexstr(address) << ", "
  //             << "mlir_aie_external_get_addr_myBuffer_" << col << row << "_"
  //             << bdNum << "(), "
  //             << " /* len */ " << len << " * " << bytes << ");\n";

  //      output << "XAie_DmaSetAxi(" << tileDMAInstRefStr(col, row, bdNum)
  //             << ", "
  //             << "/* smid */ 0, "
  //             << "/* burstlen */ 4, "
  //             << "/* QoS */ 0 , "
  //             << "/* Cache */ 0, "
  //             << "/* Secure */ " << enable << ");\n";

  //      if (block.getNumSuccessors() > 0) {
  //        Block *nextBlock = block.getSuccessors()[0]; // should have only one
  //                                                     // successor block
  //        int nextBdNum = blockMap[nextBlock];
  //        // void XAieDma_ShimBdSetNext(XAieDma_Shim *DmaInstPtr, u8
  //        // BdNum, u8 NextBd);
  //        output << "XAie_DmaSetNextBd(" << tileDMAInstRefStr(col, row, bdNum)
  //               << ", "
  //               << " /* nextbd */ " << nextBdNum << ", "
  //               << " /* enableNextBd */ 1);\n"; // TODO Check if br ^end: to
  //                                               // disable this?
  //      }
  //      if (foundBdPacket) {
  //        output << "XAie_DmaSetPkt(" << tileDMAInstRefStr(col, row, bdNum)
  //               << ", " << packetStr(packetID, packetType) << ");\n";
  //      }
  //      output << "XAie_DmaEnableBd(" << tileDMAInstRefStr(col, row, bdNum)
  //             << ");\n";
  //      output << "XAie_DmaWriteBd(" << deviceInstRef << ", "
  //             << tileDMAInstRefStr(col, row, bdNum) << ", "
  //             << tileLocStr(col, row) << ", "
  //             << " /* bd */ " << bdNum << ");\n";
  //    }
  //  }

  //  for (auto &block : op.getBody()) {
  //    for (auto op : block.getOps<DMAStartOp>()) {
  //      int bdNum = blockMap[op.getDest()];

  //      llvm::StringRef dmaDir = stringifyDMAChannelDir(op.getChannelDir());
  //      int chNum = op.getChannelIndex();

  //      output << "XAie_DmaChannelPushBdToQueue(" << deviceInstRef << ", "
  //             << tileLocStr(col, row) << ", "
  //             << "/* ChNum */" << chNum
  //             << ", "
  //             // TODO hack until physical dialect changes
  //             << "/* dmaDir */ DMA_" << dmaDir << ", "
  //             << "/* BdNum */" << bdNum << ");\n";
  //      output << "XAie_DmaChannelEnable(" << deviceInstRef << ", "
  //             << tileLocStr(col, row) << ", "
  //             << "/* ChNum */ " << chNum
  //             << ", "
  //             // TODO hack until physical dialect changes
  //             << "/* dmaDir */ DMA_" << dmaDir << ");\n";
  //    }
  //  }
  //  output << "} // mlir_aie_configure_shimdma\n\n";
  //}

  ////---------------------------------------------------------------------------
  //// mlir_aie_initialize_locks
  ////---------------------------------------------------------------------------
  // output << "void mlir_aie_initialize_locks(" << ctx_p << ") {\n";
  //// Lock configuration
  // for (auto op : module.getOps<UseLockOp>()) {
  //   int lockVal = op.getLockValue();
  //   int timeOut = op.getTimeout();
  //   LockOp lock = dyn_cast<LockOp>(op.getLock().getDefiningOp());
  //   TileOp tile = dyn_cast<TileOp>(lock.getTile().getDefiningOp());
  //   int col = tile.colIndex();
  //   int row = tile.rowIndex();
  //   int lockID = lock.getLockIDValue();
  //   if (op.acquire()) {
  //     output << "XAie_LockAcquire(" << deviceInstRef << ", "
  //            << tileLocStr(col, row) << ", " << tileLockStr(lockID, lockVal)
  //            << ", " << timeOut << ");\n";
  //   } else if (op.release()) {
  //     output << "XAie_LockRelease(" << deviceInstRef << ", "
  //            << tileLocStr(col, row) << ", " << tileLockStr(lockID, lockVal)
  //            << ", " << timeOut << ");\n";
  //   }
  // }
  // output << "} // mlir_aie_initialize_locks\n";

  //---------------------------------------------------------------------------
  // mlir_aie_configure_switchboxes
  //---------------------------------------------------------------------------
  output << "  int x, y;\n";

  // StreamSwitch (switchbox) configuration
  for (auto switchboxOp : targetOp.getOps<SwitchboxOp>()) {
    Region &r = switchboxOp.getConnections();
    Block &b = r.front();
    bool isEmpty = b.getOps<ConnectOp>().empty() &&
                   b.getOps<MasterSetOp>().empty() &&
                   b.getOps<PacketRulesOp>().empty();
    bool isParam = false;

    if (isa<TileOp>(switchboxOp.getTile().getDefiningOp())) {
      int col = switchboxOp.colIndex();
      int row = switchboxOp.rowIndex();
      if (!isEmpty) {
        output << "// Core Stream Switch column " << col << " row " << row
               << "\n";
        output << "x = " << col << ";\n";
        output << "y = " << row << ";\n";
      }
    } else if (AIEX::SelectOp sel = dyn_cast<AIEX::SelectOp>(
                   switchboxOp.getTile().getDefiningOp())) {
      // parameterize streamswitch's configuration
      isParam = true;
      HerdOp sourceHerd = dyn_cast<HerdOp>(sel.getStartHerd().getDefiningOp());
      std::string sourceHerdName(sourceHerd.name().getValue());

      IterOp iterX = dyn_cast<IterOp>(sel.getIterX().getDefiningOp());
      IterOp iterY = dyn_cast<IterOp>(sel.getIterY().getDefiningOp());
      int startXValue = iterX.getStartValue();
      int endXValue = iterX.getEndValue();
      int strideXValue = iterX.getStrideValue();
      int startYValue = iterY.getStartValue();
      int endYValue = iterY.getEndValue();
      int strideYValue = iterY.getStrideValue();

      std::string startX(sourceHerdName + "_X + " +
                         std::to_string(startXValue));
      std::string endX(sourceHerdName + "_X + " + std::to_string(endXValue));
      std::string startY(sourceHerdName + "_Y + " +
                         std::to_string(startYValue));
      std::string endY(sourceHerdName + "_Y + " + std::to_string(endYValue));

      output << "for (x = " << startX << "; x < " << endX
             << "; x += " << strideXValue << ") {\n";
      output << "for (y = " << startY << "; y < " << endY
             << "; y += " << strideYValue << ") {\n";
    }

    if (switchboxOp.rowIndex() == 0) {
      // FIXME hack for TCT routing
      // TODO Support both channels
      output << "XAie_StrmConnCctEnable(" << deviceInstRef << ", "
             << tileLocStr("x", "y") << ", "
             << "CTRL, 0, "
             << "SOUTH, 0"
             << ");\n";
      output << "{\n"
             << "  //configure DMA_<S2MM/MM2S>_<N>_Ctrl register\n"
             << "  XAie_DmaChannelDesc DmaChannelDescInst;\n"
             << "  XAie_DmaChannelDescInit(" << deviceInstRef << ", "
             << "&DmaChannelDescInst, " << tileLocStr("x", "y") << ");\n"
             << "  XAie_DmaChannelSetControllerId(&DmaChannelDescInst, 0);\n"
             << "  XAie_DmaWriteChannel(" << deviceInstRef << ", "
             << "&DmaChannelDescInst, " << tileLocStr("x", "y")
             << ", 0, DMA_S2MM);\n"
             << "}\n\n"
             << "{\n"
             << "  //configure DMA_<S2MM/MM2S>_<N>_Ctrl register\n"
             << "  XAie_DmaChannelDesc DmaChannelDescInst;\n"
             << "  XAie_DmaChannelDescInit(" << deviceInstRef << ", "
             << "&DmaChannelDescInst, " << tileLocStr("x", "y") << ");\n"
             << "  XAie_DmaChannelSetControllerId(&DmaChannelDescInst, 0);\n"
             << "  XAie_DmaWriteChannel(" << deviceInstRef << ", "
             << "&DmaChannelDescInst, " << tileLocStr("x", "y")
             << ", 1, DMA_S2MM);\n"
             << "}\n\n"
             << "XAie_AieToPlIntfEnable (&DevInst, XAie_TileLoc(x, y), 0, "
                "PLIF_WIDTH_32);\n";
    }

    for (auto connectOp : b.getOps<ConnectOp>()) {
      output << "XAie_StrmConnCctEnable(" << deviceInstRef << ", "
             << tileLocStr("x", "y") << ", "
             << stringifyWireBundle(connectOp.getSourceBundle()).upper() << ", "
             << connectOp.sourceIndex() << ", "
             << stringifyWireBundle(connectOp.getDestBundle()).upper() << ", "
             << connectOp.destIndex() << ");\n";
    }

    for (auto connectOp : b.getOps<MasterSetOp>()) {
      int mask = 0;
      int arbiter = -1;
      for (auto val : connectOp.getAmsels()) {
        AMSelOp amsel = dyn_cast<AMSelOp>(val.getDefiningOp());
        arbiter = amsel.arbiterIndex();
        int msel = amsel.getMselValue();
        mask |= (1 << msel);
      }
      bool isdma = (connectOp.getDestBundle() == WireBundle::DMA);
      // assume a connection going south from row zero gets wired to shimdma by
      // a shimmux. TODO: fix the assumption
      if (!isdma && (switchboxOp.rowIndex() == 0)) {
        isdma = (connectOp.getDestBundle() == WireBundle::South);
      }
      // Flag for overriding DROP_HEADER. TODO: Formalize this in tablegen
      isdma &= !(connectOp->hasAttr("keep_pkt_header"));
      output << "XAie_StrmPktSwMstrPortEnable(" << deviceInstRef << ", "
             << tileLocStr("x", "y") << ", "
             << stringifyWireBundle(connectOp.getDestBundle()).upper() << ", "
             << connectOp.destIndex() << ", "
             << "/* drop_header */ "
             << (isdma ? "XAIE_SS_PKT_DROP_HEADER"
                       : "XAIE_SS_PKT_DONOT_DROP_HEADER")
             << ", "
             << "/* arbiter */ " << arbiter << ", "
             << "/* MSelEn */ "
             << "0x" << llvm::utohexstr(mask) << ");\n";
    }

    for (auto connectOp : b.getOps<PacketRulesOp>()) {
      int slot = 0;
      Block &block = connectOp.getRules().front();
      for (auto slotOp : block.getOps<PacketRuleOp>()) {
        AMSelOp amselOp = dyn_cast<AMSelOp>(slotOp.getAmsel().getDefiningOp());
        int arbiter = amselOp.arbiterIndex();
        int msel = amselOp.getMselValue();
        output << "XAie_StrmPktSwSlavePortEnable(" << deviceInstRef << ", "
               << tileLocStr("x", "y") << ", "
               << stringifyWireBundle(connectOp.getSourceBundle()).upper()
               << ", " << connectOp.sourceIndex() << ");\n";

        // TODO Need to better define packet id,type used here
        output << "XAie_StrmPktSwSlaveSlotEnable(" << deviceInstRef << ", "
               << tileLocStr("x", "y") << ", "
               << stringifyWireBundle(connectOp.getSourceBundle()).upper()
               << ", " << connectOp.sourceIndex() << ", "
               << "/* slot */ " << slot << ", "
               << "/* packet */ " << packetStr(slotOp.valueInt(), /*type*/ 0)
               << ", "
               << "/* mask */ "
               << "0x" << llvm::utohexstr(slotOp.maskInt()) << ", "
               << "/* msel */ " << msel << ", "
               << "/* arbiter */ " << arbiter << ");\n";
        slot++;
      }
    }

    if (isParam) {
      output << "}\n";
      output << "}\n";
    }
  }
  for (auto op : targetOp.getOps<ShimMuxOp>()) {
    Region &r = op.getConnections();
    Block &b = r.front();
    bool isEmpty = b.getOps<ConnectOp>().empty();

    if (isa<TileOp>(op.getTile().getDefiningOp())) {
      int col = op.colIndex();
      int row = op.rowIndex();
      if (!isEmpty) {
        output << "// ShimMux column " << col << " row " << row << "\n";
        output << "// NOTE ShimMux always connects from the south as "
               << "directions are defined relative to the tile stream "
               << "switch\n";
        output << "x = " << col << ";\n";
        output << "y = " << row << ";\n";
      }
    }

    for (auto connectOp : b.getOps<ConnectOp>()) {
      if (connectOp.getSourceBundle() == WireBundle::North) {
        // demux!
        output
            << "XAie_EnableAieToShimDmaStrmPort(" << deviceInstRef << ", "
            << tileLocStr("x", "y")
            << ", "
            //               <<
            //               stringifyWireBundle(connectOp.sourceBundle()).upper()
            << connectOp.sourceIndex() << ");\n";
      } else if (connectOp.getDestBundle() == WireBundle::North) {
        // mux
        output
            << "XAie_EnableShimDmaToAieStrmPort(" << deviceInstRef << ", "
            << tileLocStr("x", "y")
            << ", "
            //               <<
            //               stringifyWireBundle(connectOp.sourceBundle()).upper()
            << connectOp.destIndex() << ");\n";
      }
    }
  }
  for (auto switchboxOp : targetOp.getOps<ShimSwitchboxOp>()) {
    Region &r = switchboxOp.getConnections();
    Block &b = r.front();
    bool isEmpty = b.getOps<ConnectOp>().empty();
    int col = switchboxOp.getCol();
    if (!isEmpty) {
      output << "// Shim Switch column " << col << "\n";
    }
    for (auto connectOp : b.getOps<ConnectOp>()) {
      output << "XAie_StrmConnCctEnable(" << deviceInstRef << ", "
             << tileLocStr(col, 0) << ", "
             << stringifyWireBundle(connectOp.getSourceBundle()).upper() << ", "
             << connectOp.sourceIndex() << ", "
             << stringifyWireBundle(connectOp.getDestBundle()).upper() << ", "
             << connectOp.destIndex() << ");\n";
    }
  }

  output << "} // ppgraph_init\n\n";

  output << cdoGenFileFooter();

  return success();
}
} // namespace AIE
} // namespace xilinx
