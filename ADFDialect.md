<!-- Autogenerated by mlir-tblgen; don't manually edit -->

# 'ADF' Dialect

_Types and operations for the ADF dialect_

This is an MLIR dialect designed to capture the Xilinx Adaptive Data Flow
(ADF) Graph semantics.  This dialect is intended to be converible to/from the
C++ graph syntax, but to represent the graph abstractly, rather than at
the C++ syntactic level.

[TOC]

## Operations

### `ADF.graph` (::xilinx::ADF::GraphOp)

_An ADF graph operation_

Syntax:

```
operation ::= `ADF.graph` `(` $name `)` regions attr-dict
```

An operation that represents an ADF graph.  This operation determines
the name of the graph and contains a single region containing ADF
dialect operations. For example, 

```mlir
ADF.graph("name") {
  your_graph_operations
}
```

Traits: `AlwaysSpeculatableImplTrait`, `NoTerminator`, `SingleBlock`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>



### `ADF.inout_port` (::xilinx::ADF::GraphInOutOp)

_Graph input/output port operation_

Syntax:

```
operation ::= `ADF.inout_port` `(` $name `)` $inp attr-dict `:` `(`type($inp) `)` `->` type(results)
```

An operation representing a dual input/output of an ADF graph.
This is usually used to represent inout parameter val=ues

```mlir
  %2 = ADF.inout_port("name") %3 : (!ADF.interface<!ADF.int32>) -> !ADF.interface<!ADF.int32>                                           
```

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `inp` |  |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; |  |



### `ADF.input_port` (::xilinx::ADF::GraphInputOp)

_Graph input port operation_

Syntax:

```
operation ::= `ADF.input_port` `(` $name `)` $value attr-dict `->` type($output)
```

An operation representing a primary input of an ADF graph. 
It takes an array attribute as the input
argument. The constant values of the array attribute defines the interface
of whole ADF graph. The first index is a bool integer and 1:i1 means the ADF
graph is based on stream data access mechanism; 0:i1 means it's an adf
window data access. If it's the stream mechanism, then the second index
should set to -1, otherwise, the second index should set to the window size.
e.g. 128 byte.  

The input_port will return an output with "interface" type to propagate the
interface values defined by the argument array attributes.

```mlir
  %0 = ADF.input_port("name")  [1:i1, -1:i32] -> !ADF.interface<!ADF.int32>  // for ADF stream access mechanism
```
  or 
```mlir
  %1 = ADF.input_port("name")  [0:i1, 128:i32] -> !ADF.interface<!ADF.int32> // for ADF window access mechanism 
```

Traits: `AlwaysSpeculatableImplTrait`, `ConstantLike`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>value</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr>
<tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| `output` |  |



### `ADF.kernel` (::xilinx::ADF::KernelOp)

_Call and instantiate a kernel node with proper connections_

Syntax:

```
operation ::= `ADF.kernel` $callee `(` $kernel_inputs `)` attr-dict `:` functional-type($kernel_inputs, results)
```

An operation representing a primitive node in the graph.
This operation refers to a function implementing the kernel.  It takes "window"
types for both its variadic inputs and the op_return to propagate the
window size through entire ADF graph. 

```mlir
  %3 = ADF.kernel @kfunc2(%1, %2) :
          (!ADF.interface<!ADF.int32>, !ADF.interface<!ADF.int32>) -> !ADF.interface<!ADF.int32>
```

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>callee</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `kernel_inputs` | variadic of  |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; |  |



### `ADF.output_port` (::xilinx::ADF::GraphOutputOp)

_Graph output port operation_

Syntax:

```
operation ::= `ADF.output_port` `(` $name `)` $inp attr-dict `:` `(`type($inp) `)` `->` type(results)
```

An operation representing a primary input of an ADF graph. 
The operation takes an argument with "window" type and also returns an
"window" type output for final type checking. 

```mlir
  %2 = ADF.output_port("name") %3 : (!ADF.interface<!ADF.int32>) -> !ADF.interface<!ADF.int32>                                           
```

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `inp` |  |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; |  |



## Types

### InterfaceType

Syntax:

```
!ADF.interface<
  mlir::Type   # type
>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `mlir::Type` |  |

### ParameterType

Syntax:

```
!ADF.parameter<
  mlir::Type   # type
>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `mlir::Type` |  |

### StreamType

Syntax:

```
!ADF.stream<
  mlir::Type   # type
>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `mlir::Type` |  |

### WindowType

Syntax:

```
!ADF.window<
  mlir::Type,   # type
  int,   # size
  int   # overlap
>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `mlir::Type` |  |
| size | `int` |  |
| overlap | `int` |  |

### acc48Type

Syntax: `!ADF.acc48`


### acc80Type

Syntax: `!ADF.acc80`


### accfloatType

Syntax: `!ADF.accfloat`


### cacc48Type

Syntax: `!ADF.cacc48`


### cacc80Type

Syntax: `!ADF.cacc80`


### caccfloatType

Syntax: `!ADF.caccfloat`


### cfloatType

Syntax: `!ADF.cfloat`


### cint16Type

Syntax: `!ADF.cint16`


### cint32Type

Syntax: `!ADF.cint32`


### floatType

Syntax: `!ADF.float`


### int8Type

Syntax: `!ADF.int8`


### int16Type

Syntax: `!ADF.int16`


### int32Type

Syntax: `!ADF.int32`


### int64Type

Syntax: `!ADF.int64`


### uint8Type

Syntax: `!ADF.uint8`


### uint16Type

Syntax: `!ADF.uint16`


### uint32Type

Syntax: `!ADF.uint32`


### uint64Type

Syntax: `!ADF.uint64`

