<!---//===- README.md --------------------------*- Markdown -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// Copyright (C) 2022, Advanced Micro Devices, Inc.
// 
//===----------------------------------------------------------------------===//-->

# <ins>Tutorial 3 - communication via objectFifo (local memory)</ins>

This part of the tutorial introduces the `objectFifo` abstraction, which is used to setup communication between tiles without explicit configuration of the dataflow movement. The abstraction is then lowered via MLIR conversion passes onto the physical `mlir-aie` components.

This abstraction consists of several `AIE.objectfifo` operations which are gradually introduced in this tutorial and the following ones. The code in [aie.mlir](aie.mlir) is an implementation of tutorial-3 using the `objectFifo` abstraction. While it is seemingly more complicated than the initial implementation, we will see how powerful this logical abstraction is for more complex designs in future tutorials.

Firstly, an objectFifo is created between tiles (1,4) and (2,4) with the operation:
```
AIE.objectfifo @name (producerTile, {list of consumerTiles}, depth) : elemDatatype`
```
The objectFifo describes both the data allocation and its movement. An objectFifo has a depth, or size, which represents a number of pre-allocated objects of the specified datatype that can be synchronously accessed by actors, which we separate into consumers and producers. In this tutorial, tile (1,4) is the producer tile and tile (2,4) is the consumer tile and the objectFifo established between them has one object of type `memref<256xi32>`. This is shown in the diagram below.

<img src="../../images/OF_shared.png" width="1000">

To achieve deadlock-free communication, actors must acquire and release objects from the objectFifo. In this example, there is only one object to acquire. The operation, 
```
AIE.objectfifo.acquire @name (port, numberElem) : subviewType
```
returns a subview of the objectFifo containing the specified number of elements. Individual elements can then be accessed in an array-like fashion with the operation: 
```
AIE.objectfifo.subview.access(subview, index) : elemDatatype
```
When an object is no longer required for computation, the actor which acquired it should release it with the operation:
```
AIE.objectfifo.release @name (port, numberElem)
``` 
such that other actors may acquire it in the future. The acquire and release operations both take an additional port attribute which can be either "Produce" or "Consume". The use of this attribute will be further described in the `Object FIFO Lowering` section.

# <ins>Object FIFO Lowering</ins>

The objects of an objectFifo each lower into a lock and buffer pair. As such, the `AIE.objectfifo.acquire` and `AIE.objectfifo.release` operations are lowered into `use_lock` operations. Both these operations take a port attribute which can be either "Produce" or "Consume". This attribute is used to determine the lock values to give to the `use_lock` operations in order to achieve the desired synchronisation. For example:
```
AIE.objectfifo.acquire @objFifo (Produce, 1)
AIE.objectfifo.acquire @objFifo (Consume, 1)
```
are each lowered into,
```
AIE.use_lock(%lock14_0, "Acquire", 0)
AIE.use_lock(%lock14_0, "Acquire", 1)
```
where %lock14_0 is the lock generated by the lowering.

Both the lock and buffer are components that are local to a tile and its memory module. The lowering will generate these components in the tile, and in its associated memory module, chosen based on the position of the tiles which were used when creating the objectFifo, such that they are available in shared local memory.

To apply the lowering pass on an mlir source file, use the command below in a fully setup mlir-aie project:
```
aie-opt --aie-canonicalize-device <path to mlir source file> | aie-opt --aie-objectFifo-stateful-transform
```
We note that in the above command there are actually two lowering passes being applied. The first pass will ensure that there exists a target device configuration in the source code, or add one if there isn't. That is the same pass that is used by `aiecc.py`, but needs to be explicitly called when running lowering passes separately. Further details on the device configuration can be found in [tutorial-2b](../../tutorial-2/tutorial-2b/).

Two different lowerings currently exist for objectFifo operations: one is a static lowering that keeps track of acquire / release operations at compile-time and unrolls for-loops to ensure the proper buffer / lock pair is accessed each iteration; the other is a runtime solution which keeps track of acquire / release operations in a global state buffer which is then read to determine the correct buffer to access each iteration through an scf.IndexSwitchOp. Additional details can be found in the [Design Patterns](../../../docs/AIEDesignPatterns.md).

## <ins>Tutorial 3 Lab </ins>

1. Read through the [/objectFifo_ver/aie.mlir](aie.mlir) design. In which tile and its local memory will the objectFifo lowering generate the buffer and its lock? <img src="../../images/answer1.jpg" title="On even rows tiles have local memories to their left, so the shared memory is that of tile (2,4). That is where the lowering will generate the shared buffer and lock." height=25>

2. Run `make` and `make -C aie.mlir.prj/sim` to compile the design with `aiecc.py` and then simulate that design with aiesimulator.

3. Change the locations of tiles (1,4) and (2,4) to (1,3) and (2,3). Navigate to the location of the [/objectFifo_ver/aie.mlir](aie.mlir) design and apply the objectFifo lowering on it. In which tile's local memory module did the lowering generate the buffer and its lock this time? <img src="../../images/answer1.jpg" title="On odd rows tiles have local memories to their right, so the shared memory is that of tile (1,3). That is where the lowering will generate the shared buffer and lock." height=25>

4. Increase the objectFifo size to 2. Apply the objectFifo lowering again. How many buffer/lock pairs are created and in which memory module? <img src="../../images/answer1.jpg" title="2 buffer/lock pairs are created in the shared memory of tile (1,3)." height=25>
