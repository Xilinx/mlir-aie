# pkt2mlir - Control Packet Binary to MLIR Disassembler

`pkt2mlir.py` is a tool that converts AIE NPU control packet binaries into human-readable MLIR format. This is useful for debugging, inspecting compiled configurations, and understanding the control packet operations sent to the NPU.

## Overview

The tool parses binary control packet files generated by `aie-translate --aie-ctrlpkt-to-bin` and reconstructs the equivalent MLIR module containing:
- Device configuration (`aie.device`)
- Tile controller_id attributes (`PacketInfoAttr`)
- Runtime sequences with control packet operations (`aiex.control_packet`)

## Usage

```bash
pkt2mlir.py -f <binary-file> [-d <device-type>]
```

### Options

- `-f`, `-file FILE` : Input control packet binary file (required)
- `-d`, `-device DEVICE` : Target AIE device type (default: npu1)
  - Supported devices: xcvc1902, xcve2302, xcve2802, npu1, npu1_1col, npu1_2col, npu1_3col, npu2, npu2_1col, npu2_2col, npu2_3col, npu2_4col, npu2_5col, npu2_6col, npu2_7col
- `-h`, `--help` : Show help message and exit

## Examples

### Basic Control Packet Operations Round-trip

Generate control packet binary and disassemble it:

```bash
# Create a simple MLIR file with control packets
cat > control_packets.mlir << 'EOF'
module {
  aie.device(npu1) {
    %tile00 = aie.tile(0, 0) {controller_id = #aie.packet_info<pkt_type = 2, pkt_id = 3>}
    
    aiex.runtime_sequence() {
      aiex.control_packet {address = 0x0001F000 : ui32, opcode = 0 : i32, stream_id = 0 : i32, data = array<i32: 2>}
      aiex.control_packet {address = 0x0001F020 : ui32, opcode = 2 : i32, stream_id = 9 : i32, data = array<i32: 3, 4, 5, 6>}
      aiex.control_packet {address = 0x00000400 : ui32, opcode = 1 : i32, stream_id = 2 : i32, length = 4 : i32}
    }
  }
}
EOF

# Compile to binary
aie-translate --aie-ctrlpkt-to-bin control_packets.mlir -o control_packets.bin
```

View the raw control packet binary structure:

```bash
# Inspect binary structure (2 word header + optional data for each packet)
hexdump -C control_packets.bin
```

```
00000000  00 20 00 03 00 1f 00 00  02 00 00 00 00 20 00 03  |. .......... ..|
00000010  09 b1 f0 20 03 00 00 00  04 00 00 00 05 00 00 00  |... ............|
00000020  06 00 00 00 00 20 00 03  02 70 04 00              |..... ...p..|
```

Translate back to MLIR:

```bash
pkt2mlir.py -f control_packets.bin
```

Or specify a different device type:

```bash
pkt2mlir.py -f control_packets.bin -d npu1
```

Output:

```mlir
module {
  aie.device(npu1) {
    %shim_noc_tile_0_0 = aie.tile(0, 0) {controller_id = #aie.packet_info<pkt_type = 2, pkt_id = 3>}
    
    aiex.runtime_sequence @configure() {
      aiex.control_packet {address = 126976 : ui32, data = array<i32: 2>, opcode = 0 : i32, stream_id = 0 : i32}
      aiex.control_packet {address = 127008 : ui32, data = array<i32: 3, 4, 5, 6>, opcode = 2 : i32, stream_id = 9 : i32}
      aiex.control_packet {address = 1024 : ui32, length = 4 : i32, opcode = 1 : i32, stream_id = 2 : i32}
    }
  }
}
```

## Control Packet Binary Format

Each control packet in the binary consists of:

1. **Stream Header** (32 bits):
   - Bit [31]: Even parity bit
   - Bits [14:12]: Packet type (3 bits)
   - Bits [7:0]: Packet ID (8 bits)

2. **Control Packet Header** (32 bits):
   - Bit [31]: Even parity bit
   - Bits [30:24]: Stream ID (7 bits)
   - Bits [23:22]: Opcode (2 bits)
     - `0x0` = Write
     - `0x1` = Read
     - `0x2` = Block write
   - Bits [21:20]: Beats (size-1, 2 bits)
   - Bits [19:0]: Address (20 bits)

3. **Data Payload** (optional, 32-bit words):
   - Present for write (opcode 0x0) and block write (opcode 0x2)
   - Number of words = beats + 1

## Use Cases

- **Debugging**: Inspect what control packets are being sent to the NPU
- **Verification**: Compare generated binaries against expected values
- **Reverse Engineering**: Understand control packet configurations
- **Testing**: Validate round-trip conversion (MLIR → binary → MLIR)
- **Documentation**: Generate human-readable documentation from binaries

## See Also

- `txn2mlir.py` - Transaction binary to MLIR disassembler
- `aie-translate --aie-ctrlpkt-to-bin` - Generate control packet binaries
- `aie-translate --aie-npu-to-binary` - Generate transaction binaries
