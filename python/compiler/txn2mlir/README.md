# txn2mlir - Transaction Binary to MLIR Disassembler

`txn2mlir.py` is a tool that converts AIE NPU transaction binaries into human-readable MLIR format. This is useful for debugging, inspecting compiled configurations, and understanding the runtime sequence of operations sent to the NPU.

## Overview

The tool parses binary transaction files generated by `aie-translate -aie-npu-to-binary` and reconstructs the equivalent MLIR module containing:
- Device configuration (`aie.device`)
- Global memory buffers (`memref.global`)
- Runtime sequences with NPU operations (`aiex.runtime_sequence`)

## Usage

```bash
txn2mlir.py -f <binary-file>
```

### Options

- `-f`, `-file FILE` : Input transaction binary file (required)
- `-h`, `--help` : Show help message and exit

## Examples

### Basic NPU Operations Round-trip

Generate a simple transaction binary and disassemble it:

```bash
# Create a simple MLIR file
cat > simple.mlir << 'EOF'
module {
  aie.device(npu1_1col) {
    memref.global "private" constant @blockwrite_data : memref<2xi32> = dense<[4195328, 0]>
    aiex.runtime_sequence() {
      aiex.npu.maskwrite32 {address = 2301952 : ui32, mask = 2 : ui32, value = 2 : ui32}
      aiex.npu.write32 {address = 2224128 : ui32, value = 2 : ui32}
      %0 = memref.get_global @blockwrite_data : memref<2xi32>
      aiex.npu.blockwrite(%0) {address = 2215936 : ui32} : memref<2xi32>
    }
  }
}
EOF

# Compile to binary
aie-translate -aie-npu-to-binary simple.mlir -o simple.cfg
```

View the raw transaction binary structure:

```bash
# Inspect binary header and operations
hexdump -C simple.cfg
```

```
00000000  00 01 03 06 01 01 00 00  03 00 00 00 5c 00 00 00  |............\...|
00000010  03 00 00 00 00 00 00 00  00 20 23 00 00 00 00 00  |......... #.....|
00000020  02 00 00 00 02 00 00 00  1c 00 00 00 00 00 00 00  |................|
...
```

Translate back to MLIR:

```bash
txn2mlir.py -f simple.cfg
```
```mlir
module {
  aie.device(npu1_1col) {
    memref.global "private" constant @blockwrite_data : memref<2xi32> = dense<[4195328, 0]>
    aiex.runtime_sequence @configure() {
      aiex.npu.maskwrite32 {address = 2301952 : ui32, mask = 2 : ui32, value = 2 : ui32}
      aiex.npu.write32 {address = 2224128 : ui32, value = 2 : ui32}
      %0 = memref.get_global @blockwrite_data : memref<2xi32>
      aiex.npu.blockwrite(%0) {address = 2215936 : ui32} : memref<2xi32>
    }
  }
}
```