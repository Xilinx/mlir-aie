# localbuffer.py -*- Python -*-
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2024 Advanced Micro Devices, Inc.
from collections import defaultdict
import numpy as np

from .. import ir
from ..ir import Module, Context, InsertionPoint, Location, Operation
from ..dialects.aie import buffer
from .worker import Worker
from .program import CurrentDeviceOp, CurrentModule
from .device import Tile


class LocalBuffer(buffer):
    """A LocalBuffer will generate a BufferOp; it is called a LocalBuffer because it should only
    be initialized within a function given to a Worker.
    """

    """This is used to ensure default names are uniquely given within a design"""
    __buf_tile_index = defaultdict(int)

    def __init__(
        self,
        type: type[np.ndarray] | None = None,
        initial_value: np.ndarray | None = None,
        name: str | None = None,
    ):
        """Initialize a LocalBuffer. Placement will be set to the current core.

        Args:
            type (type[np.ndarray] | None, optional): The tensor type representing the buffer to allocate. Defaults to None.
            initial_value (np.ndarray | None, optional): An initial value of the buffer. The type of this should match the given type. Defaults to None.
            name (str | None, optional): The name of the buffer. If None is given, one will be autogenerated. Defaults to None.

        Raises:
            ValueError: Arguments are validated.
        """
        if type is None and initial_value is None:
            raise ValueError("Must provide either type, initial value, or both.")
        if type is None:
            type = np.ndarray[initial_value.shape, np.dtype[initial_value.dtype]]

        # Use context to get current core placement
        current_core_placement = Worker.current_core_placement.get()
        if current_core_placement is None:
            raise ValueError("Can only instantiate Buffer() in a worker function.")

        if not name:
            col = getattr(current_core_placement, "col", None)
            row = getattr(current_core_placement, "row", None)
            if col is not None and hasattr(col, "value"):
                col = col.value
            if row is not None and hasattr(row, "value"):
                row = row.value
            idx = self.__get_index(current_core_placement)
            name = f"buf_{col}_{row}_{idx}"

        # if initial_value is None:
        device_op = get_device_op_from_module()
        block = device_op.regions[0].blocks[0]

        # Count number of tile ops and track last one
        tile_count = 0
        last_tile_op = None
        for op in block.operations:
            if op.name == "aie.tile":
                tile_count += 1
                last_tile_op = op

        ip = None if tile_count == 1 else InsertionPoint(last_tile_op)

        super().__init__(
            tile=current_core_placement,
            datatype=type,
            name=name,
            initial_value=initial_value,
            ip=ip,
        )

    @classmethod
    def __get_index(cls, placement: Tile) -> int:
        idx = cls.__buf_tile_index[placement]
        cls.__buf_tile_index[placement] += 1
        return idx


def get_device_op_from_module():
    module = CurrentModule.get()
    if module is None:
        raise RuntimeError("No MLIR module context available")
    # The device op should be the first (or only) op in the module's body
    for op in module.body.operations:
        if op.name == "aie.device":
            return op
    raise RuntimeError("No aie.device op found in module")
