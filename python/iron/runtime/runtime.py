# runtime.py -*- Python -*-
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2024 Advanced Micro Devices, Inc.

from __future__ import annotations
from collections import defaultdict
from contextlib import contextmanager
import numpy as np


from ... import ir  # type: ignore

from ...dialects.aiex import runtime_sequence
from ...dialects._aiex_ops_gen import dma_await_task, dma_free_task  # type: ignore
from ...helpers.taplib import TensorAccessPattern
from ..dataflow.objectfifo import ObjectFifoHandle
from ..phys.tile import PlacementTile, AnyShimTile
from ..resolvable import Resolvable
from .dmatask import DMATask
from .runtimedata import RuntimeData
from .runtimeendpoint import RuntimeEndpoint
from ..worker import Worker
from .runtimetaskgroup import RuntimeTaskGroup
from .runtimetask import (
    RuntimeTask,
    RuntimeStartTask,
    InlineOpRuntimeTask,
    FinishTaskGroupTask,
)


class Runtime(Resolvable):
    __task_group_index = 0

    def __init__(
        self,
    ) -> Runtime:
        self._rt_data = []
        self._tasks: list[RuntimeTask] = []
        self._fifos = set()
        self._workers = []
        self._open_task_groups = []

    @contextmanager
    def sequence(self, *input_types: type[np.ndarray]):
        try:
            self._rt_data = list(map(RuntimeData, input_types))
            if len(self._rt_data) == 1:
                yield self._rt_data[0]
            else:
                yield tuple(self._rt_data.copy())
        finally:
            if len(self._open_task_groups) != 0:
                tgs_str = ", ".join([str(t) for t in self._open_task_groups])
                raise ValueError(f"Failed to close task groups: {tgs_str}")
            for of_handle in self._fifos:
                # It's very easy to accidentally generate multiple (identical)
                # consumers in the runtime. This bit of code prunes out duplicates.
                if not of_handle._is_prod:
                    fifo_obj = of_handle._object_fifo
                    runtime_cons = None
                    to_remove = []
                    for c in fifo_obj._cons:
                        if isinstance(c.endpoint, RuntimeEndpoint):
                            if not runtime_cons:
                                runtime_cons = c
                            else:
                                if (
                                    c.depth == runtime_cons.depth
                                    and c.dims_from_stream
                                    == runtime_cons.dims_from_stream
                                ):
                                    to_remove.append(c)
                                else:
                                    raise ValueError(
                                        f"Found two different RuntimeEndpoints for consumers of the same ObjectFifo: {fifo_obj}"
                                    )
                    for r in to_remove:
                        fifo_obj._cons.remove(r)

    def task_group(self) -> RuntimeTaskGroup:
        tg = RuntimeTaskGroup(self.__task_group_index)
        self._open_task_groups.append(tg)
        self.__task_group_index += 1
        return tg

    def finish_task_group(self, task_group: RuntimeTaskGroup):
        self._open_task_groups.remove(task_group)
        self._tasks.append(FinishTaskGroupTask(task_group))

    def fill(
        self,
        in_fifo: ObjectFifoHandle,
        source: RuntimeData,
        tap: TensorAccessPattern | None = None,
        task_group: RuntimeTaskGroup | None = None,
        wait: bool = False,
        placement: PlacementTile = AnyShimTile,
    ) -> None:
        if source not in self._rt_data:
            raise ValueError(
                f"Source {source} is not a RuntimeData object generated by sequence()"
            )
        rt_endpoint = RuntimeEndpoint(placement)

        if tap is None:
            tap = source.default_tap()

        in_fifo.endpoint = rt_endpoint
        self._fifos.add(in_fifo)
        self._tasks.append(DMATask(in_fifo, source, tap, task_group, wait))

    def drain(
        self,
        out_fifo: ObjectFifoHandle,
        dest: RuntimeData,
        tap: TensorAccessPattern | None = None,
        task_group: RuntimeTaskGroup | None = None,
        wait: bool = False,
        placement: PlacementTile = AnyShimTile,
    ) -> None:
        if dest not in self._rt_data:
            raise ValueError(
                f"Destination {dest} is not a RuntimeData object generated by sequence()"
            )
        rt_endpoint = RuntimeEndpoint(placement)
        if tap is None:
            tap = dest.default_tap()

        out_fifo.endpoint = rt_endpoint
        self._fifos.add(out_fifo)
        self._tasks.append(DMATask(out_fifo, dest, tap, task_group, wait))

    def start(self, *args: Worker):
        for worker in args:
            if not isinstance(worker, Worker):
                raise ValueError("Runtime can only start Worker objects")
            self._workers.append(worker)
            self._tasks.append(RuntimeStartTask(worker))

    def inline_ops(self, inline_func, inline_args):
        # TODO: should filter args based on some criteria??
        self._tasks.append(InlineOpRuntimeTask(inline_func, inline_args))

    def get_workers(self) -> list[Worker]:
        return self._workers.copy()

    def get_fifos(self) -> list[ObjectFifoHandle]:
        return self._fifos.copy()

    def resolve(
        self,
        loc: ir.Location | None = None,
        ip: ir.InsertionPoint | None = None,
    ) -> None:
        rt_dtypes = [rt_data.arr_type for rt_data in self._rt_data]

        task_group_actions = defaultdict(list)

        @runtime_sequence(*rt_dtypes)
        def sequence(*args):

            for rt_data, rt_data_val in zip(self._rt_data, args):
                rt_data.op = rt_data_val

            no_waits = []
            for task in self._tasks:
                task.resolve()
                if isinstance(task, DMATask):
                    if task.will_wait():
                        if task.task_group:
                            task_group_actions[task.task_group].append(
                                (dma_await_task, [task.task])
                            )
                        else:
                            dma_await_task(task.task)
                            for t in no_waits:
                                dma_free_task(t.task)
                            no_waits = []
                    else:
                        if task.task_group:
                            task_group_actions[task.task_group].append(
                                (dma_free_task, [task.task])
                            )
                        else:
                            no_waits.append(task)
                if isinstance(task, FinishTaskGroupTask):
                    actions = task_group_actions[task.task_group]
                    for fn, args in actions:
                        if fn == dma_await_task:
                            fn(*args)
                    for fn, args in actions:
                        if fn != dma_await_task:
                            fn(*args)
                    task_group_actions[task.task_group] = None
