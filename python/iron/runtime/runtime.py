# runtime.py -*- Python -*-
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2024 Advanced Micro Devices, Inc.

from __future__ import annotations
from collections import defaultdict
from contextlib import contextmanager
import numpy as np


from ... import ir  # type: ignore

from ...dialects.aiex import runtime_sequence
from ...dialects._aiex_ops_gen import dma_await_task, dma_free_task  # type: ignore
from ...helpers.taplib import TensorAccessPattern
from ..dataflow.objectfifo import ObjectFifoHandle
from ..phys.tile import PlacementTile, AnyShimTile
from ..resolvable import Resolvable
from .dmatask import DMATask
from .runtimedata import RuntimeData
from .runtimeendpoint import RuntimeEndpoint
from ..worker import Worker
from .runtimetaskgroup import RuntimeTaskGroup
from .runtimetask import (
    RuntimeTask,
    RuntimeStartTask,
    InlineOpRuntimeTask,
    FinishTaskGroupTask,
)


class Runtime(Resolvable):
    __task_group_index = 0

    def __init__(
        self,
    ) -> Runtime:
        self._rt_data = []
        self._tasks: list[RuntimeTask] = []
        self._fifos = set()
        self._workers = []
        self._open_task_groups = []

    @contextmanager
    def sequence(self, *input_types: type[np.ndarray]):
        try:
            self._rt_data = list(map(RuntimeData, input_types))
            if len(self._rt_data) == 1:
                yield self._rt_data[0]
            else:
                yield tuple(self._rt_data.copy())
        finally:
            if len(self._open_task_groups) != 0:
                tgs_str = [str(t) for t in self._open_task_groups].join(", ")
                raise ValueError(f"Failed to close task groups: {tgs_str}")

    def task_group(self) -> RuntimeTaskGroup:
        tg = RuntimeTaskGroup(self.__task_group_index)
        self._open_task_groups.append(tg)
        self.__task_group_index += 1
        return tg

    def finish_task_group(self, task_group: RuntimeTaskGroup):
        self._open_task_groups.remove(task_group)
        self._tasks.append(FinishTaskGroupTask(task_group))

    def fill(
        self,
        in_fifo: ObjectFifoHandle,
        source: RuntimeData,
        tap: TensorAccessPattern | None = None,
        task_group: RuntimeTaskGroup | None = None,
        wait: bool = False,
        placement: PlacementTile = AnyShimTile,
    ) -> None:
        if source not in self._rt_data:
            raise ValueError(
                f"Source {source} is not a RuntimeData object generated by sequence()"
            )
        rt_endpoint = RuntimeEndpoint(placement)

        if tap is None:
            tap = source.default_tap()

        # There can only be one runtime endpoint in an ObjectFIFO
        if in_fifo in self._fifos:
            ep = in_fifo.get_endpoint()
            if isinstance(ep, RuntimeEndpoint):
                if ep.tile != placement:
                    if ep.tile == AnyShimTile:
                        in_fifo.replace_endpoint(ep, rt_endpoint)
                    else:
                        raise ValueError(
                            f"ObjectFIFO can only have one RuntimeEndpoint: has {ep}, trying to set: {rt_endpoint}"
                        )
        else:
            in_fifo.endpoint = rt_endpoint
            self._fifos.add(in_fifo)
        self._tasks.append(DMATask(in_fifo, source, tap, task_group, wait))

    def drain(
        self,
        out_fifo: ObjectFifoHandle,
        dest: RuntimeData,
        tap: TensorAccessPattern | None = None,
        task_group: RuntimeTaskGroup | None = None,
        wait: bool = False,
        placement: PlacementTile = AnyShimTile,
    ) -> None:
        if dest not in self._rt_data:
            raise ValueError(
                f"Destination {dest} is not a RuntimeData object generated by sequence()"
            )
        rt_endpoint = RuntimeEndpoint(placement)
        if tap is None:
            tap = dest.default_tap()

        if out_fifo in self._fifos:
            existing_endpoints = out_fifo.all_of_endpoints()
            for ep in existing_endpoints:
                if isinstance(ep, RuntimeEndpoint):
                    if ep.tile != placement:
                        ep.place(placement)
                        if ep.tile == AnyShimTile:
                            ep.place(placement)
                        else:
                            raise ValueError(
                                f"ObjectFIFO can only have one RuntimeEndpoint: has {ep}, trying to set: {rt_endpoint}"
                            )
        else:
            out_fifo.endpoint = rt_endpoint
            self._fifos.add(out_fifo)
        self._tasks.append(DMATask(out_fifo, dest, tap, task_group, wait))

    def start(self, *args: Worker):
        for worker in args:
            if not isinstance(worker, Worker):
                raise ValueError("Runtime can only start Worker objects")
            self._workers.append(worker)
            self._tasks.append(RuntimeStartTask(worker))

    def inline_ops(self, inline_func, inline_args):
        # TODO: should filter args based on some criteria??
        self._tasks.append(InlineOpRuntimeTask(inline_func, inline_args))

    def get_workers(self) -> list[Worker]:
        return self._workers.copy()

    def get_fifos(self) -> list[ObjectFifoHandle]:
        return self._fifos.copy()

    def resolve(
        self,
        loc: ir.Location | None = None,
        ip: ir.InsertionPoint | None = None,
    ) -> None:
        rt_dtypes = [rt_data.arr_type for rt_data in self._rt_data]

        task_group_actions = defaultdict(list)

        @runtime_sequence(*rt_dtypes)
        def sequence(*args):

            for rt_data, rt_data_val in zip(self._rt_data, args):
                rt_data.op = rt_data_val

            no_waits = []
            for task in self._tasks:
                task.resolve()
                if isinstance(task, DMATask):
                    if task.will_wait():
                        if task.task_group:
                            task_group_actions[task.task_group].append(
                                (dma_await_task, [task.task])
                            )
                        else:
                            dma_await_task(task.task)
                            for t in no_waits:
                                dma_free_task(t.task)
                            no_waits = []
                    else:
                        if task.task_group:
                            task_group_actions[task.task_group].append(
                                (dma_free_task, [task.task])
                            )
                        else:
                            no_waits.append(task)
                if isinstance(task, FinishTaskGroupTask):
                    actions = task_group_actions[task.task_group]
                    for fn, args in actions:
                        fn(*args)
                    task_group_actions[task.task_group] = None
