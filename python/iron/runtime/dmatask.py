# dmatask.py -*- Python -*-
#
# This file is licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# (c) Copyright 2024 Advanced Micro Devices, Inc.

from ... import ir  # type: ignore

from ...dialects._aiex_ops_gen import dma_start_task  # type: ignore
from ...dialects.aiex import shim_dma_single_bd_task
from ..dataflow import ObjectFifoHandle
from .data import RuntimeData
from ...helpers.taplib import TensorAccessPattern
from .task import RuntimeTask
from .taskgroup import RuntimeTaskGroup


class DMATask(RuntimeTask):
    def __init__(
        self,
        object_fifo: ObjectFifoHandle,
        rt_data: RuntimeData,
        tap: TensorAccessPattern,
        task_group: RuntimeTaskGroup | None = None,
        wait: bool = False,
    ):
        """A RuntimeTask that will resolve to a DMA Operation.

        Args:
            object_fifo (ObjectFifoHandle): The ObjectFifoHandle associated with the operation
            rt_data (RuntimeData): The Runtime buffer associated with the operation.
            tap (TensorAccessPattern): The access pattern associated with the operation.
            task_group (RuntimeTaskGroup | None, optional): The task group associated with the operation. Defaults to None.
            wait (bool, optional): Whether this task should conclude with a call to await or a call to free. Defaults to False.
        """
        self._object_fifo = object_fifo
        self._rt_data = rt_data
        self._tap = tap
        self._wait = wait
        self._task = None
        RuntimeTask.__init__(self, task_group)

    def will_wait(self) -> bool:
        """If this tasks shoudl conclude with an await operation."""
        return self._wait

    @property
    def fifo(self) -> ObjectFifoHandle:
        """The ObjectFifoHandle associated with this task."""
        return self._object_fifo

    @property
    def task(self):
        """The MLIR op generated by resolve(). This handle is used after resolution for await or free operations as
        dictated by a RuntimeTaskGroup Finish operation"""
        if not self._task:
            raise ValueError("Cannot get task before it is created (during resolve())")
        return self._task

    def resolve(
        self,
        loc: ir.Location | None = None,
        ip: ir.InsertionPoint | None = None,
    ) -> None:
        self._task = shim_dma_single_bd_task(
            self._object_fifo.op,
            self._rt_data.op,
            tap=self._tap,
            issue_token=self._wait,
        )
        dma_start_task(self._task)
