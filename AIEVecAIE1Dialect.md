<!-- Autogenerated by mlir-tblgen; don't manually edit -->

# 'aievec_aie1' Dialect

_Types and operations for AIE1 vector dialect_

[TOC]

## Operations

### `aievec_aie1.add` (::xilinx::aievec::aie1::AddOp)

_AIE1 vector add_

AMD-specific advanced add operation that adds two 1-D vectors 
with lane selection. The vector sizes are at least 256 bits.
`$result = `$lhs + $rhs`.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>xstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values |
| `rhs` | vector of any type values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values |



### `aievec_aie1.ext` (::xilinx::aievec::aie1::ExtOp)

_AIE ext_

AMD-specific vector extract intrinsic. Selects contiguous lanes from 
the source vector, and transfers the data from those lanes to the 
result. The lane selection is controlled by index. There are two cases:
1. Extracted vector fills half of the original vector lanes (e.g. extract v64int8 from v128int8)
2. Extracted vector fills a fourth of the original vector lanes (e.g. extract v32int8 from v128int8)
In the first case, index can be 0 or 1. Index 0 extracts the lower half, and index 1 extracts the upper half.
In the second case, index can be 0 to 3. Index 0 extracts the lowest quarter, index 1 the next quarter, and so on.
`$result = ext($source, $index)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>8-bit signless integer attribute whose minimum value is 0 whose maximum value is 8</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | vector of any type values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values |



### `aievec_aie1.mac` (::xilinx::aievec::aie1::FMAOp)

_AIE vector fused multiply-add_

AMD-specific multiply-add operation. It multiplies two 1-D vectors,
and adds the result to an accumulator. The vector sizes are at least
256 bits, and the left operand vector is at least twice the size of
right operand vector. For integers, the lhs and rhs are 8/16/32 bits;
the result and acc are 48-bit or 80-bit accumulator.
`$result = `$lhs * $rhs + $acc`.
Note: the same operator can be used as fmsub operator by setting the
'fmsub' bool to true.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>xstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xstep</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zstep</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>fmsub</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values |
| `rhs` | vector of any type values |
| `acc` | vector of any type values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values |



### `aievec_aie1.mul` (::xilinx::aievec::aie1::MulOp)

_AIE vector multiply_

AMD-specific multiply operation that multiplies two 1-D vectors.
The vector sizes are at least 256 bits, and the left operand vector 
is at least twice the size of right operand vector. For integers, the
lhs and rhs are 8/16/32 bits, and result is a 48-bit or 80-bit accumulator.
`$result = `$lhs * $rhs`.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>xstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xstep</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zstep</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values |
| `rhs` | vector of any type values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values |



### `aievec_aie1.select` (::xilinx::aievec::aie1::SelectOp)

_AIE vector lane selection_

AMD-specific vector lane selection operation. It selects between the
first set of lanes or the second one according to the value in 'select'. 
If the bit in select is 0(1), it returns the value in the first(second) 
set of lanes.
`$result = `select32($select, $xbuff, $xstart, $xoffsets, $ystart, $yoffsets)`

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>select</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>ystart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>yoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>yoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>ysquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `xbuff` | vector of any type values |
| `ybuff` | vector of any type values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values |



### `aievec_aie1.sub` (::xilinx::aievec::aie1::SubOp)

_AIE1 vector subtract_

AMD-specific advanced sub operation that subtracts two 1-D vectors
with lane selection. The vector sizes are at least 256 bits.
`$result = `$lhs - $rhs`.

Traits: `AlwaysSpeculatableImplTrait`

Interfaces: `ConditionallySpeculatable`, `NoMemoryEffect (MemoryEffectOpInterface)`

Effects: `MemoryEffects::Effect{}`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>xstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>xsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zstart</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zoffsets_hi</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>zsquare</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | vector of any type values |
| `rhs` | vector of any type values |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | vector of any type values |



## Enums

### AIEArch

_AIE Architecture_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| AIE1 | `1` | AIE1 |
| AIE2 | `2` | AIE2 |
| AIE2p | `3` | AIE2p |

### AIEDevice

_AIE Device_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| xcvc1902 | `1` | xcvc1902 |
| xcve2302 | `2` | xcve2302 |
| xcve2802 | `3` | xcve2802 |
| npu1 | `4` | npu1 |
| npu1_1col | `5` | npu1_1col |
| npu1_2col | `6` | npu1_2col |
| npu1_3col | `7` | npu1_3col |
| npu1_4col | `8` | npu1_4col |
| npu2 | `9` | npu2 |
| npu2_1col | `10` | npu2_1col |
| npu2_2col | `11` | npu2_2col |
| npu2_3col | `12` | npu2_3col |
| npu2_4col | `13` | npu2_4col |
| npu2_5col | `14` | npu2_5col |
| npu2_6col | `15` | npu2_6col |
| npu2_7col | `16` | npu2_7col |

### CascadeDir

_Directions for cascade_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| South | `3` | South |
| West | `4` | West |
| North | `5` | North |
| East | `6` | East |

### DMAChannelDir

_DMA Channel direction_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| S2MM | `0` | S2MM |
| MM2S | `1` | MM2S |

### LockAction

_Lock acquire/release_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| Acquire | `0` | Acquire |
| AcquireGreaterEqual | `2` | AcquireGreaterEqual |
| Release | `1` | Release |

### LockBlocking

_Lock operation is blocking_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| NonBlocking | `0` | NonBlocking |
| Blocking | `1` | Blocking |

### ObjectFifoPort

_Ports of an object FIFO_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| Produce | `0` | Produce |
| Consume | `1` | Consume |

### WireBundle

_Bundle of wires_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| Core | `0` | Core |
| DMA | `1` | DMA |
| FIFO | `2` | FIFO |
| South | `3` | South |
| West | `4` | West |
| North | `5` | North |
| East | `6` | East |
| PLIO | `7` | PLIO |
| NOC | `8` | NOC |
| Trace | `9` | Trace |
| TileControl | `10` | TileControl |
