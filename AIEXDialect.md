<!-- Autogenerated by mlir-tblgen; don't manually edit -->

# 'aiex' Dialect

This is a dialect for experimental work related to AIEngine processors.
The expectation is that new ideas can be developed here before migration
to the more mature AIE dialect.

[TOC]

## Operations

### `aiex.bp_dest` (::xilinx::AIEX::BPDestOp)

_A destination port_

Syntax:

```
operation ::= `aiex.bp_dest` `<` $tile `,` $bundle `:` $channel `>` attr-dict
```

An object representing the destination of a  Broad Packet. This must exist
within an [AIE.bp_id] operation.
See [AIE.broadcast_packet] for an example.

Traits: `HasParent<BPIDOp>`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>bundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`)
* TileControl (`TileControl`){{% /markdown %}}</details></td></tr>
<tr><td><code>channel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index |



### `aiex.bp_id` (::xilinx::AIEX::BPIDOp)

_A set of packets that share the same ID_

Syntax:

```
operation ::= `aiex.bp_id` `(` $ID `)` regions attr-dict
```

A set of destination packets that share the same source and ID. This must exist
within an [AIE.broadcast_packet] operation.
See [AIE.broadcast_packet]for an example.

Traits: `SingleBlockImplicitTerminator<AIE::EndOp>`, `SingleBlock`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>ID</code></td><td>::mlir::IntegerAttr</td><td>8-bit signless integer attribute</td></tr>
</table>



### `aiex.broadcast_packet` (::xilinx::AIEX::BroadcastPacketOp)

_Combination of broadcast and packet-switch_

Syntax:

```
operation ::= `aiex.broadcast_packet` `(` $tile `,` $bundle `:` $channel `)` regions attr-dict
```

An abstraction of broadcast and packet-switched flow. During place and
route, it will be replaced by packet-switched flow and further replaced
by MasterSets and PacketRules inside switchboxes.

Example:
```
  %70 = AIE.tile(7, 0)
  %73 = AIE.tile(7, 3)
  %74 = AIE.tile(7, 4)
  %63 = AIE.tile(6, 3)
  %64 = AIE.tile(6, 4)
  AIE.broadcast_packet(%70, "DMA" : 0){
    AIE.bp_id(0x0){
      AIE.bp_dest<%73, "DMA" : 0>
      AIE.bp_dest<%63, "DMA" : 0>
    }
    AIE.bp_id(0x1){
      AIE.bp_dest<%74, "DMA" : 0>
      AIE.bp_dest<%64, "DMA" : 0>
    }
  }
```

Traits: `SingleBlockImplicitTerminator<AIE::EndOp>`, `SingleBlock`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>bundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`)
* TileControl (`TileControl`){{% /markdown %}}</details></td></tr>
<tr><td><code>channel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index |



### `aiex.connection` (::xilinx::AIEX::ConnectionOp)

_A logical circuit-switched connection between cores_

Syntax:

```
operation ::= `aiex.connection` `(` $source `,` $sourceBundle `:` $sourceChannel `,` $dest `,` $destBundle `:` $destChannel `)` attr-dict
```

The "aie.connection" operation represents a circuit switched connection between two endpoints, usually
"aie.core" operations.  During routing, this is replaced by "aie.connect" operations which represent
the programmed connections inside a switchbox, along with "aie.wire" operations which represent
physical connections between switchboxes and other components.  Note that while "aie.flow" operations
can express partial routes between tiles, this is not possible with "aie.connection" operations.

Example:
  %22 = aie.tile(2, 2)
  %c22 = aie.core(%22)
  %11 = aie.tile(1, 1)
  %c11 = aie.core(%11)
  aie.flow(%c22, "Core" : 0, %c11, "Core" : 1)


#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>sourceBundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`)
* TileControl (`TileControl`){{% /markdown %}}</details></td></tr>
<tr><td><code>sourceChannel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>destBundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`)
* TileControl (`TileControl`){{% /markdown %}}</details></td></tr>
<tr><td><code>destChannel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | index |
| `dest` | index |



### `aiex.control_packet` (::xilinx::AIEX::NpuControlPacketOp)

_AIE control packet_

Syntax:

```
operation ::= `aiex.control_packet` attr-dict
```

The control_packet operation represents a low-level AIE control packet header
and payload.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>address</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr>
<tr><td><code>length</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>opcode</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>stream_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>data</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr>
</table>



### `aiex.dma_await_task` (::xilinx::AIEX::DMAAwaitTaskOp)

_Await Completion of a Previously Submitted DMA Task_

Syntax:

```
operation ::= `aiex.dma_await_task` `(` $task `)` attr-dict
```

This operation will block execution of the runtime sequence until the referenced previously started DMA task has completed.

DMA tasks can be started using `aiex.start_task` using abstract BD chains declared using `aie.bd_chain`, or using `aiex.start_configured_task` using a manually configured task.

To be able to wait on a task, it must issue a task completion token (TCT). Tasks only emit these tokens if the attribute `issue_token` is set to `true`.

Traits: `HasParent<RuntimeSequenceOp>`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `task` | index |



### `aiex.dma_configure_task` (::xilinx::AIEX::DMAConfigureTaskOp)

_Concrete Instantiation of a Buffer Descriptor Chain as a Task on a Channel and Direction on a Tile_

Syntax:

```
operation ::= `aiex.dma_configure_task` `(` $tile `,` $direction `,` $channel `)` regions attr-dict
```

Encapsulates the DMA configuration of one task, that is the (chain of) buffer descriptors to be executed on a given channel and direction on a tile.

Such configurations are generated by materializing abstract aie.bd_chains using aiex.start_task, or can be created manually using this op.

Once configured, a task can be submitted for execution using `aiex.dma_start_configured_task`, after which its execution completion can be awaited using `aiex.dma_await_task`.

Traits: `HasParent<RuntimeSequenceOp>`

Interfaces: `OpAsmOpInterface`, `TileElement`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>direction</code></td><td>xilinx::AIE::DMAChannelDirAttr</td><td><details><summary>DMA Channel direction</summary>{{% markdown %}}Enum cases:
* S2MM (`S2MM`)
* MM2S (`MM2S`){{% /markdown %}}</details></td></tr>
<tr><td><code>channel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>issue_token</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
<tr><td><code>repeat_count</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | index |



### `aiex.dma_configure_task_for` (::xilinx::AIEX::DMAConfigureTaskForOp)

_As dma_configure_task, but specify tile, direction and channel by reference to a Shim DMA allocation op_

Syntax:

```
operation ::= `aiex.dma_configure_task_for` $alloc regions attr-dict
```

Traits: `HasParent<RuntimeSequenceOp>`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>alloc</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>issue_token</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
<tr><td><code>repeat_count</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | index |



### `aiex.dma_free_task` (::xilinx::AIEX::DMAFreeTaskOp)

_Free all Buffer Descriptor IDs Associated with the Given Task_

Syntax:

```
operation ::= `aiex.dma_free_task` `(` $task `)` attr-dict
```

This operation informs the static buffer descriptor allocator pass in the compiler that the buffer descriptor IDs it has allocated to the BDs inside the referenced task can be reused thereafter.

Potential future implementations of dynamic buffer descriptor allocators may lower this to a `free` instruction.

Traits: `HasParent<RuntimeSequenceOp>`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `task` | index |



### `aiex.dma_start_bd_chain` (::xilinx::AIEX::DMAStartBdChainOp)

_Materialize an Abstract BD Chain as a DMA Task on the Given Tile, Channel and Direction and Immediately Start It_

Syntax:

```
operation ::= `aiex.dma_start_bd_chain` $symbol `(` $args `)` `:` `(` type($args) `)` ` ` `on` ` ` `(` $tile `,` $direction `,` $channel `)` attr-dict
```

This operation will configure a new DMA task on the given tile, channel and direction by concretizing an abstract BD chain, previously defined using `aie.bd_chain`, with the given input arguments.

Completion of the DMA task, i.e. the data transfer, can be awaited using `aiex.await_task` if the attribute `issue_token` is set to `true`.

Traits: `HasParent<RuntimeSequenceOp>`

Interfaces: `OpAsmOpInterface`, `TileElement`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>symbol</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>direction</code></td><td>xilinx::AIE::DMAChannelDirAttr</td><td><details><summary>DMA Channel direction</summary>{{% markdown %}}Enum cases:
* S2MM (`S2MM`)
* MM2S (`MM2S`){{% /markdown %}}</details></td></tr>
<tr><td><code>channel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>issue_token</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
<tr><td><code>repeat_count</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `args` | variadic of any type |
| `tile` | index |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | index |



### `aiex.dma_start_bd_chain_for` (::xilinx::AIEX::DMAStartBdChainForOp)

_As dma_start_bd_chain, but specify tile, direction and channel by reference to a Shim DMA allocation op_

Syntax:

```
operation ::= `aiex.dma_start_bd_chain_for` $symbol `(` $args `)` `:` `(` type($args) `)` ` ` `for` ` ` $alloc attr-dict
```

Traits: `HasParent<RuntimeSequenceOp>`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>symbol</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>alloc</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>issue_token</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
<tr><td><code>repeat_count</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `args` | variadic of any type |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | index |



### `aiex.dma_start_task` (::xilinx::AIEX::DMAStartTaskOp)

_Submit a Preconfigured Task to the Task Queue_

Syntax:

```
operation ::= `aiex.dma_start_task` `(` $task `)` attr-dict
```

Submits the referenced task for execution on the tile, channel and direction it has been configured to run on.
Once submitted, if the task is configured to issue a token, you can await completion of the task using `aiex.await_task`.

Traits: `HasParent<RuntimeSequenceOp>`

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `task` | index |



### `aiex.getTile` (::xilinx::AIEX::GetTileOp)

_Get a reference to an AIE tile_

Syntax:

```
operation ::= `aiex.getTile` `(` $col `,` $row `)` attr-dict
```

Return a reference to an AIE tile, given the column and the row of the tile.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `col` | index |
| `row` | index |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | index |



### `aiex.herd` (::xilinx::AIEX::HerdOp)

_Declare a herd which is a bundle of core organized in a rectangular shape_

Syntax:

```
operation ::= `aiex.herd` `[` $width `]` `[` $height `]` attr-dict
```

This operation creates a group of AIE tiles in 2D shape.

Example:
  %herd0 = AIE.herd[1][1] // a single AIE tile. location unknown
  %herd1 = AIE.herd[4][1] // a row of four-AIE tile

The operation can be used in replacement of a TileOp -- in case we want to select a group of
hardware entities (cores, mems, switchboxes) instead of individual entity, and we don't want to
specify their locations just yet. This can be useful if we want to generate parameterizable
code (the column and row values are parameterized).

Example:

  %herd = AIE.herd[2][2] // a herd of 2x2 AIE tiles

  AIE.core(%herd) {
    // all the cores belong to this herd runs the same code
  }

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>width</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>height</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | index |



### `aiex.iter` (::xilinx::AIEX::IterOp)

_An iter operation_

Syntax:

```
operation ::= `aiex.iter` `(` $start `,` $end `,` $stride `)` attr-dict
```

This operation generates index values that can be used with the SelectOp to select a group of tiles
from a herd.

Example:
  %iter0 = AIE.iter(0, 15, 1) // 0, 1, 2, ... , 15
  %iter1 = AIE.iter(2, 8, 2)  // 2, 4, 6

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>start</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>end</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>stride</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | index |



### `aiex.memcpy` (::xilinx::AIEX::MemcpyOp)

_A memcpy op_

Syntax:

```
operation ::= `aiex.memcpy` $tokenName `(` $acqValue `,` $relValue `)` `(`
              $srcTile `:` `<` $srcBuf `,` $srcOffset `,` $srcLen `>` `,`
              $dstTile `:` `<` $dstBuf `,` $dstOffset `,` $dstLen `>` `)`
              attr-dict `:` `(` type($srcBuf) `,` type($dstBuf) `)`
```

This operation defines a logical data transfer of a buffer from a source tile to another buffer
from a destination tile.

This operation should be lowered to Mem ops with DMA setup and Flow ops for routing data from
the source tile to the dest. tile.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>tokenName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>acqValue</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>relValue</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>srcOffset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>srcLen</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>dstOffset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>dstLen</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `srcTile` | index |
| `srcBuf` | memref of any type values |
| `dstTile` | index |
| `dstBuf` | memref of any type values |



### `aiex.multi_dest` (::xilinx::AIEX::MultiDestOp)

_A destination port of multicast flow_

Syntax:

```
operation ::= `aiex.multi_dest` `<` $tile `,` $bundle `:` $channel `>` attr-dict
```

An object representing the destination of a multicast flow. This must exist
within an [aiex.multicast] operation. There can be multiple destinations within an
aiex.multicast Op.

See [aiex.multicast]for an example.

Traits: `HasParent<MulticastOp>`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>bundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`)
* TileControl (`TileControl`){{% /markdown %}}</details></td></tr>
<tr><td><code>channel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index |



### `aiex.multicast` (::xilinx::AIEX::MulticastOp)

_An abstraction of multicast_

Syntax:

```
operation ::= `aiex.multicast` `(` $tile `,` $bundle `:` $channel `)` regions attr-dict
```

An abstraction of broadcast. During place and
route, it will be replaced by multiple flows.

Example:
```
  %70 = AIE.tile(7, 0)
  %73 = AIE.tile(7, 3)
  %74 = AIE.tile(7, 4)
  %63 = AIE.tile(6, 3)
  %64 = AIE.tile(6, 4)
  aiex.multicast(%70, "DMA" : 0){
    aiex.multi_dest<%73, "DMA" : 0>
    aiex.multi_dest<%74, "DMA" : 0>
    aiex.multi_dest<%63, "DMA" : 0>
    aiex.multi_dest<%64, "DMA" : 0>
  }
```

Traits: `SingleBlockImplicitTerminator<AIE::EndOp>`, `SingleBlock`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>bundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`)
* TileControl (`TileControl`){{% /markdown %}}</details></td></tr>
<tr><td><code>channel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index |



### `aiex.npu.address_patch` (::xilinx::AIEX::NpuAddressPatchOp)

_Address patch operator_

Syntax:

```
operation ::= `aiex.npu.address_patch` attr-dict
```

address patch operator

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>addr</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr>
<tr><td><code>arg_idx</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>arg_plus</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>



### `aiex.npu.blockwrite` (::xilinx::AIEX::NpuBlockWriteOp)

_Blockwrite operator_

Syntax:

```
operation ::= `aiex.npu.blockwrite` `(` $data `)` attr-dict `:` type($data)
```

blockwrite operator writes the data from the memref 'data' to the AIE array.
If 'buffer' is present then 'address' is interpreted as an offset into the
aie.buffer with symbol name 'buffer'.
If 'column' and 'row' are present then 'address' is interpreted as an offset
into the memory space of aie.tile(column, row).
If 'buffer' is not present and 'column' and 'row' are not present then
'address' is interpreted as a full 32-bit address in the AIE array.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>address</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr>
<tr><td><code>buffer</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>column</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>row</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `data` | memref of any type values |



### `aiex.npu.dma_memcpy_nd` (::xilinx::AIEX::NpuDmaMemcpyNdOp)

_Half DMA operator_

Syntax:

```
operation ::= `aiex.npu.dma_memcpy_nd` `(` $memref ``
              custom<DynamicIndexList>($offsets, $static_offsets) ``
              custom<DynamicIndexList>($sizes, $static_sizes) ``
              custom<DynamicIndexList>($strides, $static_strides) ``
              (`,` `packet` `=` $packet^)? `)`
              attr-dict `:` type($memref)
```

An n-dimensional half DMA operator.

Programs a DMA to access a memory `memref` with an access pattern specified by `offsets`,
`sizes` and `strides` or `static_offsets`, `static_sizes` and `static_strides`. The operator
references the target DMA coordinates (`x`, `y`) and channel through the `metadata`
symbol and specifies a descriptor `id` to be used, which will become the `bd_id` to be used
when lowered further. The `issue_token` attribute specifies whether the execution of this
operation should issue a token which can be received and read for synchronization purposes.
This `issue_token` attribute is set to `false` by default for `MM2S` for backward compatibility
and **is always set to true for** `S2MM` channels.
The burst length attribute specifies the burst length in bytes for the DMA operation. A value
of 0 indicates that the burst length is not specified and the maximal burst length is used.

#### `metadata` -- Specifying Tile, Channel, Direction and Linking a `dma_memcpy_nd` to its Other Half

The `metadata` attribute must point to a symbol referencing a
[`aie.shim_dma_allocation` operation](AIEDialect.html#aiedma_bd-xilinxaiedmabdop).
The tile coordinates of the DMA to configure, the channel number and the direction (`MM2S` or `S2MM`) are taken from this operation.

To connect the DMA to its other half (i.e. a `MM2S` DMA to its receiving end and a `S2MM` to the sending end),
the user must configure a flow (`aie.flow`) between the tile and channel referenced in the `aie.shim_dma_allocation` and the corresponding other end.

When using ObjectFIFOs, the `aie.shim_dma_allocation` operations and the `aie.flows` are generated automatically.
The symbol of the `aie.objectfifo` (create) operation can be used directly in `metadata` in this case.

#### Notes on Synchronization and Reusing Buffer Descriptor IDs

When the `dma_memcpy_nd` operation executes, it immediately reprograms the buffer descriptor with ID `bd_id` on tile (`x`, `y`), even if that buffer descriptor is currently executing.
Without proper synchronization, this inevitably leads to nondeterministic results.

Programming a buffer descriptor that is not currently executing is harmless.
Thus, the first `dma_memcpy_nd` call for each `bd_id` requires no synchronization.

However, if you wish to later re-use a `bd_id` on the same tile, you must wait for the previous buffer descriptor to complete.
The `sync` or `dma_wait` operations can be used for this.

`sync` blocks until it receives a _task completion token_ (TCT).
To properly synchronize, you must thus configure your BD to issue a TCT using the `issue_token` attribute, then wait on that token before reusing the BD.

`dma_wait` is a convenience operation that lowers to the corresponding `sync` operation for the refrenced symbol.

Note that if you have multiple concurrently running BDs and you can reason one BD will always complete after all others, it is not strictly necessary to issue and wait on the TC token for every BD.
For example, if you have input and output BDs on the shim, and you know the cores will only push output onto the output BD after the input BDs have completed, it may be sufficient to synchronize only on the output BD before reusing input BDs.

#### Data Layout Transformations

The `sizes` and `strides` attributes describe a data layout transformation to be performed by the DMA.
These transformations are described in more depth in the documentation for the
[`aie.dma_bd` operation](AIEDialect.html#aiedma_bd-xilinxaiedmabdop).
Note that the syntax here differs from that of the `dma_bd` operation:
offsets and strides are given as separate arrays instead of tuples.

The `offsets` array is used to calculate a static offset into the memref.
Each offset in the array is understood in relation to the shape of the memref;
the lowest-dimension `offset` is a direct offset in units of memref element type, and the higher dimensions are multiplied by the size of the memref in those dimensions.
Note that this is for convenience of the user only.
The hardware only supports a single static offset, and this offset is calculated at compile time.
Thus, all offsets can be equivalently expressed with the lowest dimension only.

#### Packet Header Attribute
The optional `packet` attribute defines the packet header and packet type that gets issued per DMA BD.
If the attribute is set, then every time the DMA BD gets issued, a packet header is generated prior to the transmission of data.
The packet header is used to guide arbitration throughout a packet-routed data flow, where each switch box arbitrates the data packet to stream to a successor based on the packet header.


Traits: `AttrSizedOperandSegments`

Interfaces: `MyOffsetSizeAndStrideOpInterface`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>static_offsets</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 4 elements</td></tr>
<tr><td><code>static_sizes</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 4 elements</td></tr>
<tr><td><code>static_strides</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 4 elements</td></tr>
<tr><td><code>packet</code></td><td>::xilinx::AIE::PacketInfoAttr</td><td>
    Tuple encoding the type and header of a packet;
  </td></tr>
<tr><td><code>metadata</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>id</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
<tr><td><code>issue_token</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
<tr><td><code>d0_zero_before</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
<tr><td><code>d1_zero_before</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
<tr><td><code>d2_zero_before</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
<tr><td><code>d0_zero_after</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
<tr><td><code>d1_zero_after</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
<tr><td><code>d2_zero_after</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
<tr><td><code>burst_length</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `memref` | memref of any type values |
| `offsets` | variadic of 64-bit signless integer |
| `sizes` | variadic of 64-bit signless integer |
| `strides` | variadic of 64-bit signless integer |



### `aiex.npu.dma_wait` (::xilinx::AIEX::NpuDmaWaitOp)

_Blocking operation to wait for a DMA to complete execution._

Syntax:

```
operation ::= `aiex.npu.dma_wait` attr-dict
```

The NpuDmaWaitOp blocks until the DMA referenced through `symbol` completes execution
and issues a task-complete-token (TCT).

`symbol` is a reference to a `aie.shim_dma_allocation`, which contains information about the column, channel and channel direction on which to wait for a TCT.
The `aie.shim_dma_allocation` may be generated from an ObjectFIFO, in which case you can directly pass the ObjectFIFO symbol refrence.
`npu.dma_wait` will be lowered to the corresponding `npu.sync` operation using the information from `symbol`.

Example:
```mlir
  ...
  aie.objectfifo @out0(%tile_0_1, {% raw %}{%tile_0_0}{% endraw %}, 4 : i32) : !aie.objectfifo<memref<32x32xi32>>
  ...
  aiex.npu.dma_memcpy_nd(0, 0, %arg2[1, 1, 0, 0][1, 1, 32, 32][1, 1, 64, 1]) {id = 0 : i64, issue_token = true, metadata = @out0} : memref<32x64xi32>
  ...
  aiex.npu.dma_wait { symbol = @out0 }
```
Here, we have an objectfifo with symbol name `out0`, which is then referenced in the
`npu.dma_memcpy_nd` operation as the target for the respective DMA operation. Afterwards,
an `npu.dma_wait` operation references the same symbol to block until the respective DMA
has executed all of its tasks.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>symbol</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
</table>



### `aiex.npu.maskwrite32` (::xilinx::AIEX::NpuMaskWrite32Op)

_Write a masked 32-bit value to the AIE array_

Syntax:

```
operation ::= `aiex.npu.maskwrite32` attr-dict
```

NPU mask write32 operator writes a masked 32bit value to the AIE array.
If 'buffer' is present then 'address' is interpreted as an offset into the
aie.buffer with symbol name 'buffer'.
If 'column' and 'row' are present then 'address' is interpreted as an offset
into the memory space of aie.tile(column, row).
If 'buffer' is not present and 'column' and 'row' are not present then
'address' is interpreted as a full 32-bit address in the AIE array.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>address</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr>
<tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr>
<tr><td><code>mask</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr>
<tr><td><code>buffer</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>column</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>row</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>



### `aiex.npu.push_queue` (::xilinx::AIEX::NpuPushQueueOp)

_Bd queue push operator_

Syntax:

```
operation ::= `aiex.npu.push_queue` `(` $column `,` $row `,` $direction `:` $channel `)` attr-dict
```

bd queue push operator

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>column</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>row</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>direction</code></td><td>xilinx::AIE::DMAChannelDirAttr</td><td><details><summary>DMA Channel direction</summary>{{% markdown %}}Enum cases:
* S2MM (`S2MM`)
* MM2S (`MM2S`){{% /markdown %}}</details></td></tr>
<tr><td><code>channel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>issue_token</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
<tr><td><code>repeat_count</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>bd_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>



### `aiex.npu.rtp_write` (::xilinx::AIEX::NpuWriteRTPOp)

_Rtp write operator_

Syntax:

```
operation ::= `aiex.npu.rtp_write` `(` $buffer `,` $index `,` $value `)` attr-dict
```

rtp write operator

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>buffer</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr>
<tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>



### `aiex.npu.sync` (::xilinx::AIEX::NpuSyncOp)

_Sync operator_

Syntax:

```
operation ::= `aiex.npu.sync` attr-dict
```

The sync operation blocks execution of the instruction stream until a task-complete token (TCT) is received on `column`, `row`, channel `channel`, direction `direction` (where `0` is `S2MM` and `1` is `MM2S`).

#### Troubleshooting

If this operation appears to deadlock, ensure that at least one buffer descriptor is configured to issue a TCT on the channel you expect.
By default, `dma_memcpy_nd` operations only issue tokens for `S2MM` channels, and `issue_token` must be set to `true` to issue tokens for `MM2S` channels.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>column</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>row</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>direction</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>channel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>column_num</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>row_num</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>



### `aiex.npu.write32` (::xilinx::AIEX::NpuWrite32Op)

_Write32 operator_

Syntax:

```
operation ::= `aiex.npu.write32` attr-dict
```

NPU write32 operator writes a 32bit value to the AIE array.
If 'buffer' is present then 'address' is interpreted as an offset into the
aie.buffer with symbol name 'buffer'.
If 'column' and 'row' are present then 'address' is interpreted as an offset
into the memory space of aie.tile(column, row).
If 'buffer' is not present and 'column' and 'row' are not present then
'address' is interpreted as a full 32-bit address in the AIE array.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>address</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr>
<tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr>
<tr><td><code>buffer</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>column</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>row</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>



### `aiex.npu.writebd` (::xilinx::AIEX::NpuWriteBdOp)

_Dma operator_

Syntax:

```
operation ::= `aiex.npu.writebd` attr-dict
```

writebd operator

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>column</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>bd_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>buffer_length</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>buffer_offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>enable_packet</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>out_of_order_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>packet_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>packet_type</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d0_size</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d0_stride</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d1_size</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d1_stride</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d2_size</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d2_stride</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>iteration_current</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>iteration_size</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>iteration_stride</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>next_bd</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>row</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>use_next_bd</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>valid_bd</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>lock_rel_val</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>lock_rel_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>lock_acq_enable</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>lock_acq_val</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>lock_acq_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d0_zero_before</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d1_zero_before</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d2_zero_before</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d0_zero_after</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d1_zero_after</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d2_zero_after</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>burst_length</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>



### `aiex.place` (::xilinx::AIEX::PlaceOp)

_A place operation that specifies the relative placement (XY) of one herd to another_

Syntax:

```
operation ::= `aiex.place` `(` $sourceHerd `,` $destHerd `,` $distX `,` $distY `)` attr-dict
```

A place operation that specifies the relative placement (XY) of one herd to another.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>distX</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>distY</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `sourceHerd` | index |
| `destHerd` | index |



### `aiex.route` (::xilinx::AIEX::RouteOp)

_A route operation that routes one herd to another_

Syntax:

```
operation ::= `aiex.route` `(` `<` $sourceHerds `,` $sourceBundle `:` $sourceChannel `>` `,`
              `<` $destHerds   `,` $destBundle   `:` $destChannel   `>` `)` attr-dict
```

A route operation that routes one herd to another.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>sourceBundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`)
* TileControl (`TileControl`){{% /markdown %}}</details></td></tr>
<tr><td><code>sourceChannel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>destBundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`)
* TileControl (`TileControl`){{% /markdown %}}</details></td></tr>
<tr><td><code>destChannel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `sourceHerds` | index |
| `destHerds` | index |



### `aiex.runtime_sequence` (::xilinx::AIEX::RuntimeSequenceOp)

_Program the configuration co-processor of the AI Engine array_

Instructions in this operation allow for runtime (re-)configuration of the AI Engine array, such as configuring data movement buffer descriptors.
These instructions will execute on the configuration co-processor of the AI Engine array.

Typically, these instructions include configuring the data transfers between host and AIE array on the shims.
The input arguments are arguments passed in from the host at kernel invocation time. This may include buffers on the host.

Traits: `HasParent<AIE::DeviceOp>`, `NoTerminator`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
</table>



### `aiex.select` (::xilinx::AIEX::SelectOp)

_A select operation_

Syntax:

```
operation ::= `aiex.select` `(` $startHerd `,` $iterX `,` $iterY `)` attr-dict
```

This operation selects a group of tiles based on the selected indices.

Example:

  %herd = AIE.herd[4][4] // a herd of 4x4 tiles

  %ix = AIE.iter(0, 4, 1) // 0, 1, 2, 3
  %iy = AIE.iter(0, 1, 1) // 0

  %sub_herd = AIE.select(%herd, %ix, %iy)

The SelectOp in the above example will select the tiles %herd[0][0], %herd[1][0],
%herd[2][0], %herd[3][0] (the first column of the herd).

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `startHerd` | index |
| `iterX` | index |
| `iterY` | index |

#### Results:

| Result | Description |
| :----: | ----------- |
| &laquo;unnamed&raquo; | index |



### `aiex.set_lock` (::xilinx::AIEX::SetLockOp)

_Set the value of a lock_

Syntax:

```
operation ::= `aiex.set_lock` `(` $lock `,` $value `)` attr-dict
```

This operation sets the value of `lock` inside of a RuntimeSequenceOp.
The operation is non blocking and does not offer any synchronization guarantees.
Should be used in combination with blocking operations.

Example:
```
  %tile22 = aie.tile(2, 2)
  %lock22_0 = aie.lock(%tile22, 0)
  ...
  aiex.set_lock(%lock22_0, 5)
```

Traits: `HasParent<RuntimeSequenceOp>`, `SkipAccessibilityCheckTrait`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lock` | index |



### `aiex.token` (::xilinx::AIEX::TokenOp)

_Declare a token (a logical lock)_

Syntax:

```
operation ::= `aiex.token` `(` $value `)` attr-dict
```

This operation creates a logical lock. We use Symbol so that it can be referenced globally.
Unlike phsical locks, logical locks are unlimited, and we can specify any integer value
associated with a lock. The logical lock is used to manually specify the dependence of tasks, or
core executions.

The operation can also be generated automatically if the Dependence Analysis can be leveraged.

Example:
  AIE.token(0) {sym_name = "token0"} // Declare token0 with initial value of 0

  ...

  AIE.useToken @token0("Acquire", 0) // acquire token0 if its value is 0

  ...

  AIE.useToken @token0("Release", 5) // release token0 and set its value to 5


Interfaces: `Symbol`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>



### `aiex.useToken` (::xilinx::AIEX::UseTokenOp)

_Acquire/release a logical lock_

Syntax:

```
operation ::= `aiex.useToken` $tokenName `(` $action `,` $value `)` attr-dict
```

This operation uses token (logical lock). A logical lock can be acquired or released with a value.
Similar to UseLockOp, this operation can be understood as "blocking" op.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>tokenName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>action</code></td><td>xilinx::AIE::LockActionAttr</td><td><details><summary>lock acquire/release</summary>{{% markdown %}}Enum cases:
* Acquire (`Acquire`)
* AcquireGreaterEqual (`AcquireGreaterEqual`)
* Release (`Release`){{% /markdown %}}</details></td></tr>
</table>



## Enums

### AIEArch

_AIE Architecture_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| AIE1 | `1` | AIE1 |
| AIE2 | `2` | AIE2 |
| AIE2p | `3` | AIE2p |

### AIEDevice

_AIE Device_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| xcvc1902 | `1` | xcvc1902 |
| xcve2302 | `2` | xcve2302 |
| xcve2802 | `3` | xcve2802 |
| npu1 | `4` | npu1 |
| npu1_1col | `5` | npu1_1col |
| npu1_2col | `6` | npu1_2col |
| npu1_3col | `7` | npu1_3col |
| npu1_4col | `8` | npu1_4col |
| npu2 | `9` | npu2 |
| npu2_1col | `10` | npu2_1col |
| npu2_2col | `11` | npu2_2col |
| npu2_3col | `12` | npu2_3col |
| npu2_4col | `13` | npu2_4col |
| npu2_5col | `14` | npu2_5col |
| npu2_6col | `15` | npu2_6col |
| npu2_7col | `16` | npu2_7col |

### CascadeDir

_Directions for cascade_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| South | `3` | South |
| West | `4` | West |
| North | `5` | North |
| East | `6` | East |

### DMAChannelDir

_DMA Channel direction_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| S2MM | `0` | S2MM |
| MM2S | `1` | MM2S |

### LockAction

_Lock acquire/release_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| Acquire | `0` | Acquire |
| AcquireGreaterEqual | `2` | AcquireGreaterEqual |
| Release | `1` | Release |

### LockBlocking

_Lock operation is blocking_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| NonBlocking | `0` | NonBlocking |
| Blocking | `1` | Blocking |

### ObjectFifoPort

_Ports of an object FIFO_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| Produce | `0` | Produce |
| Consume | `1` | Consume |

### WireBundle

_Bundle of wires_

#### Cases:

| Symbol | Value | String |
| :----: | :---: | ------ |
| Core | `0` | Core |
| DMA | `1` | DMA |
| FIFO | `2` | FIFO |
| South | `3` | South |
| West | `4` | West |
| North | `5` | North |
| East | `6` | East |
| PLIO | `7` | PLIO |
| NOC | `8` | NOC |
| Trace | `9` | Trace |
| TileControl | `10` | TileControl |
