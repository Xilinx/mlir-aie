<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'aiex' Dialect

This is a dialect for experimental work related to AIEngine processors.
The expectation is that new ideas can be developed here before migration
to the more mature AIE dialect.


[TOC]

## Operations

### `aiex.bp_dest` (::xilinx::AIEX::BPDestOp)

_A destination port_


Syntax:

```
operation ::= `aiex.bp_dest` `<` $tile `,` $bundle `:` $channel `>` attr-dict
```

An object representing the destination of a  Broad Packet. This must exist
within an [AIE.bp_id] operation.
See [AIE.broadcast_packet] for an example.

Traits: `HasParent<BPIDOp>`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>bundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`){{% /markdown %}}</details></td></tr>
<tr><td><code>channel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index


### `aiex.bp_id` (::xilinx::AIEX::BPIDOp)

_A set of packets that share the same ID_


Syntax:

```
operation ::= `aiex.bp_id` `(` $ID `)` regions attr-dict
```

A set of destination packets that share the same source and ID. This must exist
within an [AIE.broadcast_packet] operation.
See [AIE.broadcast_packet]for an example.

Traits: `SingleBlockImplicitTerminator<AIE::EndOp>`, `SingleBlock`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>ID</code></td><td>::mlir::IntegerAttr</td><td>8-bit signless integer attribute</td></tr>
</table>


### `aiex.broadcast_packet` (::xilinx::AIEX::BroadcastPacketOp)

_Combination of broadcast and packet-switch_


Syntax:

```
operation ::= `aiex.broadcast_packet` `(` $tile `,` $bundle `:` $channel `)` regions attr-dict
```

An abstraction of broadcast and packet-switched flow. During place and
route, it will be replaced by packet-switched flow and further replaced
by MasterSets and PacketRules inside switchboxes.

Example:
```
  %70 = AIE.tile(7, 0)
  %73 = AIE.tile(7, 3)
  %74 = AIE.tile(7, 4)
  %63 = AIE.tile(6, 3)
  %64 = AIE.tile(6, 4)
  AIE.broadcast_packet(%70, "DMA" : 0){
    AIE.bp_id(0x0){
      AIE.bp_dest<%73, "DMA" : 0>
      AIE.bp_dest<%63, "DMA" : 0>
    }
    AIE.bp_id(0x1){
      AIE.bp_dest<%74, "DMA" : 0>
      AIE.bp_dest<%64, "DMA" : 0>
    }
  }
```

Traits: `SingleBlockImplicitTerminator<AIE::EndOp>`, `SingleBlock`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>bundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`){{% /markdown %}}</details></td></tr>
<tr><td><code>channel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index


### `aiex.connection` (::xilinx::AIEX::ConnectionOp)

_A logical circuit-switched connection between cores_


Syntax:

```
operation ::= `aiex.connection` `(` $source `,` $sourceBundle `:` $sourceChannel `,` $dest `,` $destBundle `:` $destChannel `)` attr-dict
```

The "aie.connection" operation represents a circuit switched connection between two endpoints, usually
"aie.core" operations.  During routing, this is replaced by "aie.connect" operations which represent
the programmed connections inside a switchbox, along with "aie.wire" operations which represent
physical connections between switchboxes and other components.  Note that while "aie.flow" operations
can express partial routes between tiles, this is not possible with "aie.connection" operations.

Example:
  %22 = aie.tile(2, 2)
  %c22 = aie.core(%22)
  %11 = aie.tile(1, 1)
  %c11 = aie.core(%11)
  aie.flow(%c22, "Core" : 0, %c11, "Core" : 1)


#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>sourceBundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`){{% /markdown %}}</details></td></tr>
<tr><td><code>sourceChannel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>destBundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`){{% /markdown %}}</details></td></tr>
<tr><td><code>destChannel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `source` | index
| `dest` | index


### `aiex.getTile` (::xilinx::AIEX::GetTileOp)

_Get a reference to an AIE tile_


Syntax:

```
operation ::= `aiex.getTile` `(` $col `,` $row `)` attr-dict
```

Return a reference to an AIE tile, given the column and the row of the tile.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `col` | index
| `row` | index

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | index


### `aiex.herd` (::xilinx::AIEX::HerdOp)

_Declare a herd which is a bundle of core organized in a rectangular shape_


Syntax:

```
operation ::= `aiex.herd` `[` $width `]` `[` $height `]` attr-dict
```

This operation creates a group of AIE tiles in 2D shape.

Example:
  %herd0 = AIE.herd[1][1] // a single AIE tile. location unknown
  %herd1 = AIE.herd[4][1] // a row of four-AIE tile

The operation can be used in replacement of a TileOp -- in case we want to select a group of
hardware entities (cores, mems, switchboxes) instead of individual entity, and we don't want to
specify their locations just yet. This can be useful if we want to generate parameterizable
code (the column and row values are parameterized).

Example:

  %herd = AIE.herd[2][2] // a herd of 2x2 AIE tiles

  AIE.core(%herd) {
    // all the cores belong to this herd runs the same code
  }

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>width</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>height</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index


### `aiex.iter` (::xilinx::AIEX::IterOp)

_An iter operation_


Syntax:

```
operation ::= `aiex.iter` `(` $start `,` $end `,` $stride `)` attr-dict
```

This operation generates index values that can be used with the SelectOp to select a group of tiles
from a herd.

Example:
  %iter0 = AIE.iter(0, 15, 1) // 0, 1, 2, ... , 15
  %iter1 = AIE.iter(2, 8, 2)  // 2, 4, 6

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>start</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>end</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>stride</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index


### `aiex.memcpy` (::xilinx::AIEX::MemcpyOp)

_A memcpy op_


Syntax:

```
operation ::= `aiex.memcpy` $tokenName `(` $acqValue `,` $relValue `)` `(`
              $srcTile `:` `<` $srcBuf `,` $srcOffset `,` $srcLen `>` `,`
              $dstTile `:` `<` $dstBuf `,` $dstOffset `,` $dstLen `>` `)`
              attr-dict `:` `(` type($srcBuf) `,` type($dstBuf) `)`
```

This operation defines a logical data transfer of a buffer from a source tile to another buffer
from a destination tile.

This operation should be lowered to Mem ops with DMA setup and Flow ops for routing data from
the source tile to the dest. tile.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>tokenName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>acqValue</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>relValue</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>srcOffset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>srcLen</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>dstOffset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>dstLen</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `srcTile` | index
| `srcBuf` | memref of any type values
| `dstTile` | index
| `dstBuf` | memref of any type values


### `aiex.multi_dest` (::xilinx::AIEX::MultiDestOp)

_A destination port of multicast flow_


Syntax:

```
operation ::= `aiex.multi_dest` `<` $tile `,` $bundle `:` $channel `>` attr-dict
```

An object representing the destination of a multicast flow. This must exist
within an [aiex.multicast] operation. There can be multiple destinations within an
aiex.multicast Op.

See [aiex.multicast]for an example.

Traits: `HasParent<MulticastOp>`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>bundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`){{% /markdown %}}</details></td></tr>
<tr><td><code>channel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index


### `aiex.multicast` (::xilinx::AIEX::MulticastOp)

_An abstraction of multicast_


Syntax:

```
operation ::= `aiex.multicast` `(` $tile `,` $bundle `:` $channel `)` regions attr-dict
```

An abstraction of broadcast. During place and
route, it will be replaced by multiple flows.

Example:
```
  %70 = AIE.tile(7, 0)
  %73 = AIE.tile(7, 3)
  %74 = AIE.tile(7, 4)
  %63 = AIE.tile(6, 3)
  %64 = AIE.tile(6, 4)
  aiex.multicast(%70, "DMA" : 0){
    aiex.multi_dest<%73, "DMA" : 0>
    aiex.multi_dest<%74, "DMA" : 0>
    aiex.multi_dest<%63, "DMA" : 0>
    aiex.multi_dest<%64, "DMA" : 0>
  }
```

Traits: `SingleBlockImplicitTerminator<AIE::EndOp>`, `SingleBlock`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>bundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`){{% /markdown %}}</details></td></tr>
<tr><td><code>channel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `tile` | index


### `aiex.npu.dma_memcpy_nd` (::xilinx::AIEX::NpuDmaMemcpyNdOp)

_Half dma operator_


Syntax:

```
operation ::= `aiex.npu.dma_memcpy_nd` `(` $x `,` $y `,` $memref ``
              custom<DynamicIndexList>($offsets, $static_offsets) ``
              custom<DynamicIndexList>($sizes, $static_sizes) ``
              custom<DynamicIndexList>($strides, $static_strides) `)`
              attr-dict `:` type($memref)
```

An nd half dma operator.

Programs a DMA on coordinates (`x`, `y`) to access a memory `memref` with an access
pattern specified by `offsets`, `sizes` and `strides` or `static_offsets`, `static_sizes`
and `static_strides`. The operator references the target channel through the `metadata`
symbol and specifies a descriptor `id` to be used, which will become the `bd_id` to be used
when lowered further. The `issue_token` attribute specifies whether the execution of this
operation should issue a token which can be received and read for synchronization purposes.
This `issue_token` attribute is set to `false` by default for `MM2S` for backward compatibility
and **is always set to true for** `S2MM` channels.

Traits: `AttrSizedOperandSegments`

Interfaces: `MyOffsetSizeAndStrideOpInterface`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>x</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
<tr><td><code>y</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
<tr><td><code>static_offsets</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 4 elements</td></tr>
<tr><td><code>static_sizes</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 4 elements</td></tr>
<tr><td><code>static_strides</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 3 elements</td></tr>
<tr><td><code>metadata</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>id</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr>
<tr><td><code>issue_token</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `memref` | memref of any type values
| `offsets` | variadic of 64-bit signless integer
| `sizes` | variadic of 64-bit signless integer
| `strides` | variadic of 64-bit signless integer


### `aiex.npu.dma_wait` (::xilinx::AIEX::NpuDmaWaitOp)

_Blocking operation to wait for a DMA to complete execution._


Syntax:

```
operation ::= `aiex.npu.dma_wait` attr-dict
```

The NpuDmaWaitOp blocks until the DMA referenced through `symbol` completes execution
and issues a task-complete-token.

Example:
```mlir
  ...
  aie.objectfifo @out0(%tile_0_1, {%tile_0_0}, 4 : i32) : !aie.objectfifo<memref<32x32xi32>>
  ...
  aiex.npu.dma_memcpy_nd(0, 0, %arg2[1, 1, 0, 0][1, 1, 32, 32][1, 1, 64]) {id = 0 : i64, issue_token = true, metadata = @out0} : memref<32x64xi32>
  ...
  aiex.npu.dma_wait { symbol = @out0 }
```
Here, we have an objectfifo with symbol name `out0`, which is then referenced in the
`npu.dma_memcpy_nd` operation as the target for the respective DMA operation. Afterwards,
an `npu.dma_wait` operation references the same symbol to block until the respective DMA
has executed all of its tasks.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>symbol</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
</table>


### `aiex.npu.rtp_write` (::xilinx::AIEX::NpuWriteRTPOp)

_Rtp write operator_


Syntax:

```
operation ::= `aiex.npu.rtp_write` `(` $col `,` $row `,` $index `,` $value `)` attr-dict
```

rtp write operator

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>buffer_sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr>
<tr><td><code>col</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr>
<tr><td><code>row</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr>
<tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr>
<tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>


### `aiex.npu.shimtile_push_queue` (::xilinx::AIEX::NpuShimTilePushQueueOp)

_Bd queue push operator_


Syntax:

```
operation ::= `aiex.npu.shimtile_push_queue` attr-dict
```

bd queue push operator

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>metadata</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>issue_token</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr>
<tr><td><code>repeat_count</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>bd_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>


### `aiex.npu.sync` (::xilinx::AIEX::NpuSyncOp)

_Sync operator_


Syntax:

```
operation ::= `aiex.npu.sync` attr-dict
```

tct sync operator

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>column</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>row</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>direction</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>channel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>column_num</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>row_num</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>


### `aiex.npu.write32` (::xilinx::AIEX::NpuWrite32Op)

_Write32 operator_


Syntax:

```
operation ::= `aiex.npu.write32` attr-dict
```

write32 operator

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>column</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>row</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>address</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr>
<tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr>
</table>


### `aiex.npu.writebd_shimtile` (::xilinx::AIEX::NpuWriteBdExShimTileOp)

_Dma operator_


Syntax:

```
operation ::= `aiex.npu.writebd_shimtile` attr-dict
```

writebd_shimtile operator

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>column</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>column_num</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>ddr_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>bd_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>buffer_length</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>buffer_offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>enable_packet</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>out_of_order_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>packet_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>packet_type</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d0_size</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d0_stride</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d1_size</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d1_stride</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>d2_stride</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>iteration_current</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>iteration_size</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>iteration_stride</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>next_bd</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>use_next_bd</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>valid_bd</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>lock_rel_val</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>lock_rel_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>lock_acq_enable</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>lock_acq_val</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>lock_acq_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>


### `aiex.place` (::xilinx::AIEX::PlaceOp)

_A place operation that specifies the relative placement (XY) of one herd to another_


Syntax:

```
operation ::= `aiex.place` `(` $sourceHerd `,` $destHerd `,` $distX `,` $distY `)` attr-dict
```

A place operation that specifies the relative placement (XY) of one herd to another.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>distX</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>distY</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `sourceHerd` | index
| `destHerd` | index


### `aiex.route` (::xilinx::AIEX::RouteOp)

_A route operation that routes one herd to another_


Syntax:

```
operation ::= `aiex.route` `(` `<` $sourceHerds `,` $sourceBundle `:` $sourceChannel `>` `,`
              `<` $destHerds   `,` $destBundle   `:` $destChannel   `>` `)` attr-dict
```

A route operation that routes one herd to another.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>sourceBundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`){{% /markdown %}}</details></td></tr>
<tr><td><code>sourceChannel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>destBundle</code></td><td>xilinx::AIE::WireBundleAttr</td><td><details><summary>Bundle of wires</summary>{{% markdown %}}Enum cases:
* Core (`Core`)
* DMA (`DMA`)
* FIFO (`FIFO`)
* South (`South`)
* West (`West`)
* North (`North`)
* East (`East`)
* PLIO (`PLIO`)
* NOC (`NOC`)
* Trace (`Trace`){{% /markdown %}}</details></td></tr>
<tr><td><code>destChannel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `sourceHerds` | index
| `destHerds` | index


### `aiex.select` (::xilinx::AIEX::SelectOp)

_A select operation_


Syntax:

```
operation ::= `aiex.select` `(` $startHerd `,` $iterX `,` $iterY `)` attr-dict
```

This operation selects a group of tiles based on the selected indices.

Example:

  %herd = AIE.herd[4][4] // a herd of 4x4 tiles

  %ix = AIE.iter(0, 4, 1) // 0, 1, 2, 3
  %iy = AIE.iter(0, 1, 1) // 0

  %sub_herd = AIE.select(%herd, %ix, %iy)

The SelectOp in the above example will select the tiles %herd[0][0], %herd[1][0],
%herd[2][0], %herd[3][0] (the first column of the herd).

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `startHerd` | index
| `iterX` | index
| `iterY` | index

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | index


### `aiex.token` (::xilinx::AIEX::TokenOp)

_Declare a token (a logical lock)_


Syntax:

```
operation ::= `aiex.token` `(` $value `)` attr-dict
```

This operation creates a logical lock. We use Symbol so that it can be referenced globally.
Unlike phsical locks, logical locks are unlimited, and we can specify any integer value
associated with a lock. The logical lock is used to manually specify the dependence of tasks, or
core executions.

The operation can also be generated automatically if the Dependence Analysis can be leveraged.

Example:
  AIE.token(0) {sym_name = "token0"} // Declare token0 with initial value of 0

  ...

  AIE.useToken @token0("Acquire", 0) // acquire token0 if its value is 0

  ...

  AIE.useToken @token0("Release", 5) // release token0 and set its value to 5


Interfaces: `Symbol`

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
</table>


### `aiex.useToken` (::xilinx::AIEX::UseTokenOp)

_Acquire/release a logical lock_


Syntax:

```
operation ::= `aiex.useToken` $tokenName `(` $action `,` $value `)` attr-dict
```

This operation uses token (logical lock). A logical lock can be acquired or released with a value.
Similar to UseLockOp, this operation can be understood as "blocking" op.

#### Attributes:

<table>
<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
<tr><td><code>tokenName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr>
<tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr>
<tr><td><code>action</code></td><td>xilinx::AIE::LockActionAttr</td><td><details><summary>lock acquire/release</summary>{{% markdown %}}Enum cases:
* Acquire (`Acquire`)
* AcquireGreaterEqual (`AcquireGreaterEqual`)
* Release (`Release`){{% /markdown %}}</details></td></tr>
</table>


