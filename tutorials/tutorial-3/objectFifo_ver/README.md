<!---//===- README.md --------------------------*- Markdown -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// Copyright (C) 2022, Advanced Micro Devices, Inc.
// 
//===----------------------------------------------------------------------===//-->

# <ins>Tutorial 3 - communication via objectFifo (local memory), locks</ins>

This part of the tutorial introduces the object FIFO abstraction, which is used to setup communication between tiles without explicit configuration of the dataflow movement. The abstraction is then lowered via MLIR conversion passes onto the physical `mlir-aie` components.

The object FIFO abstraction consists of several `AIE.objectFifo` operations which are gradually introduced in this tutorial and the following ones. The code in [aie.mlir](aie.mlir) is an implementation of tutorial-3 using the objectFifo abstraction.

Firstly, an objectFifo is created between tiles (1,4) and (2,4) with the `AIE.objectFifo.createObjectFifo` operation. The object FIFO describes both the data allocation and its movement. An object FIFO has a depth, or size, which represents a number of pre-allocated objects of a specified datatype that can be synchronously accessed by actors, which we separate into consumers and producers. In this tutorial, tile (1,4) is the producer tile and tile (2,4) is the consumer tile and the object FIFO established between them has one object of type `memref<256xi32>`.

To achieve deadlock-free communication, actors must acquire and release objects from the object FIFO. In this example, there is only one object to acquire. The operation `AIE.objectFifo.acquire` returns a subview of the object FIFO containing the specified number of elements. Individual elements can then be accessed in an array-like fashion with the operation `AIE.objectFifo.subview.access`. When an object is no longer required for computation, the actor which acquired it should release it with `AIE.objectFifo.release` such that other actors may acquire it in the future. The acquire and release operations both take an additional port attribute which can be either "Produce" or "Consume". The use of this attribute will be further described in the `Object FIFO Lowering` section.

# <ins>Object FIFO Lowering</ins>

The objects of an object FIFO each lower into a `lock` and `buffer` pair. As such, the `AIE.objectFifo.acquire` and `AIE.objectFifo.release` operations are lowered into `useLock` operation. Both these operations take a port attribute which can be either "Produce" or "Consume". This attribute is used to determine the lock values to give to the `useLock` operations in order to achieve the desired synchronisation. For example:
```
AIE.objectFifo.acquire<Produce>(%objFifo : !AIE.objectFifo<memref<256xi32>>, 1)
```
is lowered into,
```
AIE.useLock(%lock14_0, "Acquire", 0)
```
where %lock14_0 is the lock generated by the lowering. And as another example, 
```
AIE.objectFifo.acquire<Consume>(%objFifo : !AIE.objectFifo<memref<256xi32>>, 1)
```
is lowered into,
```
AIE.useLock(%lock14_0, "Acquire", 0)
```
is lowered into,
```
AIE.useLock(%lock14_0, "Acquire", 1)
```

Both the lock and buffer are components that are local to a tile and its memory module. The object FIFO lowering will generate these components in the tile, and in its associated memory module, chosen based on the position of the tiles which were used when creating the object FIFO.

## <ins>Tutorial 3 Lab </ins>

1. Read through the [/objectFifo_ver/aie.mlir](aie.mlir) design. In which tile and its local memory will the object FIFO lowering generate the object and its lock?
