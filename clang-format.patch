diff --git a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/chess_main.cc b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/chess_main.cc
index f1d5093..f4ee1b5 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/chess_main.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/chess_main.cc
@@ -1,19 +1,18 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
 #include "hdiff.h"
 
-int main()
-{
-    int32_t din1[10] = {};
-    int32_t din2[10] = {};
-    int32_t din3[10] = {};
-    int32_t din4[10] = {};
-    int32_t din5[10] = {};
-    int32_t dout[10] = {};
-    vec_hdiff(din1,din2,din3, din4, din5,  dout); 
-    return 1;
+int main() {
+  int32_t din1[10] = {};
+  int32_t din2[10] = {};
+  int32_t din3[10] = {};
+  int32_t din4[10] = {};
+  int32_t din5[10] = {};
+  int32_t dout[10] = {};
+  vec_hdiff(din1, din2, din3, din4, din5, dout);
+  return 1;
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff.h b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff.h
index 2acd529..95a792e 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff.h
+++ b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff.h
@@ -1,16 +1,29 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
 extern "C" {
-void hdiff_lap(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict row2,int32_t* restrict row3,int32_t* restrict row4, int32_t* restrict out_flux1, int32_t* restrict out_flux2, int32_t* restrict out_flux3, int32_t* restrict out_flux4 );
-void hdiff_flux(int32_t* restrict row1, int32_t* restrict row2,int32_t* restrict row3, int32_t* restrict flux_forward1,int32_t* restrict flux_forward2,int32_t* restrict flux_forward3,int32_t* restrict flux_forward4,  int32_t * restrict out);
-
-void hdiff_lap_fp32(float* restrict row0, float* restrict row1,float* restrict row2,float* restrict row3,float* restrict row4, float* restrict out_flux1, float* restrict out_flux2, float* restrict out_flux3, float* restrict out_flux4 );
-void hdiff_flux_fp32(float* restrict row1, float* restrict row2,float* restrict row3, float* restrict flux_forward1,float* restrict flux_forward2,float* restrict flux_forward3,float* restrict flux_forward4,  float * restrict out);
-
+void hdiff_lap(int32_t *restrict row0, int32_t *restrict row1,
+               int32_t *restrict row2, int32_t *restrict row3,
+               int32_t *restrict row4, int32_t *restrict out_flux1,
+               int32_t *restrict out_flux2, int32_t *restrict out_flux3,
+               int32_t *restrict out_flux4);
+void hdiff_flux(int32_t *restrict row1, int32_t *restrict row2,
+                int32_t *restrict row3, int32_t *restrict flux_forward1,
+                int32_t *restrict flux_forward2,
+                int32_t *restrict flux_forward3,
+                int32_t *restrict flux_forward4, int32_t *restrict out);
 
+void hdiff_lap_fp32(float *restrict row0, float *restrict row1,
+                    float *restrict row2, float *restrict row3,
+                    float *restrict row4, float *restrict out_flux1,
+                    float *restrict out_flux2, float *restrict out_flux3,
+                    float *restrict out_flux4);
+void hdiff_flux_fp32(float *restrict row1, float *restrict row2,
+                     float *restrict row3, float *restrict flux_forward1,
+                     float *restrict flux_forward2,
+                     float *restrict flux_forward3,
+                     float *restrict flux_forward4, float *restrict out);
 }
-
diff --git a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_flux.cc b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_flux.cc
index eaa7ca6..b844ebe 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_flux.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_flux.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,152 +9,170 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,  int32_t * restrict out)
+// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,
+// int32_t * restrict out)
 // {
-void hdiff_flux(int32_t* restrict row1, int32_t* restrict row2,int32_t* restrict row3, int32_t* restrict flux_forward1,int32_t* restrict flux_forward2,int32_t* restrict flux_forward3,int32_t* restrict flux_forward4,  int32_t * restrict out)
-{
-    
-    alignas(32) int32_t weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) int32_t flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8int32 coeffs1         = *(v8int32*) weights1;  //  8 x int32 = 256b W vector
-    v8int32 flux_out_coeff=*(v8int32*)flux_out;
-
-    // v8int32 * restrict  ptr_in = (v8int32 *) in;
-    v8int32 * restrict  ptr_forward = (v8int32 *) flux_forward1;
-    v8int32 * ptr_out = (v8int32 *) out;
-    
-    v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    v8int32 * restrict row2_ptr=(v8int32 *)row2;
-    v8int32 * restrict row3_ptr=(v8int32 *)row3;
-
-    // v8int32 * restrict r1=(v8int32 *)row1_ptr;
-    // v8int32 * restrict r2=(v8int32 *)row2_ptr;
-
-    // v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    // v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    // v8int32 * restrict row2_ptr=(v8int32 *)row2;
-
-    v16int32   data_buf1=null_v16int32();
-    v16int32  data_buf2=null_v16int32();
-
-    v8acc80 acc_0=null_v8acc80();
-    v8acc80 acc_1=null_v8acc80();
-          //  8 x int32 = 256b W vector
-
-  
-        // r1 = ptr_in + 1*COL/8 + aor*COL/8;
-        // r2 = ptr_in + 2*COL/8 + aor*COL/8;
-        data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
-
-        data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-
-        
-    // buf_2=R2 , and buf_1=R3
-        
-    for (unsigned i = 0; i < COL/8; i++)
-        chess_prepare_for_pipelining
-        chess_loop_range(1,)
-        {
-            v8int32  flux_sub;
-            // printf("inside flux");
-            // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
-            ptr_forward = (v8int32 *) flux_forward1+i;
-            flux_sub=*ptr_forward;
-            // flux_sub=window_readincr_v8(flux_cascade);
-            acc_1=lmul8   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);           // (lap_ij - lap_ijm)*g
-            acc_1=lmsc8   (acc_1,data_buf2,1,0x76543210,flux_sub,    0,0x00000000);     // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
-
-            // compare > 0
-            unsigned int flx_compare_imj=gt16(concat(srs(acc_1,0),undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-                        
-            // //Calculate final fly_ijm
-            v16int32 out_flx_inter1=select16(flx_compare_imj,concat(flux_sub,undef_v8int32()),null_v16int32()); 
-
-            //v16int32 flx_out1=add16(null_v16int32(),out_flx_inter1);     //still fly_ijm
-                
-    /////////////////////////////////////////////////////////////////////////////////////
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_forward2+i;
-            flux_sub=*ptr_forward;
-            
-            acc_0=lmul8   (data_buf2,3,0x76543210,flux_sub,    0,0x00000000);            // (lap_ijp - lap_ij) * h       
-            acc_0=lmsc8   (acc_0,data_buf2,2,0x76543210,flux_sub,    0,0x00000000);      //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g           
-
-            //Calculates final fly_ij (comparison > 0)
-            unsigned int flx_compare_ij=gt16(concat(srs(acc_0,0),undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter2=select16(flx_compare_ij,concat(flux_sub,undef_v8int32()),null_v16int32());    
-
-            //add fly_ij - fly_ijm
-            v16int32 flx_out2=sub16(out_flx_inter2,out_flx_inter1);                             
-/////////////////////////////////////////////////////////////////////////////////////
-
-            /// retrieving flx_imj = lap_ij - lap_imj
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_forward3+i;
-            flux_sub=*ptr_forward;
-            acc_1=lmul8   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);       //   (lap_ij - lap_imj) * g
-            acc_1=lmsc8   (acc_1,data_buf1,2,0x76543210,flux_sub,    0,0x00000000); //    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c  
-            
-          
-            
-            row3_ptr=((v8int32 *) (row3))+i;
-
-            data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-            data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-            
-            //Calculates final flx_imj (comparison > 0)
-            unsigned int fly_compare_ijm=gt16(concat(srs(acc_1,0),undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter3=select16(fly_compare_ijm,concat(flux_sub,undef_v8int32()),null_v16int32());
-
-            v16int32 flx_out3=sub16(flx_out2,out_flx_inter3);                     //adds fly_ij - fly_ijm - flx_imj
-/////////////////////////////////////////////////////////////////////////////////////
-             // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-             //re†rieving flx_ij = lap_ipj - lap_ij
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_forward4+i;
-            flux_sub=*ptr_forward;
-
-            //below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
-            acc_1=lmul8   (data_buf1,2,0x76543210,flux_sub,    0,0x00000000);      //  (lap_ipj - lap_ij) * k       
-
-            acc_1=lmsc8   (acc_1,data_buf2,2,0x76543210,flux_sub,    0,0x00000000);    //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g   
-
-            
-            // r1 = ptr_in + 1*COL/8 + i+1+ aor*COL/8;
-            row1_ptr=((v8int32 *) (row1))+i+1;
-            data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
-            data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
-     
-
-            // final flx_ij (comparison > 0 )
-            unsigned int fly_compare_ij=gt16(concat(srs(acc_1,0),undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter4=select16(fly_compare_ij,concat(flux_sub,undef_v8int32()),null_v16int32()); 
-
-            v16int32 flx_out4=add16(flx_out3,out_flx_inter4); //adds fly_ij - fly_ijm - flx_imj + flx_ij
-
-            v8acc80 final_output = lmul8  (flx_out4, 0, 0x76543210, flux_out_coeff,    0,0x00000000);  // Multiply by -7s
-            final_output=lmac8(final_output, data_buf2,  2, 0x76543210,concat(coeffs1, undef_v8int32()), 0 , 0x76543210); 
-
-
-          //LOAD DATA FOR NEXT ITERATION
-            
-         
-            row2_ptr=((v8int32 *) (row2))+i+1;
-            // data_buf1=*r1++;
-            data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
-            data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-
-            // window_writeincr(out, srs(final_output,0));
-            *ptr_out++ =  srs(final_output,0);  
-                      
-        }
-    
-
+void hdiff_flux(int32_t *restrict row1, int32_t *restrict row2,
+                int32_t *restrict row3, int32_t *restrict flux_forward1,
+                int32_t *restrict flux_forward2,
+                int32_t *restrict flux_forward3,
+                int32_t *restrict flux_forward4, int32_t *restrict out) {
+
+  alignas(32) int32_t weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) int32_t flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8int32 coeffs1 = *(v8int32 *)weights1; //  8 x int32 = 256b W vector
+  v8int32 flux_out_coeff = *(v8int32 *)flux_out;
+
+  // v8int32 * restrict  ptr_in = (v8int32 *) in;
+  v8int32 *restrict ptr_forward = (v8int32 *)flux_forward1;
+  v8int32 *ptr_out = (v8int32 *)out;
+
+  v8int32 *restrict row1_ptr = (v8int32 *)row1;
+  v8int32 *restrict row2_ptr = (v8int32 *)row2;
+  v8int32 *restrict row3_ptr = (v8int32 *)row3;
+
+  // v8int32 * restrict r1=(v8int32 *)row1_ptr;
+  // v8int32 * restrict r2=(v8int32 *)row2_ptr;
+
+  // v8int32 * restrict row0_ptr=(v8int32 *)row0;
+  // v8int32 * restrict row1_ptr=(v8int32 *)row1;
+  // v8int32 * restrict row2_ptr=(v8int32 *)row2;
+
+  v16int32 data_buf1 = null_v16int32();
+  v16int32 data_buf2 = null_v16int32();
+
+  v8acc80 acc_0 = null_v8acc80();
+  v8acc80 acc_1 = null_v8acc80();
+  //  8 x int32 = 256b W vector
+
+  // r1 = ptr_in + 1*COL/8 + aor*COL/8;
+  // r2 = ptr_in + 2*COL/8 + aor*COL/8;
+  data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
+
+  data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+
+  // buf_2=R2 , and buf_1=R3
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v8int32 flux_sub;
+      // printf("inside flux");
+      // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
+      ptr_forward = (v8int32 *)flux_forward1 + i;
+      flux_sub = *ptr_forward;
+      // flux_sub=window_readincr_v8(flux_cascade);
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g
+      acc_1 = lmsc8(acc_1, data_buf2, 1, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
+
+      // compare > 0
+      unsigned int flx_compare_imj =
+          gt16(concat(srs(acc_1, 0), undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+
+      // //Calculate final fly_ijm
+      v16int32 out_flx_inter1 = select16(
+          flx_compare_imj, concat(flux_sub, undef_v8int32()), null_v16int32());
+
+      // v16int32 flx_out1=add16(null_v16int32(),out_flx_inter1);     //still
+      // fly_ijm
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_forward2 + i;
+      flux_sub = *ptr_forward;
+
+      acc_0 = lmul8(data_buf2, 3, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ijp - lap_ij) * h
+      acc_0 = lmsc8(
+          acc_0, data_buf2, 2, 0x76543210, flux_sub, 0,
+          0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g
+
+      // Calculates final fly_ij (comparison > 0)
+      unsigned int flx_compare_ij =
+          gt16(concat(srs(acc_0, 0), undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter2 = select16(
+          flx_compare_ij, concat(flux_sub, undef_v8int32()), null_v16int32());
+
+      // add fly_ij - fly_ijm
+      v16int32 flx_out2 = sub16(out_flx_inter2, out_flx_inter1);
+      /////////////////////////////////////////////////////////////////////////////////////
+
+      /// retrieving flx_imj = lap_ij - lap_imj
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_forward3 + i;
+      flux_sub = *ptr_forward;
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); //   (lap_ij - lap_imj) * g
+      acc_1 = lmsc8(
+          acc_1, data_buf1, 2, 0x76543210, flux_sub, 0,
+          0x00000000); //    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c
+
+      row3_ptr = ((v8int32 *)(row3)) + i;
+
+      data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+
+      // Calculates final flx_imj (comparison > 0)
+      unsigned int fly_compare_ijm =
+          gt16(concat(srs(acc_1, 0), undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter3 = select16(
+          fly_compare_ijm, concat(flux_sub, undef_v8int32()), null_v16int32());
+
+      v16int32 flx_out3 =
+          sub16(flx_out2, out_flx_inter3); // adds fly_ij - fly_ijm - flx_imj
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // re†rieving flx_ij = lap_ipj - lap_ij
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_forward4 + i;
+      flux_sub = *ptr_forward;
+
+      // below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
+      acc_1 = lmul8(data_buf1, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); //  (lap_ipj - lap_ij) * k
+
+      acc_1 =
+          lmsc8(acc_1, data_buf2, 2, 0x76543210, flux_sub, 0,
+                0x00000000); //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g
+
+      // r1 = ptr_in + 1*COL/8 + i+1+ aor*COL/8;
+      row1_ptr = ((v8int32 *)(row1)) + i + 1;
+      data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
+
+      // final flx_ij (comparison > 0 )
+      unsigned int fly_compare_ij =
+          gt16(concat(srs(acc_1, 0), undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter4 = select16(
+          fly_compare_ij, concat(flux_sub, undef_v8int32()), null_v16int32());
+
+      v16int32 flx_out4 = add16(
+          flx_out3, out_flx_inter4); // adds fly_ij - fly_ijm - flx_imj + flx_ij
+
+      v8acc80 final_output = lmul8(flx_out4, 0, 0x76543210, flux_out_coeff, 0,
+                                   0x00000000); // Multiply by -7s
+      final_output = lmac8(final_output, data_buf2, 2, 0x76543210,
+                           concat(coeffs1, undef_v8int32()), 0, 0x76543210);
+
+      // LOAD DATA FOR NEXT ITERATION
+
+      row2_ptr = ((v8int32 *)(row2)) + i + 1;
+      // data_buf1=*r1++;
+      data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+
+      // window_writeincr(out, srs(final_output,0));
+      *ptr_out++ = srs(final_output, 0);
+    }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_flux_fp32.cc b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_flux_fp32.cc
index 155c248..b70ccf5 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_flux_fp32.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_flux_fp32.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,155 +9,176 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,  int32_t * restrict out)
+// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,
+// int32_t * restrict out)
 // {
-void hdiff_flux_fp32(float* restrict row1, float* restrict row2,float* restrict row3, float* restrict flux_forward1,float* restrict flux_forward2,float* restrict flux_forward3,float* restrict flux_forward4,  float * restrict out)
-{
-    
-    alignas(32) float weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) float flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8float coeffs1        = *(v8float*) weights1;  //  8 x int32 = 256b W vector
-    v8float flux_out_coeff = *(v8float*) flux_out;
-
-    // v8int32 * restrict  ptr_in = (v8int32 *) in;
-    // v8int32 * restrict  ptr_in = (v8int32 *) in;
-    v8float * restrict  ptr_forward = (v8float *) flux_forward1;
-    v8float * ptr_out = (v8float *) out;
-    
-    v8float * restrict row1_ptr=(v8float *)row1;
-    v8float * restrict row2_ptr=(v8float *)row2;
-    v8float * restrict row3_ptr=(v8float *)row3;
-
-    // v8int32 * restrict r1=(v8int32 *)row1_ptr;
-    // v8int32 * restrict r2=(v8int32 *)row2_ptr;
-
-    // v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    // v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    // v8int32 * restrict row2_ptr=(v8int32 *)row2;
-
-    v16float   data_buf1=null_v16float();
-    v16float  data_buf2=null_v16float();
-
-    v8float acc_0=null_v8float();
-    v8float acc_1=null_v8float();
-          //  8 x int32 = 256b W vector
-
-  
-        // r1 = ptr_in + 1*COL/8 + aor*COL/8;
-        // r2 = ptr_in + 2*COL/8 + aor*COL/8;
-        data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
-
-        data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-
-        
-    // buf_2=R2 , and buf_1=R3
-        
-    for (unsigned i = 0; i < COL/8; i++)
-        chess_prepare_for_pipelining
-        chess_loop_range(1,)
-        {
-          v8float  flux_sub;
-          // printf("inside flux");
-          // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-          // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
-          ptr_forward = (v8float *) flux_forward1+i;
-          flux_sub=*ptr_forward;
-          // flux_sub=window_readincr_v8(flux_cascade);
-          acc_1=fpmul   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);///  (lap_ij - lap_ijm)*g
-          acc_1=fpmsc   (acc_1,data_buf2,1,0x76543210,flux_sub,    0,0x00000000);// (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
-
-          // compare > 0
-          unsigned int flx_compare_imj=fpge (acc_1, null_v16float(), 0,0x76543210); /// flx_ijm * (test_in[d][c][r] - test_in[d][c][r-1]) > 0 ? 0 :
-
-          //Calculate final fly_ijm
-          v16float out_flx_inter1=fpselect16(flx_compare_imj,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-
-          v8float flx_out1=fpadd(null_v8float(),out_flx_inter1,0,0x76543210);   //still fly_ijm
-
-          /////////////////////////////////////////////////////////////////////////////////////
-          // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-          // flux_sub=window_readincr_v8(flux_cascade);
-          ptr_forward = (v8float *) flux_forward2+i;
-          flux_sub=*ptr_forward;
-
-          acc_0=fpmul   (data_buf2,3,0x76543210,flux_sub,    0,0x00000000); // (lap_ijp - lap_ij) * h    
-          acc_0=fpmsc   (acc_1,data_buf2,2,0x76543210,flux_sub,    0,0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g                     
-
-          //Calculates final fly_ij (comparison > 0)
-          //Calculates final fly_ij (comparison > 0)
-          unsigned int flx_compare_ij=fpge (acc_0, null_v16float(), 0,0x76543210); 
-          v16float out_flx_inter2=fpselect16(flx_compare_ij,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-
-          //fly_ijm -fly_ij
-          v8float flx_out2=fpsub(flx_out1,out_flx_inter2,0,0x76543210);                          
-          /////////////////////////////////////////////////////////////////////////////////////
-
-          /// retrieving flx_imj = lap_ij - lap_imj
-          // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-          // flux_sub=window_readincr_v8(flux_cascade);
-          ptr_forward = (v8float *) flux_forward3+i;
-          flux_sub=*ptr_forward;
-          acc_1=fpmul   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);///   (lap_ij - lap_imj) * g
-          acc_1=fpmsc   (acc_1,data_buf1,2,0x76543210,flux_sub,    0,0x00000000);///    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c          
-
-
-
-
-          row3_ptr=((v8float *) (row3))+i;
-          // r1 = ptr_in + 3*COL/8 + i + aor*COL/8; // load for LAP_ijp for fly_ij
-          // data_buf1=*r1++;
-          data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-          data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-
-          //Calculates final flx_imj (comparison > 0)
-          unsigned int fly_compare_ijm=fpge (acc_1, null_v16float(), 0,0x76543210);
-          v16float out_flx_inter3=fpselect16(fly_compare_ijm,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-
-          v8float flx_out3=fpadd(flx_out2,out_flx_inter3,0,0x76543210);     //adds fly_ijm -fly_ij + flx_imj 
-
-          /////////////////////////////////////////////////////////////////////////////////////
-          // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-          //re†rieving flx_ij = lap_ipj - lap_ij
-          // flux_sub=window_readincr_v8(flux_cascade);
-          ptr_forward = (v8float *) flux_forward4+i;
-          flux_sub=*ptr_forward;
-
-          //below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
-          acc_1=fpmul   (data_buf1,2,0x76543210,flux_sub,    0,0x00000000);//  (lap_ipj - lap_ij) * k       
-
-          acc_1=fpmsc   (acc_1,data_buf2,2,0x76543210,flux_sub,    0,0x00000000);    //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g   
-
-          // r1 = ptr_in + 1*COL/8 + i+1+ aor*COL/8;
-          row1_ptr=((v8float *) (row1))+i+1;
-          data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
-          data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
-
-
-          // final flx_ij (comparison > 0 )
-          unsigned int fly_compare_ij=fpge (acc_1, null_v16float(), 0,0x76543210);
-          v16float out_flx_inter4=fpselect16(fly_compare_ij,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-
-          v8float flx_out4=fpsub(flx_out3,out_flx_inter4,0,0x76543210); //adds  fly_ijm -fly_ij + flx_imj -flx_ij
-
-          v8float   final_output=fpmul  (concat(flx_out4,null_v8float()),0,0x76543210,flux_out_coeff,    0,0x00000000);  // Multiply by +7s
-          final_output=fpmac(final_output,data_buf2,  2, 0x76543210,coeffs1, 0 , 0x76543210); 
-
-          //LOAD DATA FOR NEXT ITERATION
-
-
-          row2_ptr=((v8float *) (row2))+i+1;
-          // data_buf1=*r1++;
-          data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
-          data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-
-          // window_writeincr(out, srs(final_output,0));
-          *ptr_out++ =  final_output;  
-                      
-        }
-    
-
+void hdiff_flux_fp32(float *restrict row1, float *restrict row2,
+                     float *restrict row3, float *restrict flux_forward1,
+                     float *restrict flux_forward2,
+                     float *restrict flux_forward3,
+                     float *restrict flux_forward4, float *restrict out) {
+
+  alignas(32) float weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) float flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8float coeffs1 = *(v8float *)weights1; //  8 x int32 = 256b W vector
+  v8float flux_out_coeff = *(v8float *)flux_out;
+
+  // v8int32 * restrict  ptr_in = (v8int32 *) in;
+  // v8int32 * restrict  ptr_in = (v8int32 *) in;
+  v8float *restrict ptr_forward = (v8float *)flux_forward1;
+  v8float *ptr_out = (v8float *)out;
+
+  v8float *restrict row1_ptr = (v8float *)row1;
+  v8float *restrict row2_ptr = (v8float *)row2;
+  v8float *restrict row3_ptr = (v8float *)row3;
+
+  // v8int32 * restrict r1=(v8int32 *)row1_ptr;
+  // v8int32 * restrict r2=(v8int32 *)row2_ptr;
+
+  // v8int32 * restrict row0_ptr=(v8int32 *)row0;
+  // v8int32 * restrict row1_ptr=(v8int32 *)row1;
+  // v8int32 * restrict row2_ptr=(v8int32 *)row2;
+
+  v16float data_buf1 = null_v16float();
+  v16float data_buf2 = null_v16float();
+
+  v8float acc_0 = null_v8float();
+  v8float acc_1 = null_v8float();
+  //  8 x int32 = 256b W vector
+
+  // r1 = ptr_in + 1*COL/8 + aor*COL/8;
+  // r2 = ptr_in + 2*COL/8 + aor*COL/8;
+  data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
+
+  data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+
+  // buf_2=R2 , and buf_1=R3
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v8float flux_sub;
+      // printf("inside flux");
+      // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
+      ptr_forward = (v8float *)flux_forward1 + i;
+      flux_sub = *ptr_forward;
+      // flux_sub=window_readincr_v8(flux_cascade);
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); ///  (lap_ij - lap_ijm)*g
+      acc_1 = fpmsc(acc_1, data_buf2, 1, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
+
+      // compare > 0
+      unsigned int flx_compare_imj =
+          fpge(acc_1, null_v16float(), 0,
+               0x76543210); /// flx_ijm * (test_in[d][c][r] -
+                            /// test_in[d][c][r-1]) > 0 ? 0 :
+
+      // Calculate final fly_ijm
+      v16float out_flx_inter1 = fpselect16(
+          flx_compare_imj, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      v8float flx_out1 =
+          fpadd(null_v8float(), out_flx_inter1, 0, 0x76543210); // still fly_ijm
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_forward2 + i;
+      flux_sub = *ptr_forward;
+
+      acc_0 = fpmul(data_buf2, 3, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ijp - lap_ij) * h
+      acc_0 = fpmsc(
+          acc_1, data_buf2, 2, 0x76543210, flux_sub, 0,
+          0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g
+
+      // Calculates final fly_ij (comparison > 0)
+      // Calculates final fly_ij (comparison > 0)
+      unsigned int flx_compare_ij = fpge(acc_0, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter2 = fpselect16(
+          flx_compare_ij, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      // fly_ijm -fly_ij
+      v8float flx_out2 = fpsub(flx_out1, out_flx_inter2, 0, 0x76543210);
+      /////////////////////////////////////////////////////////////////////////////////////
+
+      /// retrieving flx_imj = lap_ij - lap_imj
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_forward3 + i;
+      flux_sub = *ptr_forward;
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); ///   (lap_ij - lap_imj) * g
+      acc_1 = fpmsc(
+          acc_1, data_buf1, 2, 0x76543210, flux_sub, 0,
+          0x00000000); ///    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c
+
+      row3_ptr = ((v8float *)(row3)) + i;
+      // r1 = ptr_in + 3*COL/8 + i + aor*COL/8; // load for LAP_ijp for fly_ij
+      // data_buf1=*r1++;
+      data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+
+      // Calculates final flx_imj (comparison > 0)
+      unsigned int fly_compare_ijm =
+          fpge(acc_1, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter3 = fpselect16(
+          fly_compare_ijm, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      v8float flx_out3 = fpadd(flx_out2, out_flx_inter3, 0,
+                               0x76543210); // adds fly_ijm -fly_ij + flx_imj
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // re†rieving flx_ij = lap_ipj - lap_ij
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_forward4 + i;
+      flux_sub = *ptr_forward;
+
+      // below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
+      acc_1 = fpmul(data_buf1, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); //  (lap_ipj - lap_ij) * k
+
+      acc_1 =
+          fpmsc(acc_1, data_buf2, 2, 0x76543210, flux_sub, 0,
+                0x00000000); //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g
+
+      // r1 = ptr_in + 1*COL/8 + i+1+ aor*COL/8;
+      row1_ptr = ((v8float *)(row1)) + i + 1;
+      data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
+
+      // final flx_ij (comparison > 0 )
+      unsigned int fly_compare_ij = fpge(acc_1, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter4 = fpselect16(
+          fly_compare_ij, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      v8float flx_out4 =
+          fpsub(flx_out3, out_flx_inter4, 0,
+                0x76543210); // adds  fly_ijm -fly_ij + flx_imj -flx_ij
+
+      v8float final_output =
+          fpmul(concat(flx_out4, null_v8float()), 0, 0x76543210, flux_out_coeff,
+                0, 0x00000000); // Multiply by +7s
+      final_output =
+          fpmac(final_output, data_buf2, 2, 0x76543210, coeffs1, 0, 0x76543210);
+
+      // LOAD DATA FOR NEXT ITERATION
+
+      row2_ptr = ((v8float *)(row2)) + i + 1;
+      // data_buf1=*r1++;
+      data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+
+      // window_writeincr(out, srs(final_output,0));
+      *ptr_out++ = final_output;
+    }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_lap.cc b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_lap.cc
index 8e67e50..20b0b8d 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_lap.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_lap.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,173 +9,195 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-//align to 16 bytes boundary, equivalent to "alignas(v4int32)"
-void hdiff_lap(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict row2,int32_t* restrict row3,int32_t* restrict row4, int32_t* restrict out_flux1, int32_t* restrict out_flux2, int32_t* restrict out_flux3, int32_t* restrict out_flux4 )
-{
-
- // const int32_t *restrict w = weights;
-    alignas(32) int32_t weights[8] = {-4,-4,-4,-4,-4,-4,-4,-4};
-    alignas(32) int32_t weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) int32_t weights_rest[8] = {-1,-1,-1,-1,-1,-1,-1,-1};
-    alignas(32) int32_t flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8int32 coeffs         = *(v8int32*) weights;  //  8 x int32 = 256b W vector
-    v8int32 coeffs1        = *(v8int32*) weights1;  //  8 x int32 = 256b W vector
-    v8int32 coeffs_rest    = *(v8int32*) weights_rest;  //  8 x int32 = 256b W vector
-    v8int32 flux_out_coeff = *(v8int32*) flux_out;
-
-    // v8int32 * restrict ptr_in = (v8int32 *) in;
-    v8int32 * ptr_out = (v8int32 *) out_flux1;
-    v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    v8int32 * restrict row2_ptr=(v8int32 *)row2;
-    v8int32 * restrict row3_ptr=(v8int32 *)row3;
-    v8int32 * restrict row4_ptr=(v8int32 *)row4;
-    v8int32 * restrict r1;
-    // v8int32 * restrict r2;
-    // v8int32 * restrict r2=ptr_in+1*COL/8;
-
-    v16int32 data_buf1 = null_v16int32();
-    v16int32 data_buf2 = null_v16int32();
-    
-    v8acc80 acc_0 = null_v8acc80();
-    v8acc80 acc_1 = null_v8acc80();
-
-    //  v8acc80 acc_1=null_v8acc80();        
-    v8int32 lap_ij = null_v8int32();      //  8 x int32 = 256b W vector
-    v8int32 lap_0  = null_v8int32();      //  8 x int32 = 256b W vector
-
-
-
-        data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-        data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
-    
-        for (unsigned i = 0; i < COL/8; i++)
-            chess_prepare_for_pipelining
-                    chess_loop_range(1,)
-        {   
-            v16int32 flux_sub;
-
-            acc_0=lmul8   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);          //c           
-            acc_1=lmul8   (data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);          //b
-          
-            acc_0=lmac8   (acc_0,data_buf1,2,0x76543210,coeffs_rest,    0,0x00000000);    //c,k
-            acc_1=lmac8   (acc_1,data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);    //b,j
-          
-            // r2 = ptr_in+2 * COL/8+i ;
-            row2_ptr=((v8int32 *) (row2))+i;
-            data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
-
-            acc_0=lmac8   (acc_0,data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000); //c,k,f
-            acc_0=lmsc8   (acc_0,data_buf2,2,0x76543210,coeffs,    0,0x00000000);      //c,k,f,4*g
-            acc_0=lmac8   (acc_0,data_buf2,3,0x76543210,coeffs_rest,    0,0x00000000);  //c,k,f,4*g,h
-            
-            lap_ij=srs(acc_0,0); //store lap_ij
-
-            acc_1=lmac8   (acc_1,data_buf2,0,0x76543210,coeffs_rest,    0,0x00000000); //b,j,e
-            acc_1=lmsc8   (acc_1,data_buf2,1,0x76543210,coeffs,    0,0x00000000);      //b,j,e,4*f
-            acc_1=lmac8   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);  //b,j,e,4*f,g  
-           
-            //lap_ijm
-            lap_0=srs(acc_1,0);
-            
-            //Calculate  lap_ij - lap_ijm
-            
-            flux_sub = sub16(concat(lap_ij,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_0,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 ); 
-            ptr_out = (v8int32 *) out_flux1;
-            *ptr_out =  ext_w(flux_sub,0);
-            //
-          
-            acc_0=lmul8   (data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);   // l
-            acc_0=lmsc8   (acc_0,data_buf2,3,0x76543210,coeffs,    0,0x00000000);  // l, 4*h
-        
-
-            // r1 = ptr_in+1 * COL/8+i ;
-            row1_ptr=((v8int32 *) (row1))+i;
-            data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));     
-
-            acc_0=lmac8  (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);  // l, 4*h, g
-            acc_0=lmac8   (acc_0,data_buf2,4,0x76543210,coeffs_rest,    0,0x00000000); // l, 4*h, g, i 
-
-                      
-            acc_0=lmac8   (acc_0,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);// l, 4*h, g, i, d 
-            
-            //Calculates lap_ijp
-            lap_0=srs(acc_0,0); 
-
-            //Calculates lap_ijp - lap_ij
-            flux_sub = sub16(concat(lap_0,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_ij,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 );
-            ptr_out= (v8int32 *) out_flux2;
-            *ptr_out=  ext_w(flux_sub,0);
-                 
-
-            //***********************************************************************STARTING X FLUX*****************************************************************************************************************************************************
-            
-            acc_1=lmul8    ( data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000); // g                     
-            acc_0=lmul8   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);   // g
-
-            // r2 = ptr_in + 0*COL/8 + i ; 
-            row0_ptr=((v8int32 *) (row0))+i;
-            data_buf2 = upd_w(data_buf2, 0, *(row0_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row0_ptr));
-                  
-            acc_1=lmsc8    (acc_1, data_buf1,2,0x76543210,coeffs,    0,0x00000000);             // g, 4*c
-            acc_1=lmac8    (acc_1, data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);        // g, 4*c, b
-            acc_1=lmac8   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);          // g, 4*c, b, a
-          
-            // r2 = ptr_in + 4*COL/8 + i ; 
-            row4_ptr=((v8int32 *) (row4))+i;
-            data_buf2 = upd_w(data_buf2, 0, *(row4_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row4_ptr));
-
-            acc_1=lmac8    ( acc_1,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b, a, d               
-            acc_0=lmac8   (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);         // g, m
-   
-            
-            //Calculates lap_imj
-            lap_0=srs(acc_1,0); 
-
-            flux_sub = sub16(concat(lap_ij,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_0,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 ); 
-            ptr_out= (v8int32 *) out_flux3;
-            *ptr_out =  ext_w(flux_sub,0);
-
-            
-            // r1 = ptr_in + 3*COL/8 + i ;
-            row3_ptr=((v8int32 *) (row3))+i;
-            data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
-
-            acc_0=lmsc8   (acc_0,data_buf1,2,0x76543210,coeffs,    0,0x00000000); //g, m , k * 4
-
-            // v16int32 flx_out3=sub16(flx_out2,out_flx_inter3);                     //adds fly_ij - fly_ijm - flx_imj
-
-            acc_0=lmac8   (acc_0,data_buf1, 1,0x76543210,coeffs_rest,    0,0x00000000);     //g, m , k * 4, j 
-            
-            //LOAD DATA FOR NEXT ITERATION
-            // r2 = ptr_in + 1*COL/8 + i + 1 ;
-            row1_ptr=((v8int32 *) (row1))+i+1;
-            data_buf2 = upd_w(data_buf2, 0, *(row1_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row1_ptr));
-
-            acc_0=lmac8   (acc_0,data_buf1, 3,0x76543210,coeffs_rest,    0,0x00000000);     //g, m , k * 4, j, l  
-
-            //  flx_ij = lap_ipj - lap_ij
-            flux_sub = sub16(concat(srs(acc_0,0),undef_v8int32()), 0, 0x76543210, 0xFEDCBA98, concat(lap_ij,undef_v8int32()),   0,  0x76543210, 0xFEDCBA98 ); 
-             ptr_out= (v8int32 *) out_flux4;
-             *ptr_out =  ext_w(flux_sub,0);
-
-             
-            //LOAD DATA FOR NEXT ITERATION
-            row3_ptr=((v8int32 *) (row3))+i+1;
-            data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
-
-        // }
-
+// align to 16 bytes boundary, equivalent to "alignas(v4int32)"
+void hdiff_lap(int32_t *restrict row0, int32_t *restrict row1,
+               int32_t *restrict row2, int32_t *restrict row3,
+               int32_t *restrict row4, int32_t *restrict out_flux1,
+               int32_t *restrict out_flux2, int32_t *restrict out_flux3,
+               int32_t *restrict out_flux4) {
+
+  // const int32_t *restrict w = weights;
+  alignas(32) int32_t weights[8] = {-4, -4, -4, -4, -4, -4, -4, -4};
+  alignas(32) int32_t weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) int32_t weights_rest[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
+  alignas(32) int32_t flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8int32 coeffs = *(v8int32 *)weights;           //  8 x int32 = 256b W vector
+  v8int32 coeffs1 = *(v8int32 *)weights1;         //  8 x int32 = 256b W vector
+  v8int32 coeffs_rest = *(v8int32 *)weights_rest; //  8 x int32 = 256b W vector
+  v8int32 flux_out_coeff = *(v8int32 *)flux_out;
+
+  // v8int32 * restrict ptr_in = (v8int32 *) in;
+  v8int32 *ptr_out = (v8int32 *)out_flux1;
+  v8int32 *restrict row0_ptr = (v8int32 *)row0;
+  v8int32 *restrict row1_ptr = (v8int32 *)row1;
+  v8int32 *restrict row2_ptr = (v8int32 *)row2;
+  v8int32 *restrict row3_ptr = (v8int32 *)row3;
+  v8int32 *restrict row4_ptr = (v8int32 *)row4;
+  v8int32 *restrict r1;
+  // v8int32 * restrict r2;
+  // v8int32 * restrict r2=ptr_in+1*COL/8;
+
+  v16int32 data_buf1 = null_v16int32();
+  v16int32 data_buf2 = null_v16int32();
+
+  v8acc80 acc_0 = null_v8acc80();
+  v8acc80 acc_1 = null_v8acc80();
+
+  //  v8acc80 acc_1=null_v8acc80();
+  v8int32 lap_ij = null_v8int32(); //  8 x int32 = 256b W vector
+  v8int32 lap_0 = null_v8int32();  //  8 x int32 = 256b W vector
+
+  data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+  data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v16int32 flux_sub;
+
+      acc_0 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // c
+      acc_1 = lmul8(data_buf2, 1, 0x76543210, coeffs_rest, 0, 0x00000000); // b
+
+      acc_0 = lmac8(acc_0, data_buf1, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k
+      acc_1 = lmac8(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j
+
+      // r2 = ptr_in+2 * COL/8+i ;
+      row2_ptr = ((v8int32 *)(row2)) + i;
+      data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
+
+      acc_0 = lmac8(acc_0, data_buf2, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k,f
+      acc_0 = lmsc8(acc_0, data_buf2, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // c,k,f,4*g
+      acc_0 = lmac8(acc_0, data_buf2, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k,f,4*g,h
+
+      lap_ij = srs(acc_0, 0); // store lap_ij
+
+      acc_1 = lmac8(acc_1, data_buf2, 0, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j,e
+      acc_1 = lmsc8(acc_1, data_buf2, 1, 0x76543210, coeffs, 0,
+                    0x00000000); // b,j,e,4*f
+      acc_1 = lmac8(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j,e,4*f,g
+
+      // lap_ijm
+      lap_0 = srs(acc_1, 0);
+
+      // Calculate  lap_ij - lap_ijm
+
+      flux_sub =
+          sub16(concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+      ptr_out = (v8int32 *)out_flux1;
+      *ptr_out = ext_w(flux_sub, 0);
+      //
+
+      acc_0 = lmul8(data_buf1, 3, 0x76543210, coeffs_rest, 0, 0x00000000); // l
+      acc_0 = lmsc8(acc_0, data_buf2, 3, 0x76543210, coeffs, 0,
+                    0x00000000); // l, 4*h
+
+      // r1 = ptr_in+1 * COL/8+i ;
+      row1_ptr = ((v8int32 *)(row1)) + i;
+      data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));
+
+      acc_0 = lmac8(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g
+      acc_0 = lmac8(acc_0, data_buf2, 4, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g, i
+
+      acc_0 = lmac8(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g, i, d
+
+      // Calculates lap_ijp
+      lap_0 = srs(acc_0, 0);
+
+      // Calculates lap_ijp - lap_ij
+      flux_sub =
+          sub16(concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+      ptr_out = (v8int32 *)out_flux2;
+      *ptr_out = ext_w(flux_sub, 0);
+
+      //***********************************************************************STARTING
+      //X
+      //FLUX*****************************************************************************************************************************************************
+
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+      acc_0 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+
+      // r2 = ptr_in + 0*COL/8 + i ;
+      row0_ptr = ((v8int32 *)(row0)) + i;
+      data_buf2 = upd_w(data_buf2, 0, *(row0_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row0_ptr));
+
+      acc_1 = lmsc8(acc_1, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, 4*c
+      acc_1 = lmac8(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b
+      acc_1 = lmac8(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a
+
+      // r2 = ptr_in + 4*COL/8 + i ;
+      row4_ptr = ((v8int32 *)(row4)) + i;
+      data_buf2 = upd_w(data_buf2, 0, *(row4_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row4_ptr));
+
+      acc_1 = lmac8(acc_1, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a, d
+      acc_0 = lmac8(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m
+
+      // Calculates lap_imj
+      lap_0 = srs(acc_1, 0);
+
+      flux_sub =
+          sub16(concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+      ptr_out = (v8int32 *)out_flux3;
+      *ptr_out = ext_w(flux_sub, 0);
+
+      // r1 = ptr_in + 3*COL/8 + i ;
+      row3_ptr = ((v8int32 *)(row3)) + i;
+      data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
+
+      acc_0 = lmsc8(acc_0, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, m , k * 4
+
+      // v16int32 flx_out3=sub16(flx_out2,out_flx_inter3); //adds fly_ij -
+      // fly_ijm - flx_imj
+
+      acc_0 = lmac8(acc_0, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m , k * 4, j
+
+      // LOAD DATA FOR NEXT ITERATION
+      //  r2 = ptr_in + 1*COL/8 + i + 1 ;
+      row1_ptr = ((v8int32 *)(row1)) + i + 1;
+      data_buf2 = upd_w(data_buf2, 0, *(row1_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row1_ptr));
+
+      acc_0 = lmac8(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m , k * 4, j, l
+
+      //  flx_ij = lap_ipj - lap_ij
+      flux_sub = sub16(concat(srs(acc_0, 0), undef_v8int32()), 0, 0x76543210,
+                       0xFEDCBA98, concat(lap_ij, undef_v8int32()), 0,
+                       0x76543210, 0xFEDCBA98);
+      ptr_out = (v8int32 *)out_flux4;
+      *ptr_out = ext_w(flux_sub, 0);
+
+      // LOAD DATA FOR NEXT ITERATION
+      row3_ptr = ((v8int32 *)(row3)) + i + 1;
+      data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
+
+      // }
     }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_lap_fp32.cc b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_lap_fp32.cc
index 6f252f7..a183c57 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_lap_fp32.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/hdiff_lap_fp32.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,168 +9,182 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-//align to 16 bytes boundary, equivalent to "alignas(v4int32)"
-void hdiff_lap_fp32(float* restrict row0, float* restrict row1,float* restrict row2,float* restrict row3,float* restrict row4, float* restrict out_flux1, float* restrict out_flux2, float* restrict out_flux3, float* restrict out_flux4 )
-{
-
- // const float *restrict w = weights;
-    alignas(32) float weights[8] = {-4,-4,-4,-4,-4,-4,-4,-4};
-    alignas(32) float weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) float weights_rest[8] = {-1,-1,-1,-1,-1,-1,-1,-1};
-    alignas(32) float flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8float coeffs         = *(v8float*) weights;  //  8 x int32 = 256b W vector
-    v8float coeffs1        = *(v8float*) weights1;  //  8 x int32 = 256b W vector
-    v8float coeffs_rest    = *(v8float*) weights_rest;  //  8 x int32 = 256b W vector
-    v8float flux_out_coeff = *(v8float*) flux_out;
-
-    // v8float * restrict ptr_in = (v8float *) in;
-    v8float * ptr_out = (v8float *) out_flux1;
-    v8float * restrict row0_ptr=(v8float *)row0;
-    v8float * restrict row1_ptr=(v8float *)row1;
-    v8float * restrict row2_ptr=(v8float *)row2;
-    v8float * restrict row3_ptr=(v8float *)row3;
-    v8float * restrict row4_ptr=(v8float *)row4;
-    v8float * restrict r1;
-    // v8float * restrict r2=ptr_in+1*COL/8;
-
-    v16float   data_buf1=null_v16float();
-    v16float  data_buf2=null_v16float();
-    
-    v8float acc_0 = null_v8float();
-    v8float acc_1 = null_v8float();
-
-    //  v8acc80 acc_1=null_v8acc80();        
-    v8float lap_ij = null_v8float();      //  8 x int32 = 256b W vector
-    v8float lap_0  = null_v8float();      //  8 x int32 = 256b W vector
-
-
-
-        data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-        data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
-    
-        for (unsigned i = 0; i < COL/8; i++)
-            chess_prepare_for_pipelining
-                    chess_loop_range(1,)
-        {   
-            v8float flux_sub;
-
-            lap_ij=fpmul (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///  //c            
-            acc_1=fpmul(data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);        //b
-          
-            lap_ij=fpmac   (lap_ij,data_buf1,2,0x76543210,coeffs_rest,    0,0x00000000);///  //c,k 
-            acc_1=fpmac   (acc_1,data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);///  //b,j
-          
-            // r2 = ptr_in+2 * COL/8+i ;
-            row2_ptr=((v8float *) (row2))+i;
-            data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
-
-            ///////// **************************LAP_ij**************************************
-            lap_ij=fpmac   (lap_ij,data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);///  //c,k,f
-            lap_ij=fpmsc   (lap_ij,data_buf2,2,0x76543210,coeffs,    0,0x00000000);///  //c,k,f,4*g
-            lap_ij=fpmac   (lap_ij,data_buf2,3,0x76543210,coeffs_rest,    0,0x00000000);///  c,k,f,4*g,h
-        
-                ///////// **************************LAP_ijm**************************************               
-            acc_1=fpmac   (acc_1,data_buf2,0,0x76543210,coeffs_rest,    0,0x00000000);///  //b,j,e         
-            acc_1=fpmsc   (acc_1,data_buf2,1,0x76543210,coeffs,    0,0x00000000);///         //b,j,e,4*f   
-            acc_1=fpmac   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///     //b,j,e,4*f,g   
-        
-            //Calculate  lap_ij - lap_ijm
-            flux_sub = fpsub(lap_ij, concat(acc_1,undef_v8float()), 0, 0x76543210); // flx_imj = lap_ij - lap_ijm;
-            ptr_out= (v8float *) out_flux1+i;
-            *ptr_out =  flux_sub;
-            //
-          
-            acc_0=fpmul   (data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);/// // l ; R1 is already loaded
-            acc_0=fpmsc   (acc_0,data_buf2,3,0x76543210,coeffs,    0,0x00000000);///   // l, 4*h
-        
-
-            // r1 = ptr_in+1 * COL/8+i ;
-            row1_ptr=((v8float *) (row1))+i;
-            data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));    
-
-            acc_0=fpmac  (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///  lap_ijp // l, 4*h, g
-            acc_0=fpmac   (acc_0,data_buf2,4,0x76543210,coeffs_rest,    0,0x00000000);///  l, 4*h, g, i   
-
-                      
-            acc_0=fpmac   (acc_0,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);///  // l, 4*h, g, i, d  
-
-            flux_sub = fpsub(acc_0, concat(lap_ij,undef_v8float()), 0, 0x76543210); 
-            ptr_out= (v8float *) out_flux2+i;
-            *ptr_out=  flux_sub;
-                 
-
-          
-            acc_1=fpmul    ( data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);        // g                
-            acc_0=fpmul   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);// g   
-
-            // r2 = ptr_in + 0*COL/8 + i ; 
-            row0_ptr=((v8float *) (row0))+i;
-            // r2 = ptr_in + 0*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm 
-            data_buf2 = upd_w(data_buf2, 0, *row0_ptr++);
-            data_buf2 = upd_w(data_buf2, 1, *row0_ptr);
-                
-            acc_1=fpmsc    (acc_1, data_buf1,2,0x76543210,coeffs,    0,0x00000000);      // g, 4*c
-            acc_1=fpmac    (acc_1, data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b
-            acc_1=fpmac   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);/// // g, 4*c, b, a
-          
-            // r2 = ptr_in + 4*COL/8 + i ; 
-            row4_ptr=((v8float *) (row4))+i;
-            // r2 = ptr_in + 4*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm 
-            data_buf2 = upd_w(data_buf2, 0, *row4_ptr++);
-            data_buf2 = upd_w(data_buf2, 1, *row4_ptr);
-                //////// **************************LAP_ipj for fly_ij since r2=R4********
-            acc_1=fpmac    ( acc_1,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b, a, d  
-            acc_0=fpmac   (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///   // g, m
-
-            
-            // //Calculates lap_imj
-            // lap_0=srs(acc_1,0); 
-
-            flux_sub = fpsub(lap_ij, concat(acc_1,undef_v8float()), 0, 0x76543210); 
-            ptr_out= (v8float *) out_flux3+i;
-            *ptr_out =  flux_sub;
-
-            
-            // r1 = ptr_in + 3*COL/8 + i ;
-            row3_ptr=((v8float *) (row3))+i;
-            // r1 = ptr_in + 3*COL/8 + i + aor*COL/8; // load for LAP_ijp for fly_ij
-            // data_buf1=*r1++;
-            data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-            data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-
-            acc_0=fpmsc   (acc_0,data_buf1,2,0x76543210,coeffs,    0,0x00000000);///  //g, m , k * 4
-
-            // v16int32 flx_out3=sub16(flx_out2,out_flx_inter3);                     //adds fly_ij - fly_ijm - flx_imj
-
-            acc_0=fpmac   (acc_0,data_buf1, 1,0x76543210,coeffs_rest,    0,0x00000000);///  //g, m , k * 4, j   
-           
-           //LOAD DATA FOR NEXT ITERATION
-            // r2 = ptr_in + 1*COL/8 + i + 1 ;
-            row1_ptr=((v8float *) (row1))+i+1;
-            data_buf2 = upd_w(data_buf2, 0, *(row1_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row1_ptr));
-            acc_0=fpmac   (acc_0,data_buf1, 3,0x76543210,coeffs_rest,    0,0x00000000);///   //g, m , k * 4, j, l 
-           
-
-            //  flx_ij = lap_ipj - lap_ij
-            flux_sub = fpsub(acc_0, concat(lap_ij,undef_v8float()), 0, 0x76543210);
-            ptr_out= (v8float *) out_flux4+i;
-            *ptr_out =  flux_sub,0;
-
-             //LOAD DATA FOR NEXT ITERATION
-            row3_ptr=((v8float *) (row3))+i+1;
-            data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
-             
-            
-
-        // }
-
+// align to 16 bytes boundary, equivalent to "alignas(v4int32)"
+void hdiff_lap_fp32(float *restrict row0, float *restrict row1,
+                    float *restrict row2, float *restrict row3,
+                    float *restrict row4, float *restrict out_flux1,
+                    float *restrict out_flux2, float *restrict out_flux3,
+                    float *restrict out_flux4) {
+
+  // const float *restrict w = weights;
+  alignas(32) float weights[8] = {-4, -4, -4, -4, -4, -4, -4, -4};
+  alignas(32) float weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) float weights_rest[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
+  alignas(32) float flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8float coeffs = *(v8float *)weights;           //  8 x int32 = 256b W vector
+  v8float coeffs1 = *(v8float *)weights1;         //  8 x int32 = 256b W vector
+  v8float coeffs_rest = *(v8float *)weights_rest; //  8 x int32 = 256b W vector
+  v8float flux_out_coeff = *(v8float *)flux_out;
+
+  // v8float * restrict ptr_in = (v8float *) in;
+  v8float *ptr_out = (v8float *)out_flux1;
+  v8float *restrict row0_ptr = (v8float *)row0;
+  v8float *restrict row1_ptr = (v8float *)row1;
+  v8float *restrict row2_ptr = (v8float *)row2;
+  v8float *restrict row3_ptr = (v8float *)row3;
+  v8float *restrict row4_ptr = (v8float *)row4;
+  v8float *restrict r1;
+  // v8float * restrict r2=ptr_in+1*COL/8;
+
+  v16float data_buf1 = null_v16float();
+  v16float data_buf2 = null_v16float();
+
+  v8float acc_0 = null_v8float();
+  v8float acc_1 = null_v8float();
+
+  //  v8acc80 acc_1=null_v8acc80();
+  v8float lap_ij = null_v8float(); //  8 x int32 = 256b W vector
+  v8float lap_0 = null_v8float();  //  8 x int32 = 256b W vector
+
+  data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+  data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v8float flux_sub;
+
+      lap_ij =
+          fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); ///  //c
+      acc_1 = fpmul(data_buf2, 1, 0x76543210, coeffs_rest, 0, 0x00000000); // b
+
+      lap_ij = fpmac(lap_ij, data_buf1, 2, 0x76543210, coeffs_rest, 0,
+                     0x00000000); ///  //c,k
+      acc_1 = fpmac(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //b,j
+
+      // r2 = ptr_in+2 * COL/8+i ;
+      row2_ptr = ((v8float *)(row2)) + i;
+      data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
+
+      /////////
+      ///**************************LAP_ij**************************************
+      lap_ij = fpmac(lap_ij, data_buf2, 1, 0x76543210, coeffs_rest, 0,
+                     0x00000000); ///  //c,k,f
+      lap_ij = fpmsc(lap_ij, data_buf2, 2, 0x76543210, coeffs, 0,
+                     0x00000000); ///  //c,k,f,4*g
+      lap_ij = fpmac(lap_ij, data_buf2, 3, 0x76543210, coeffs_rest, 0,
+                     0x00000000); ///  c,k,f,4*g,h
+
+      /////////
+      ///**************************LAP_ijm**************************************
+      acc_1 = fpmac(acc_1, data_buf2, 0, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //b,j,e
+      acc_1 = fpmsc(acc_1, data_buf2, 1, 0x76543210, coeffs, 0,
+                    0x00000000); ///         //b,j,e,4*f
+      acc_1 = fpmac(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///     //b,j,e,4*f,g
+
+      // Calculate  lap_ij - lap_ijm
+      flux_sub = fpsub(lap_ij, concat(acc_1, undef_v8float()), 0,
+                       0x76543210); // flx_imj = lap_ij - lap_ijm;
+      ptr_out = (v8float *)out_flux1 + i;
+      *ptr_out = flux_sub;
+      //
+
+      acc_0 = fpmul(data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); /// // l ; R1 is already loaded
+      acc_0 = fpmsc(acc_0, data_buf2, 3, 0x76543210, coeffs, 0,
+                    0x00000000); ///   // l, 4*h
+
+      // r1 = ptr_in+1 * COL/8+i ;
+      row1_ptr = ((v8float *)(row1)) + i;
+      data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));
+
+      acc_0 = fpmac(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  lap_ijp // l, 4*h, g
+      acc_0 = fpmac(acc_0, data_buf2, 4, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  l, 4*h, g, i
+
+      acc_0 = fpmac(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  // l, 4*h, g, i, d
+
+      flux_sub = fpsub(acc_0, concat(lap_ij, undef_v8float()), 0, 0x76543210);
+      ptr_out = (v8float *)out_flux2 + i;
+      *ptr_out = flux_sub;
+
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+      acc_0 = fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+
+      // r2 = ptr_in + 0*COL/8 + i ;
+      row0_ptr = ((v8float *)(row0)) + i;
+      // r2 = ptr_in + 0*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm
+      data_buf2 = upd_w(data_buf2, 0, *row0_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row0_ptr);
+
+      acc_1 = fpmsc(acc_1, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, 4*c
+      acc_1 = fpmac(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b
+      acc_1 = fpmac(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); /// // g, 4*c, b, a
+
+      // r2 = ptr_in + 4*COL/8 + i ;
+      row4_ptr = ((v8float *)(row4)) + i;
+      // r2 = ptr_in + 4*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm
+      data_buf2 = upd_w(data_buf2, 0, *row4_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row4_ptr);
+      //////// **************************LAP_ipj for fly_ij since r2=R4********
+      acc_1 = fpmac(acc_1, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a, d
+      acc_0 = fpmac(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///   // g, m
+
+      // //Calculates lap_imj
+      // lap_0=srs(acc_1,0);
+
+      flux_sub = fpsub(lap_ij, concat(acc_1, undef_v8float()), 0, 0x76543210);
+      ptr_out = (v8float *)out_flux3 + i;
+      *ptr_out = flux_sub;
+
+      // r1 = ptr_in + 3*COL/8 + i ;
+      row3_ptr = ((v8float *)(row3)) + i;
+      // r1 = ptr_in + 3*COL/8 + i + aor*COL/8; // load for LAP_ijp for fly_ij
+      // data_buf1=*r1++;
+      data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+
+      acc_0 = fpmsc(acc_0, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); ///  //g, m , k * 4
+
+      // v16int32 flx_out3=sub16(flx_out2,out_flx_inter3); //adds fly_ij -
+      // fly_ijm - flx_imj
+
+      acc_0 = fpmac(acc_0, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //g, m , k * 4, j
+
+      // LOAD DATA FOR NEXT ITERATION
+      //  r2 = ptr_in + 1*COL/8 + i + 1 ;
+      row1_ptr = ((v8float *)(row1)) + i + 1;
+      data_buf2 = upd_w(data_buf2, 0, *(row1_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row1_ptr));
+      acc_0 = fpmac(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///   //g, m , k * 4, j, l
+
+      //  flx_ij = lap_ipj - lap_ij
+      flux_sub = fpsub(acc_0, concat(lap_ij, undef_v8float()), 0, 0x76543210);
+      ptr_out = (v8float *)out_flux4 + i;
+      *ptr_out = flux_sub, 0;
+
+      // LOAD DATA FOR NEXT ITERATION
+      row3_ptr = ((v8float *)(row3)) + i + 1;
+      data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
+
+      // }
     }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/include.h b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/include.h
index 6ab94ff..e74fe84 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/include.h
+++ b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/include.h
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -11,43 +11,43 @@
 // #define  MULTI_4x4
 // #include <adf.h>
 #include <stdint.h>
-#define GRIDROW     256
-#define GRIDCOL     256
-#define GRIDDEPTH   1
-#define TOTAL_INPUT GRIDROW*GRIDCOL*GRIDDEPTH
-
-#define ROW			256
-#define COL			256
-#define TILE_SIZE  COL
+#define GRIDROW 256
+#define GRIDCOL 256
+#define GRIDDEPTH 1
+#define TOTAL_INPUT GRIDROW *GRIDCOL *GRIDDEPTH
 
-#define WMARGIN     256       // Margin before the frame
+#define ROW 256
+#define COL 256
+#define TILE_SIZE COL
 
+#define WMARGIN 256 // Margin before the frame
 
-#define NBYTES		4		// datatype byte-width
+#define NBYTES 4 // datatype byte-width
 
-#define AVAIL_CORES 25*25
+#define AVAIL_CORES 25 * 25
 
-#define CORE_REQUIRED TOTAL_INPUT/TILE_SIZE
+#define CORE_REQUIRED TOTAL_INPUT / TILE_SIZE
 
 #ifdef MULTI_CORE
-    #ifdef  MULTI_2x2
-        #define HW_ROW 2
-        #define HW_COL 2
-    #else 
-        #define HW_ROW 4
-        #define HW_COL 4
-    #endif
-
-    #define USED_CORE HW_ROW*HW_COL
-    #define NITER    TOTAL_INPUT/(USED_CORE*TILE_SIZE)   // Number of iteration
+#ifdef MULTI_2x2
+#define HW_ROW 2
+#define HW_COL 2
+#else
+#define HW_ROW 4
+#define HW_COL 4
+#endif
+
+#define USED_CORE HW_ROW *HW_COL
+#define NITER TOTAL_INPUT / (USED_CORE * TILE_SIZE) // Number of iteration
 #else
 
-#define NITER    TOTAL_INPUT/(TILE_SIZE)    // Number of iteration
+#define NITER TOTAL_INPUT / (TILE_SIZE) // Number of iteration
 #endif
 
 #ifdef WITH_MARGIN
-#define INPUT_FILE "./data/TestInputS.txt"    // Input file name and location
+#define INPUT_FILE "./data/TestInputS.txt" // Input file name and location
 #else
-#define INPUT_FILE "./data/dataset_256x256x64.txt"    // Input file name and location
+#define INPUT_FILE                                                             \
+  "./data/dataset_256x256x64.txt" // Input file name and location
 #endif
-#define OUTPUT_FILE "./data/TestOutputS.txt"    // Output file name and location
\ No newline at end of file
+#define OUTPUT_FILE "./data/TestOutputS.txt" // Output file name and location
\ No newline at end of file
diff --git a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/test.cpp b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/test.cpp
index 3fd3862..3ee2580 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/test.cpp
+++ b/reference_designs/horizontal_diffusion/HDIFF_dual_AIE_objectFIFO_ping_pong/test.cpp
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -13,9 +13,9 @@
 #include <stdlib.h>
 #include <sys/mman.h>
 #include <thread>
+#include <time.h>
 #include <unistd.h>
 #include <xaiengine.h>
-#include <time.h>  
 
 #define HIGH_ADDR(addr) ((addr & 0xffffffff00000000) >> 32)
 #define LOW_ADDR(addr) (addr & 0x00000000ffffffff)
@@ -25,7 +25,7 @@
 
 int main(int argc, char *argv[]) {
   printf("test start.\n");
-  clock_t t; 
+  clock_t t;
 
   aie_libxaie_ctx_t *_xaie = mlir_aie_init_libxaie();
   mlir_aie_init_device(_xaie);
@@ -38,7 +38,7 @@ int main(int argc, char *argv[]) {
   mlir_aie_clear_tile_memory(_xaie, 7, 3);
   mlir_aie_clear_tile_memory(_xaie, 7, 2);
   mlir_aie_clear_tile_memory(_xaie, 7, 1);
-//   mlir_aie_clear_tile_memory(_xaie, 6, 4);
+  //   mlir_aie_clear_tile_memory(_xaie, 6, 4);
   mlir_aie_configure_cores(_xaie);
 
   usleep(sleep_u);
@@ -48,13 +48,13 @@ int main(int argc, char *argv[]) {
 
   mlir_aie_acquire_lock(_xaie, 7, 1, 14, 0, 0); // for timing
   // When lock 14 is acquired, we broadcast event 2 from tile t73
-  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(7,1), 
-                        XAIE_MEM_MOD, 2,
-                        XAIE_EVENT_LOCK_14_ACQ_MEM); 
-  // we use broadcast event 2 at tile t74 to start the timer, and the local event lock 14 acquire to stop the timer
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(7, 1), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  // we use broadcast event 2 at tile t74 to start the timer, and the local
+  // event lock 14 acquire to stop the timer
   EventMonitor pc0(_xaie, 7, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
-                 XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
-                 XAIE_MEM_MOD);
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
   pc0.set();
 
   usleep(sleep_u);
@@ -67,38 +67,39 @@ int main(int argc, char *argv[]) {
 #define DMA_COUNT 1536
   int *ddr_ptr_in = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT);
   int *ddr_ptr_out = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT);
-//   int *mem_ptr2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT);
-//   int *mem_ptr3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT);
-//   int *mem_ptr4 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT);
-//   int *mem_ptr5 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT);
-//   int *mem_ptr6 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT);
-//   int *mem_ptr7 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT);
+  //   int *mem_ptr2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT);
+  //   int *mem_ptr3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT);
+  //   int *mem_ptr4 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT);
+  //   int *mem_ptr5 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT);
+  //   int *mem_ptr6 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT);
+  //   int *mem_ptr7 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT);
 
   // initialize the external buffers
   for (int i = 0; i < DMA_COUNT; i++) {
-    *(ddr_ptr_in + i) = i;  // input
+    *(ddr_ptr_in + i) = i; // input
     *(ddr_ptr_out + i) = 0;
   }
 
   mlir_aie_sync_mem_dev(_xaie, 0); // only used in libaiev2
   mlir_aie_sync_mem_dev(_xaie, 1); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 2); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 3); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 4); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 5); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 6); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 7); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 2); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 3); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 4); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 5); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 6); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 7); // only used in libaiev2
 
 #ifdef LIBXAIENGINEV2
-  mlir_aie_external_set_addr_ddr_test_buffer_in0((u64)ddr_ptr_in); // external set address
+  mlir_aie_external_set_addr_ddr_test_buffer_in0(
+      (u64)ddr_ptr_in); // external set address
   mlir_aie_external_set_addr_ddr_test_buffer_out((u64)ddr_ptr_out);
-//   mlir_aie_external_set_addr_RHS_tile0((u64)mem_ptr2);
-//   mlir_aie_external_set_addr_RHS_tile1((u64)mem_ptr3);
-//   mlir_aie_external_set_addr_RHS_tile2((u64)mem_ptr4);
-//   mlir_aie_external_set_addr_RHS_tile3((u64)mem_ptr5);
-//   mlir_aie_external_set_addr_Out_tile0((u64)mem_ptr6);
-//   mlir_aie_external_set_addr_Out_tile1((u64)mem_ptr7);
-//   mlir_aie_configure_shimdma_60(_xaie);
+  //   mlir_aie_external_set_addr_RHS_tile0((u64)mem_ptr2);
+  //   mlir_aie_external_set_addr_RHS_tile1((u64)mem_ptr3);
+  //   mlir_aie_external_set_addr_RHS_tile2((u64)mem_ptr4);
+  //   mlir_aie_external_set_addr_RHS_tile3((u64)mem_ptr5);
+  //   mlir_aie_external_set_addr_Out_tile0((u64)mem_ptr6);
+  //   mlir_aie_external_set_addr_Out_tile1((u64)mem_ptr7);
+  //   mlir_aie_configure_shimdma_60(_xaie);
   mlir_aie_configure_shimdma_70(_xaie);
 //   mlir_aie_configure_shimdma_100(_xaie);
 #endif
@@ -106,22 +107,18 @@ int main(int argc, char *argv[]) {
   printf("before core start\n");
   mlir_aie_print_tile_status(_xaie, 7, 3);
 
-  
-  
-
-
   printf("Release lock for accessing DDR.\n");
   mlir_aie_release_of_0_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_5_lock_0(_xaie, 0, 0);
 
   printf("Start cores\n");
   ///// --- start counter-----
-  t = clock(); 
+  t = clock();
   mlir_aie_start_cores(_xaie);
   mlir_aie_release_lock(_xaie, 7, 1, 14, 0, 0); // for timing
-  t = clock() - t; 
+  t = clock() - t;
 
-  printf ("It took %ld clicks (%f seconds).\n",t,((float)t)/CLOCKS_PER_SEC);
+  printf("It took %ld clicks (%f seconds).\n", t, ((float)t) / CLOCKS_PER_SEC);
 
   usleep(sleep_u);
   printf("after core start\n");
@@ -129,15 +126,15 @@ int main(int argc, char *argv[]) {
 
   usleep(sleep_u);
 
+  //   mlir_aie_acquire_of_17_lock_0(_xaie, 1, 0);
+  //   mlir_aie_acquire_of_15_lock_0(_xaie, 1, 0);
 
-//   mlir_aie_acquire_of_17_lock_0(_xaie, 1, 0);
-//   mlir_aie_acquire_of_15_lock_0(_xaie, 1, 0);
- 
-  mlir_aie_sync_mem_cpu(_xaie, 1); // only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        1); // only used in libaiev2 //sync up with output
   ///// --- end counter-----
-  for (int i =0; i < 256; i ++ ){
-        printf("Location %d:  %d\n", i, ddr_ptr_out[i]);
-    }
+  for (int i = 0; i < 256; i++) {
+    printf("Location %d:  %d\n", i, ddr_ptr_out[i]);
+  }
 
   int res = 0;
   if (!errors) {
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/chess_main.cc b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/chess_main.cc
index f1d5093..a20d52a 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/chess_main.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/chess_main.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/hdiff.cc b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/hdiff.cc
index c8be400..ef0366d 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/hdiff.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/hdiff.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -64,10 +64,10 @@ void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict
           
             acc_0=lmac8   (acc_0,data_buf1,2,0x76543210,coeffs_rest,    0,0x00000000);    //c,k
             acc_1=lmac8   (acc_1,data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);    //b,j
-          
+
             // r2 = ptr_in+2 * COL/8+i ;
             // r1=row2_ptr+i;
-            row2_ptr=((v8int32 *) (row2))+i;
+            row2_ptr = ((v8int32 *)(row2)) + i;
             data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
             data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
 
@@ -98,13 +98,13 @@ void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict
             acc_0=lmsc8   (acc_0,data_buf2,3,0x76543210,coeffs,    0,0x00000000);  // l, 4*h
             
             //Calculate final fly_ijm
-            v16int32 out_flx_inter1=select16(flx_compare_imj,flux_sub,null_v16int32()); 
+            v16int32 out_flx_inter1=select16(flx_compare_imj,flux_sub,null_v16int32());
 
             // r1 = ptr_in+1 * COL/8+i ;
             // r1=row1_ptr+i;
-            row1_ptr=((v8int32 *) (row1))+i;
+            row1_ptr = ((v8int32 *)(row1)) + i;
             data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));    
+            data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));
 
             acc_0=lmac8  (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);  // l, 4*h, g
             acc_0=lmac8   (acc_0,data_buf2,4,0x76543210,coeffs_rest,    0,0x00000000); // l, 4*h, g, i 
@@ -133,31 +133,31 @@ void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict
             acc_1=lmul8    ( data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000); // g                     
             acc_0=lmul8   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);   // g
 
-            // r2 = ptr_in + 0*COL/8 + i ; 
+            // r2 = ptr_in + 0*COL/8 + i ;
             // r1=row0_ptr+i;
-            row0_ptr=((v8int32 *) (row0))+i;
+            row0_ptr = ((v8int32 *)(row0)) + i;
             data_buf2 = upd_w(data_buf2, 0, *(row0_ptr)++);
             data_buf2 = upd_w(data_buf2, 1, *(row0_ptr));
-                  
+
             acc_1=lmsc8    (acc_1, data_buf1,2,0x76543210,coeffs,    0,0x00000000);             // g, 4*c
             acc_1=lmac8    (acc_1, data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);        // g, 4*c, b
             acc_1=lmac8   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);          // g, 4*c, b, a
-          
-            // r2 = ptr_in + 4*COL/8 + i ; 
+
+            // r2 = ptr_in + 4*COL/8 + i ;
             // r1=row4_ptr+i;
-            row4_ptr=((v8int32 *) (row4))+i;
+            row4_ptr = ((v8int32 *)(row4)) + i;
             data_buf2 = upd_w(data_buf2, 0, *(row4_ptr)++);
             data_buf2 = upd_w(data_buf2, 1, *(row4_ptr));
 
             acc_1=lmac8    ( acc_1,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b, a, d               
             acc_0=lmac8   (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);         // g, m
-            
-            // r2 = ptr_in + 2*COL/8 + i ; 
+
+            // r2 = ptr_in + 2*COL/8 + i ;
             // r1=row2_ptr+i;
-            row2_ptr=((v8int32 *) (row2))+i;
+            row2_ptr = ((v8int32 *)(row2)) + i;
             data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
             data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
-            
+
             //Calculates lap_imj
             lap_0=srs(acc_1,0); 
 
@@ -173,7 +173,7 @@ void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict
 
             // r1 = ptr_in + 3*COL/8 + i ;
             // r1=row3_ptr+i;
-            row3_ptr=((v8int32 *) (row3))+i;
+            row3_ptr = ((v8int32 *)(row3)) + i;
             data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
             data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
 
@@ -188,15 +188,15 @@ void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict
             flux_sub = sub16(concat(srs(acc_0,0),undef_v8int32()), 0, 0x76543210, 0xFEDCBA98, concat(lap_ij,undef_v8int32()),   0,  0x76543210, 0xFEDCBA98 ); 
 
             //below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
-            acc_1=lmul8   (data_buf1,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);      //  (lap_ipj - lap_ij) * k       
-            
-            //LOAD DATA FOR NEXT ITERATION
-            // r1 = ptr_in + 3*COL/8 + i + 1 ;
-            // r1=row3_ptr+i+1;
-            row3_ptr=((v8int32 *) (row3))+i+1;
+            acc_1=lmul8   (data_buf1,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);      //  (lap_ipj - lap_ij) * k
+
+            // LOAD DATA FOR NEXT ITERATION
+            //  r1 = ptr_in + 3*COL/8 + i + 1 ;
+            //  r1=row3_ptr+i+1;
+            row3_ptr = ((v8int32 *)(row3)) + i + 1;
             data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
             data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
-            
+
             acc_1=lmsc8   (acc_1,data_buf2,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);    //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g   
 
             // final flx_ij (comparison > 0 )
@@ -206,12 +206,12 @@ void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict
             v16int32 flx_out4=add16(flx_out3,out_flx_inter4); //adds fly_ij - fly_ijm - flx_imj + flx_ij
 
             v8acc80 final_output = lmul8  (flx_out4, 0, 0x76543210, flux_out_coeff,    0,0x00000000);  // Multiply by -7s
-            final_output=lmac8(final_output, data_buf2,  2, 0x76543210,concat(coeffs1, undef_v8int32()), 0 , 0x76543210); 
+            final_output=lmac8(final_output, data_buf2,  2, 0x76543210,concat(coeffs1, undef_v8int32()), 0 , 0x76543210);
 
-            //LOAD DATA FOR NEXT ITERATION
-            // r2 = ptr_in + 1*COL/8 + i + 1 ;
-            // r1=row1_ptr+i+1;
-            row1_ptr=((v8int32 *) (row1))+i+1;
+            // LOAD DATA FOR NEXT ITERATION
+            //  r2 = ptr_in + 1*COL/8 + i + 1 ;
+            //  r1=row1_ptr+i+1;
+            row1_ptr = ((v8int32 *)(row1)) + i + 1;
             data_buf2 = upd_w(data_buf2, 0, *(row1_ptr)++);
             data_buf2 = upd_w(data_buf2, 1, *(row1_ptr));
 
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/hdiff.h b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/hdiff.h
index 77ff260..c971c95 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/hdiff.h
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/hdiff.h
@@ -1,13 +1,13 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
 extern "C" {
 void vec_hdiff(int32_t* restrict in0,int32_t* restrict in1,int32_t* restrict in2,int32_t* restrict in3,int32_t* restrict in4, int32_t* restrict out);
-void vec_hdiff_fp32(float* restrict row0, float* restrict row1,float* restrict row2,float* restrict row3,float* restrict row4, float* restrict out);
-
-
+void vec_hdiff_fp32(float *restrict row0, float *restrict row1,
+                    float *restrict row2, float *restrict row3,
+                    float *restrict row4, float *restrict out);
 }
 
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/hdiff_fp32.cc b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/hdiff_fp32.cc
index 7ad8ee9..545d9cc 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/hdiff_fp32.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/hdiff_fp32.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -10,221 +10,280 @@
 #define kernel_load 14
 // typedef int int32;
 
+// align to 16 bytes boundary, equivalent to "alignas(v4int32)"
+void vec_hdiff_fp32(float *restrict row0, float *restrict row1,
+                    float *restrict row2, float *restrict row3,
+                    float *restrict row4, float *restrict out) {
+
+  // const float *restrict w = weights;
+  alignas(32) float weights[8] = {-4, -4, -4, -4, -4, -4, -4, -4};
+  alignas(32) float weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) float weights_rest[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
+  alignas(32) float flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8float coeffs = *(v8float *)weights;           //  8 x int32 = 256b W vector
+  v8float coeffs1 = *(v8float *)weights1;         //  8 x int32 = 256b W vector
+  v8float coeffs_rest = *(v8float *)weights_rest; //  8 x int32 = 256b W vector
+  v8float flux_out_coeff = *(v8float *)flux_out;
+
+  // v8float * restrict ptr_in = (v8float *) in;
+  v8float *ptr_out = (v8float *)out;
+  v8float *restrict row0_ptr = (v8float *)row0;
+  v8float *restrict row1_ptr = (v8float *)row1;
+  v8float *restrict row2_ptr = (v8float *)row2;
+  v8float *restrict row3_ptr = (v8float *)row3;
+  v8float *restrict row4_ptr = (v8float *)row4;
+  v8float *restrict r1;
+  // v8float * restrict r2=ptr_in+1*COL/8;
+
+  v16float data_buf1 = null_v16float();
+  v16float data_buf2 = null_v16float();
+
+  v8float acc_0 = null_v8float();
+  v8float acc_1 = null_v8float();
+
+  //  v8acc80 acc_1=null_v8acc80();
+  v8float lap_ij = null_v8float(); //  8 x int32 = 256b W vector
+  v8float lap_0 = null_v8float();  //  8 x int32 = 256b W vector
+
+  data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+  data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+
+      v8float flux_sub;
+
+      // buf_2=R1, and buf_1=R3
+      /////////
+      ///**************************LAP_ij**************************************
+      lap_ij =
+          fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); ///  //c
+      /////////
+      ///**************************LAP_ijm**************************************
+      acc_1 = fpmul(data_buf2, 1, 0x76543210, coeffs_rest, 0, 0x00000000); // b
+
+      /////////
+      ///**************************LAP_ij**************************************
+      lap_ij = fpmac(lap_ij, data_buf1, 2, 0x76543210, coeffs_rest, 0,
+                     0x00000000); ///  //c,k
+      /////////
+      ///**************************LAP_imj**************************************
+      acc_1 = fpmac(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //b,j
+
+      row2_ptr = ((v8float *)(row2)) + i;
+
+      data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+
+      /////////
+      ///**************************LAP_ij**************************************
+      lap_ij = fpmac(lap_ij, data_buf2, 1, 0x76543210, coeffs_rest, 0,
+                     0x00000000); ///  //c,k,f
+      lap_ij = fpmsc(lap_ij, data_buf2, 2, 0x76543210, coeffs, 0,
+                     0x00000000); ///  //c,k,f,4*g
+      lap_ij = fpmac(
+          lap_ij, data_buf2, 3, 0x76543210, coeffs_rest, 0,
+          0x00000000); ///  c,k,f,4*g,h
+                       /////////
+                       ///**************************LAP_ijm**************************************
+      acc_1 = fpmac(acc_1, data_buf2, 0, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //b,j,e
+      acc_1 = fpmsc(acc_1, data_buf2, 1, 0x76543210, coeffs, 0,
+                    0x00000000); ///         //b,j,e,4*f
+      acc_1 = fpmac(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///     //b,j,e,4*f,g
+
+      // Calculate  lap_ij - lap_ijm
+      flux_sub = fpsub(lap_ij, concat(acc_1, undef_v8float()), 0,
+                       0x76543210); // flx_imj = lap_ij - lap_ijm;
+
+      //*****************FLUX //below reuisng acc_1 for flux calculation
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); ///  (lap_ij - lap_ijm)*g
+      acc_1 = fpmsc(acc_1, data_buf2, 1, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
+
+      // compare > 0
+      unsigned int flx_compare_imj =
+          fpge(acc_1, null_v16float(), 0,
+               0x76543210); /// flx_ijm * (test_in[d][c][r] -
+                            /// test_in[d][c][r-1]) > 0 ? 0 :
+
+      // ///////// **************************lap_ipj
+      // flx_ij**************************************
+      acc_0 = fpmul(data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); /// // l ; R1 is already loaded
+      // ///////// **************************lap_ipj
+      // flx_ij**************************************
+      acc_0 = fpmsc(acc_0, data_buf2, 3, 0x76543210, coeffs, 0,
+                    0x00000000); ///   // l, 4*h
+
+      // Calculate final fly_ijm
+      v16float out_flx_inter1 = fpselect16(
+          flx_compare_imj, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      // r1 = ptr_in+1 * COL/8+i + aor*COL/8;
+      row1_ptr = ((v8float *)(row1)) + i;
+      // data_buf1=*r1++;
+      data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
+
+      acc_0 = fpmac(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  lap_ijp // l, 4*h, g
+      acc_0 = fpmac(acc_0, data_buf2, 4, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  l, 4*h, g, i
+      v8float flx_out1 =
+          fpadd(null_v8float(), out_flx_inter1, 0, 0x76543210); // still fly_ijm
+
+      acc_0 = fpmac(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  // l, 4*h, g, i, d
+
+      // Calculates lap_ijp - lap_ij
+      flux_sub = fpsub(acc_0, concat(lap_ij, undef_v8float()), 0, 0x76543210);
+
+      acc_1 = fpmul(data_buf2, 3, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ijp - lap_ij) * h
+      acc_1 = fpmsc(
+          acc_1, data_buf2, 2, 0x76543210, flux_sub, 0,
+          0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g
+
+      // Calculates final fly_ij (comparison > 0)
+      unsigned int flx_compare_ij = fpge(acc_1, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter2 = fpselect16(
+          flx_compare_ij, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      // fly_ijm -fly_ij
+      v8float flx_out2 = fpsub(flx_out1, out_flx_inter2, 0, 0x76543210);
+      // NOTE: fbsub does not support v16-v8 so instead of calculating fly_ij -
+      // fly_ijm - flx_imj + flx_ij
+      //               we calculate -(-fly_ij + fly_ijm + flx_imj - flx_ij)
+      //  Therefore, flux coeff is positive as well.
+
+      // //***********************************************************************STARTING
+      // X
+      // FLUX*****************************************************************************************************************************************************
+      //            //////// **************************LAP_imj sincer2=R2 are
+      //            already loaded********
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+
+      //////// **************************LAP_ipj for fly_ij sincer2=R2 are
+      ///already loaded********
+      acc_0 = fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+
+      row0_ptr = ((v8float *)(row0)) + i;
+      // r2 = ptr_in + 0*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm
+      data_buf2 = upd_w(data_buf2, 0, *row0_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row0_ptr);
+
+      // ///////// **************************LAP_imj since R1=buff 1
+      // ************************************
+
+      acc_1 = fpmsc(acc_1, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, 4*c
+      acc_1 = fpmac(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b
+      acc_1 = fpmac(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); /// // g, 4*c, b, a
+
+      row4_ptr = ((v8float *)(row4)) + i;
+      // r2 = ptr_in + 4*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm
+      data_buf2 = upd_w(data_buf2, 0, *row4_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row4_ptr);
+      //////// **************************LAP_ipj for fly_ij since r2=R4********
+      acc_1 = fpmac(acc_1, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a, d
+      acc_0 = fpmac(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///   // g, m
+
+      row2_ptr = ((v8float *)(row2)) + i;
+      // r2 = ptr_in + 2*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm
+      data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+
+      // flx_imj = lap_ij - lap_imj
+      flux_sub = fpsub(lap_ij, concat(acc_1, undef_v8float()), 0, 0x76543210);
+
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); ///   (lap_ij - lap_imj) * g
+      acc_1 = fpmsc(
+          acc_1, data_buf1, 2, 0x76543210, flux_sub, 0,
+          0x00000000); ///    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c
+
+      // Calculates final flx_imj (comparison > 0)
+      unsigned int fly_compare_ijm =
+          fpge(acc_1, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter3 = fpselect16(
+          fly_compare_ijm, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      row3_ptr = ((v8float *)(row3)) + i;
+      // r1 = ptr_in + 3*COL/8 + i + aor*COL/8; // load for LAP_ijp for fly_ij
+      // data_buf1=*r1++;
+      data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+      ////// **************************since r1=R1********
+      acc_0 = fpmsc(acc_0, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); ///  //g, m , k * 4
+
+      v8float flx_out3 = fpadd(flx_out2, out_flx_inter3, 0,
+                               0x76543210); // adds fly_ijm -fly_ij + flx_imj
+
+      acc_0 = fpmac(acc_0, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //g, m , k * 4, j
+      acc_0 = fpmac(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///   //g, m , k * 4, j, l
+      // lap_0=srs(acc_0,0); //LAP_ijp
+      ///////// **************************fly_ij
+      ///*************************************
+      //  flx_ij = lap_ipj - lap_ij
+      flux_sub = fpsub(acc_0, concat(lap_ij, undef_v8float()), 0, 0x76543210);
+
+      // below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
+      acc_1 = fpmul(data_buf1, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); //  (lap_ipj - lap_ij) * k
+
+      // LOAD DATA FOR NEXT ITERATION
+      row3_ptr = ((v8float *)(row3)) + i + 1;
+      // r1 = ptr_in + 3*COL/8 + i + 1 + aor*COL/8;
+      // data_buf1=*r1++;
+      data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+
+      acc_1 =
+          fpmsc(acc_1, data_buf2, 2, 0x76543210, flux_sub, 0,
+                0x00000000); //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g
+
+      // final flx_ij (comparison > 0 )
+      unsigned int fly_compare_ij = fpge(acc_1, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter4 = fpselect16(
+          fly_compare_ij, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      v8float flx_out4 =
+          fpsub(flx_out3, out_flx_inter4, 0,
+                0x76543210); // adds  fly_ijm -fly_ij + flx_imj -flx_ij
 
-//align to 16 bytes boundary, equivalent to "alignas(v4int32)"
-void vec_hdiff_fp32(float* restrict row0, float* restrict row1,float* restrict row2,float* restrict row3,float* restrict row4, float* restrict out)
-{
-
- // const float *restrict w = weights;
-    alignas(32) float weights[8] = {-4,-4,-4,-4,-4,-4,-4,-4};
-    alignas(32) float weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) float weights_rest[8] = {-1,-1,-1,-1,-1,-1,-1,-1};
-    alignas(32) float flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8float coeffs         = *(v8float*) weights;  //  8 x int32 = 256b W vector
-    v8float coeffs1        = *(v8float*) weights1;  //  8 x int32 = 256b W vector
-    v8float coeffs_rest    = *(v8float*) weights_rest;  //  8 x int32 = 256b W vector
-    v8float flux_out_coeff = *(v8float*) flux_out;
-
-    // v8float * restrict ptr_in = (v8float *) in;
-    v8float * ptr_out = (v8float *) out;
-    v8float * restrict row0_ptr=(v8float *)row0;
-    v8float * restrict row1_ptr=(v8float *)row1;
-    v8float * restrict row2_ptr=(v8float *)row2;
-    v8float * restrict row3_ptr=(v8float *)row3;
-    v8float * restrict row4_ptr=(v8float *)row4;
-    v8float * restrict r1;
-    // v8float * restrict r2=ptr_in+1*COL/8;
-
-    v16float   data_buf1=null_v16float();
-    v16float  data_buf2=null_v16float();
-    
-    v8float acc_0 = null_v8float();
-    v8float acc_1 = null_v8float();
-
-    //  v8acc80 acc_1=null_v8acc80();        
-    v8float lap_ij = null_v8float();      //  8 x int32 = 256b W vector
-    v8float lap_0  = null_v8float();      //  8 x int32 = 256b W vector
-
-
-
-        data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-        data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
-    
-        for (unsigned i = 0; i < COL/8; i++)
-            chess_prepare_for_pipelining
-                    chess_loop_range(1,)
-        {   
-           
-                v8float flux_sub;
-                               
-                // buf_2=R1, and buf_1=R3
-                ///////// **************************LAP_ij**************************************
-                lap_ij=fpmul (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///  //c      
-                ///////// **************************LAP_ijm**************************************
-                acc_1=fpmul(data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);        //b
-            
-                    ///////// **************************LAP_ij**************************************
-                lap_ij=fpmac   (lap_ij,data_buf1,2,0x76543210,coeffs_rest,    0,0x00000000);///  //c,k 
-                ///////// **************************LAP_imj**************************************
-                acc_1=fpmac   (acc_1,data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);///  //b,j
-                
-
-                row2_ptr=((v8float *) (row2))+i;
-   
-                data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
-                data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-      
-                ///////// **************************LAP_ij**************************************
-                lap_ij=fpmac   (lap_ij,data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);///  //c,k,f
-                lap_ij=fpmsc   (lap_ij,data_buf2,2,0x76543210,coeffs,    0,0x00000000);///  //c,k,f,4*g
-                lap_ij=fpmac   (lap_ij,data_buf2,3,0x76543210,coeffs_rest,    0,0x00000000);///  c,k,f,4*g,h
-                    ///////// **************************LAP_ijm**************************************               
-                acc_1=fpmac   (acc_1,data_buf2,0,0x76543210,coeffs_rest,    0,0x00000000);///  //b,j,e         
-                acc_1=fpmsc   (acc_1,data_buf2,1,0x76543210,coeffs,    0,0x00000000);///         //b,j,e,4*f   
-                acc_1=fpmac   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///     //b,j,e,4*f,g  
-               
-                //Calculate  lap_ij - lap_ijm
-                flux_sub = fpsub(lap_ij, concat(acc_1,undef_v8float()), 0, 0x76543210); // flx_imj = lap_ij - lap_ijm;
-                
-
-                 //*****************FLUX //below reuisng acc_1 for flux calculation
-                acc_1=fpmul   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);///  (lap_ij - lap_ijm)*g
-                acc_1=fpmsc   (acc_1,data_buf2,1,0x76543210,flux_sub,    0,0x00000000);// (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
-
-                // compare > 0
-                unsigned int flx_compare_imj=fpge (acc_1, null_v16float(), 0,0x76543210); /// flx_ijm * (test_in[d][c][r] - test_in[d][c][r-1]) > 0 ? 0 :
-                
-                    // ///////// **************************lap_ipj flx_ij**************************************
-                acc_0=fpmul   (data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);/// // l ; R1 is already loaded
-                // ///////// **************************lap_ipj flx_ij**************************************
-                acc_0=fpmsc   (acc_0,data_buf2,3,0x76543210,coeffs,    0,0x00000000);///   // l, 4*h
-
-               //Calculate final fly_ijm
-                v16float out_flx_inter1=fpselect16(flx_compare_imj,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-                  
-                // r1 = ptr_in+1 * COL/8+i + aor*COL/8;
-                row1_ptr=((v8float *) (row1))+i;
-                // data_buf1=*r1++;     
-                data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
-                data_buf1 = upd_w(data_buf1, 1, *row1_ptr); 
-
-                acc_0=fpmac  (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///  lap_ijp // l, 4*h, g
-                acc_0=fpmac   (acc_0,data_buf2,4,0x76543210,coeffs_rest,    0,0x00000000);///  l, 4*h, g, i   
-                v8float flx_out1=fpadd(null_v8float(),out_flx_inter1,0,0x76543210);   //still fly_ijm
-                
-               
-                acc_0=fpmac   (acc_0,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);///  // l, 4*h, g, i, d   
-                
-                //Calculates lap_ijp - lap_ij
-                flux_sub = fpsub(acc_0, concat(lap_ij,undef_v8float()), 0, 0x76543210); 
-               
-                acc_1=fpmul   (data_buf2,3,0x76543210,flux_sub,    0,0x00000000); // (lap_ijp - lap_ij) * h  
-                acc_1=fpmsc   (acc_1,data_buf2,2,0x76543210,flux_sub,    0,0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g                     
-
-                //Calculates final fly_ij (comparison > 0)
-                unsigned int flx_compare_ij=fpge (acc_1, null_v16float(), 0,0x76543210); 
-                v16float out_flx_inter2=fpselect16(flx_compare_ij,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-                        
-                //fly_ijm -fly_ij
-                v8float flx_out2=fpsub(flx_out1,out_flx_inter2,0,0x76543210);
-                //NOTE: fbsub does not support v16-v8 so instead of calculating fly_ij - fly_ijm - flx_imj + flx_ij
-                //              we calculate -(-fly_ij + fly_ijm + flx_imj - flx_ij)
-                // Therefore, flux coeff is positive as well.
- 
-    // //***********************************************************************STARTING X FLUX*****************************************************************************************************************************************************
-            //            //////// **************************LAP_imj sincer2=R2 are already loaded********
-                acc_1=fpmul    ( data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);        // g  
-                        
-                //////// **************************LAP_ipj for fly_ij sincer2=R2 are already loaded********
-                acc_0=fpmul   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);// g   
-
-                row0_ptr=((v8float *) (row0))+i;
-                // r2 = ptr_in + 0*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm 
-                data_buf2 = upd_w(data_buf2, 0, *row0_ptr++);
-                data_buf2 = upd_w(data_buf2, 1, *row0_ptr);
-
-                    // ///////// **************************LAP_imj since R1=buff 1 ************************************
-        
-                acc_1=fpmsc    (acc_1, data_buf1,2,0x76543210,coeffs,    0,0x00000000);      // g, 4*c
-                acc_1=fpmac    (acc_1, data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b
-                acc_1=fpmac   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);/// // g, 4*c, b, a
-                
-                row4_ptr=((v8float *) (row4))+i;
-                // r2 = ptr_in + 4*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm 
-                data_buf2 = upd_w(data_buf2, 0, *row4_ptr++);
-                data_buf2 = upd_w(data_buf2, 1, *row4_ptr);
-                    //////// **************************LAP_ipj for fly_ij since r2=R4********
-                acc_1=fpmac    ( acc_1,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b, a, d  
-                acc_0=fpmac   (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///   // g, m
-                
-
-                row2_ptr=((v8float *) (row2))+i;
-                // r2 = ptr_in + 2*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm 
-                data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
-                data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-                
-                
-                //flx_imj = lap_ij - lap_imj
-                flux_sub = fpsub(lap_ij, concat(acc_1,undef_v8float()), 0, 0x76543210); 
-               
-                acc_1=fpmul   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);///   (lap_ij - lap_imj) * g
-                acc_1=fpmsc   (acc_1,data_buf1,2,0x76543210,flux_sub,    0,0x00000000);///    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c          
-                
-                //Calculates final flx_imj (comparison > 0)
-                unsigned int fly_compare_ijm=fpge (acc_1, null_v16float(), 0,0x76543210);
-                v16float out_flx_inter3=fpselect16(fly_compare_ijm,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-        
-                row3_ptr=((v8float *) (row3))+i;
-                // r1 = ptr_in + 3*COL/8 + i + aor*COL/8; // load for LAP_ijp for fly_ij
-                // data_buf1=*r1++;
-                data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-                data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-                ////// **************************since r1=R1********
-                acc_0=fpmsc   (acc_0,data_buf1,2,0x76543210,coeffs,    0,0x00000000);///  //g, m , k * 4
-
-                v8float flx_out3=fpadd(flx_out2,out_flx_inter3,0,0x76543210);     //adds fly_ijm -fly_ij + flx_imj 
-
-                acc_0=fpmac   (acc_0,data_buf1, 1,0x76543210,coeffs_rest,    0,0x00000000);///  //g, m , k * 4, j   
-                acc_0=fpmac   (acc_0,data_buf1, 3,0x76543210,coeffs_rest,    0,0x00000000);///   //g, m , k * 4, j, l   
-                // lap_0=srs(acc_0,0); //LAP_ijp
-                ///////// **************************fly_ij *************************************
-                //  flx_ij = lap_ipj - lap_ij
-                flux_sub = fpsub(acc_0, concat(lap_ij,undef_v8float()), 0, 0x76543210);
-           
-                //below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
-                acc_1=fpmul   (data_buf1,2,0x76543210,flux_sub,    0,0x00000000);//  (lap_ipj - lap_ij) * k       
-                
-                //LOAD DATA FOR NEXT ITERATION
-                row3_ptr=((v8float *) (row3))+i+1;
-                // r1 = ptr_in + 3*COL/8 + i + 1 + aor*COL/8;
-                // data_buf1=*r1++;
-                data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-                data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-                
-                acc_1=fpmsc   (acc_1,data_buf2,2,0x76543210,flux_sub,    0,0x00000000); //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g   
-
-                 // final flx_ij (comparison > 0 )
-                unsigned int fly_compare_ij=fpge (acc_1, null_v16float(), 0,0x76543210);
-                v16float out_flx_inter4=fpselect16(fly_compare_ij,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-                
-                v8float flx_out4=fpsub(flx_out3,out_flx_inter4,0,0x76543210); //adds  fly_ijm -fly_ij + flx_imj -flx_ij
-               
-                // r1=R1, r2=R0
-           
-                v8float   final_output=fpmul  (concat(flx_out4,null_v8float()),0,0x76543210,flux_out_coeff,    0,0x00000000);  // Multiply by +7s
-                final_output=fpmac(final_output,data_buf2,  2, 0x76543210,coeffs1, 0 , 0x76543210); 
-                //LOAD DATA FOR NEXT ITERATION
-                row1_ptr=((v8float *) (row1))+i+1;
-                // r2 = ptr_in + 1*COL/8 + i + 1 + aor*COL/8;
-                data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
-                data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
-                *ptr_out++ =  final_output; 
-                // *ptr_out++ =  srs(final_output,0);       
-                //  window_writeincr(out, final_output);   
-        // }
+      // r1=R1, r2=R0
 
+      v8float final_output =
+          fpmul(concat(flx_out4, null_v8float()), 0, 0x76543210, flux_out_coeff,
+                0, 0x00000000); // Multiply by +7s
+      final_output =
+          fpmac(final_output, data_buf2, 2, 0x76543210, coeffs1, 0, 0x76543210);
+      // LOAD DATA FOR NEXT ITERATION
+      row1_ptr = ((v8float *)(row1)) + i + 1;
+      // r2 = ptr_in + 1*COL/8 + i + 1 + aor*COL/8;
+      data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
+      *ptr_out++ = final_output;
+      // *ptr_out++ =  srs(final_output,0);
+      //  window_writeincr(out, final_output);
+      // }
     }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/include.h b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/include.h
index 6ab94ff..689c33b 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/include.h
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/include.h
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/test.cpp b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/test.cpp
index b578034..c2d06c0 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/test.cpp
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO/test.cpp
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -46,8 +46,8 @@ int main(int argc, char *argv[]) {
 
   mlir_aie_acquire_lock(_xaie, 7, 1, 14, 0, 0); // for timing
   EventMonitor pc0(_xaie, 7, 1, 0, XAIE_EVENT_LOCK_14_ACQ_MEM,
-                 XAIE_EVENT_LOCK_14_REL_MEM, XAIE_EVENT_NONE_MEM,
-                 XAIE_MEM_MOD);
+                   XAIE_EVENT_LOCK_14_REL_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
   pc0.set();
 
   usleep(sleep_u);
@@ -99,10 +99,6 @@ int main(int argc, char *argv[]) {
   printf("before core start\n");
   mlir_aie_print_tile_status(_xaie, 7, 1);
 
-  
-  
-
-
   printf("Release lock for accessing DDR.\n");
   mlir_aie_release_of_0_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_3_lock_0(_xaie, 0, 0);
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/chess_main.cc b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/chess_main.cc
index f1d5093..a20d52a 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/chess_main.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/chess_main.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/hdiff.cc b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/hdiff.cc
index 52e21bb..e2c73ca 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/hdiff.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/hdiff.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,7 +9,6 @@
 #define kernel_load 14
 // typedef int int32;
 
-
 //align to 16 bytes boundary, equivalent to "alignas(v4int32)"
 void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict row2,int32_t* restrict row3,int32_t* restrict row4, int32_t* restrict out)
 {
@@ -63,10 +62,10 @@ void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict
           
             acc_0=lmac8   (acc_0,data_buf1,2,0x76543210,coeffs_rest,    0,0x00000000);    //c,k
             acc_1=lmac8   (acc_1,data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);    //b,j
-          
+
             // r2 = ptr_in+2 * COL/8+i ;
             // r1=row2_ptr+i;
-            row2_ptr=((v8int32 *) (row2))+i;
+            row2_ptr = ((v8int32 *)(row2)) + i;
             data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
             data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
 
@@ -97,13 +96,13 @@ void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict
             acc_0=lmsc8   (acc_0,data_buf2,3,0x76543210,coeffs,    0,0x00000000);  // l, 4*h
             
             //Calculate final fly_ijm
-            v16int32 out_flx_inter1=select16(flx_compare_imj,flux_sub,null_v16int32()); 
+            v16int32 out_flx_inter1=select16(flx_compare_imj,flux_sub,null_v16int32());
 
             // r1 = ptr_in+1 * COL/8+i ;
             // r1=row1_ptr+i;
-            row1_ptr=((v8int32 *) (row1))+i;
+            row1_ptr = ((v8int32 *)(row1)) + i;
             data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));    
+            data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));
 
             acc_0=lmac8  (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);  // l, 4*h, g
             acc_0=lmac8   (acc_0,data_buf2,4,0x76543210,coeffs_rest,    0,0x00000000); // l, 4*h, g, i 
@@ -132,31 +131,31 @@ void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict
             acc_1=lmul8    ( data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000); // g                     
             acc_0=lmul8   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);   // g
 
-            // r2 = ptr_in + 0*COL/8 + i ; 
+            // r2 = ptr_in + 0*COL/8 + i ;
             // r1=row0_ptr+i;
-            row0_ptr=((v8int32 *) (row0))+i;
+            row0_ptr = ((v8int32 *)(row0)) + i;
             data_buf2 = upd_w(data_buf2, 0, *(row0_ptr)++);
             data_buf2 = upd_w(data_buf2, 1, *(row0_ptr));
-                  
+
             acc_1=lmsc8    (acc_1, data_buf1,2,0x76543210,coeffs,    0,0x00000000);             // g, 4*c
             acc_1=lmac8    (acc_1, data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);        // g, 4*c, b
             acc_1=lmac8   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);          // g, 4*c, b, a
-          
-            // r2 = ptr_in + 4*COL/8 + i ; 
+
+            // r2 = ptr_in + 4*COL/8 + i ;
             // r1=row4_ptr+i;
-            row4_ptr=((v8int32 *) (row4))+i;
+            row4_ptr = ((v8int32 *)(row4)) + i;
             data_buf2 = upd_w(data_buf2, 0, *(row4_ptr)++);
             data_buf2 = upd_w(data_buf2, 1, *(row4_ptr));
 
             acc_1=lmac8    ( acc_1,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b, a, d               
             acc_0=lmac8   (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);         // g, m
-            
-            // r2 = ptr_in + 2*COL/8 + i ; 
+
+            // r2 = ptr_in + 2*COL/8 + i ;
             // r1=row2_ptr+i;
-            row2_ptr=((v8int32 *) (row2))+i;
+            row2_ptr = ((v8int32 *)(row2)) + i;
             data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
             data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
-            
+
             //Calculates lap_imj
             lap_0=srs(acc_1,0); 
 
@@ -172,7 +171,7 @@ void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict
 
             // r1 = ptr_in + 3*COL/8 + i ;
             // r1=row3_ptr+i;
-            row3_ptr=((v8int32 *) (row3))+i;
+            row3_ptr = ((v8int32 *)(row3)) + i;
             data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
             data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
 
@@ -187,15 +186,15 @@ void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict
             flux_sub = sub16(concat(srs(acc_0,0),undef_v8int32()), 0, 0x76543210, 0xFEDCBA98, concat(lap_ij,undef_v8int32()),   0,  0x76543210, 0xFEDCBA98 ); 
 
             //below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
-            acc_1=lmul8   (data_buf1,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);      //  (lap_ipj - lap_ij) * k       
-            
-            //LOAD DATA FOR NEXT ITERATION
-            // r1 = ptr_in + 3*COL/8 + i + 1 ;
-            // r1=row3_ptr+i+1;
-            row3_ptr=((v8int32 *) (row3))+i+1;
+            acc_1=lmul8   (data_buf1,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);      //  (lap_ipj - lap_ij) * k
+
+            // LOAD DATA FOR NEXT ITERATION
+            //  r1 = ptr_in + 3*COL/8 + i + 1 ;
+            //  r1=row3_ptr+i+1;
+            row3_ptr = ((v8int32 *)(row3)) + i + 1;
             data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
             data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
-            
+
             acc_1=lmsc8   (acc_1,data_buf2,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);    //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g   
 
             // final flx_ij (comparison > 0 )
@@ -205,12 +204,12 @@ void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict
             v16int32 flx_out4=add16(flx_out3,out_flx_inter4); //adds fly_ij - fly_ijm - flx_imj + flx_ij
 
             v8acc80 final_output = lmul8  (flx_out4, 0, 0x76543210, flux_out_coeff,    0,0x00000000);  // Multiply by -7s
-            final_output=lmac8(final_output, data_buf2,  2, 0x76543210,concat(coeffs1, undef_v8int32()), 0 , 0x76543210); 
+            final_output=lmac8(final_output, data_buf2,  2, 0x76543210,concat(coeffs1, undef_v8int32()), 0 , 0x76543210);
 
-            //LOAD DATA FOR NEXT ITERATION
-            // r2 = ptr_in + 1*COL/8 + i + 1 ;
-            // r1=row1_ptr+i+1;
-            row1_ptr=((v8int32 *) (row1))+i+1;
+            // LOAD DATA FOR NEXT ITERATION
+            //  r2 = ptr_in + 1*COL/8 + i + 1 ;
+            //  r1=row1_ptr+i+1;
+            row1_ptr = ((v8int32 *)(row1)) + i + 1;
             data_buf2 = upd_w(data_buf2, 0, *(row1_ptr)++);
             data_buf2 = upd_w(data_buf2, 1, *(row1_ptr));
 
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/hdiff.h b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/hdiff.h
index 77ff260..c971c95 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/hdiff.h
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/hdiff.h
@@ -1,13 +1,13 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
 extern "C" {
 void vec_hdiff(int32_t* restrict in0,int32_t* restrict in1,int32_t* restrict in2,int32_t* restrict in3,int32_t* restrict in4, int32_t* restrict out);
-void vec_hdiff_fp32(float* restrict row0, float* restrict row1,float* restrict row2,float* restrict row3,float* restrict row4, float* restrict out);
-
-
+void vec_hdiff_fp32(float *restrict row0, float *restrict row1,
+                    float *restrict row2, float *restrict row3,
+                    float *restrict row4, float *restrict out);
 }
 
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/hdiff_fp32.cc b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/hdiff_fp32.cc
index 8d7f6fc..13c78b7 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/hdiff_fp32.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/hdiff_fp32.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,221 +9,280 @@
 #define kernel_load 14
 // typedef int int32;
 
+// align to 16 bytes boundary, equivalent to "alignas(v4int32)"
+void vec_hdiff_fp32(float *restrict row0, float *restrict row1,
+                    float *restrict row2, float *restrict row3,
+                    float *restrict row4, float *restrict out) {
+
+  // const float *restrict w = weights;
+  alignas(32) float weights[8] = {-4, -4, -4, -4, -4, -4, -4, -4};
+  alignas(32) float weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) float weights_rest[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
+  alignas(32) float flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8float coeffs = *(v8float *)weights;           //  8 x int32 = 256b W vector
+  v8float coeffs1 = *(v8float *)weights1;         //  8 x int32 = 256b W vector
+  v8float coeffs_rest = *(v8float *)weights_rest; //  8 x int32 = 256b W vector
+  v8float flux_out_coeff = *(v8float *)flux_out;
+
+  // v8float * restrict ptr_in = (v8float *) in;
+  v8float *ptr_out = (v8float *)out;
+  v8float *restrict row0_ptr = (v8float *)row0;
+  v8float *restrict row1_ptr = (v8float *)row1;
+  v8float *restrict row2_ptr = (v8float *)row2;
+  v8float *restrict row3_ptr = (v8float *)row3;
+  v8float *restrict row4_ptr = (v8float *)row4;
+  v8float *restrict r1;
+  // v8float * restrict r2=ptr_in+1*COL/8;
+
+  v16float data_buf1 = null_v16float();
+  v16float data_buf2 = null_v16float();
+
+  v8float acc_0 = null_v8float();
+  v8float acc_1 = null_v8float();
+
+  //  v8acc80 acc_1=null_v8acc80();
+  v8float lap_ij = null_v8float(); //  8 x int32 = 256b W vector
+  v8float lap_0 = null_v8float();  //  8 x int32 = 256b W vector
+
+  data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+  data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+
+      v8float flux_sub;
+
+      // buf_2=R1, and buf_1=R3
+      /////////
+      ///**************************LAP_ij**************************************
+      lap_ij =
+          fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); ///  //c
+      /////////
+      ///**************************LAP_ijm**************************************
+      acc_1 = fpmul(data_buf2, 1, 0x76543210, coeffs_rest, 0, 0x00000000); // b
+
+      /////////
+      ///**************************LAP_ij**************************************
+      lap_ij = fpmac(lap_ij, data_buf1, 2, 0x76543210, coeffs_rest, 0,
+                     0x00000000); ///  //c,k
+      /////////
+      ///**************************LAP_imj**************************************
+      acc_1 = fpmac(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //b,j
+
+      row2_ptr = ((v8float *)(row2)) + i;
+
+      data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+
+      /////////
+      ///**************************LAP_ij**************************************
+      lap_ij = fpmac(lap_ij, data_buf2, 1, 0x76543210, coeffs_rest, 0,
+                     0x00000000); ///  //c,k,f
+      lap_ij = fpmsc(lap_ij, data_buf2, 2, 0x76543210, coeffs, 0,
+                     0x00000000); ///  //c,k,f,4*g
+      lap_ij = fpmac(
+          lap_ij, data_buf2, 3, 0x76543210, coeffs_rest, 0,
+          0x00000000); ///  c,k,f,4*g,h
+                       /////////
+                       ///**************************LAP_ijm**************************************
+      acc_1 = fpmac(acc_1, data_buf2, 0, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //b,j,e
+      acc_1 = fpmsc(acc_1, data_buf2, 1, 0x76543210, coeffs, 0,
+                    0x00000000); ///         //b,j,e,4*f
+      acc_1 = fpmac(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///     //b,j,e,4*f,g
+
+      // Calculate  lap_ij - lap_ijm
+      flux_sub = fpsub(lap_ij, concat(acc_1, undef_v8float()), 0,
+                       0x76543210); // flx_imj = lap_ij - lap_ijm;
+
+      //*****************FLUX //below reuisng acc_1 for flux calculation
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); ///  (lap_ij - lap_ijm)*g
+      acc_1 = fpmsc(acc_1, data_buf2, 1, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
+
+      // compare > 0
+      unsigned int flx_compare_imj =
+          fpge(acc_1, null_v16float(), 0,
+               0x76543210); /// flx_ijm * (test_in[d][c][r] -
+                            /// test_in[d][c][r-1]) > 0 ? 0 :
+
+      // ///////// **************************lap_ipj
+      // flx_ij**************************************
+      acc_0 = fpmul(data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); /// // l ; R1 is already loaded
+      // ///////// **************************lap_ipj
+      // flx_ij**************************************
+      acc_0 = fpmsc(acc_0, data_buf2, 3, 0x76543210, coeffs, 0,
+                    0x00000000); ///   // l, 4*h
+
+      // Calculate final fly_ijm
+      v16float out_flx_inter1 = fpselect16(
+          flx_compare_imj, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      // r1 = ptr_in+1 * COL/8+i + aor*COL/8;
+      row1_ptr = ((v8float *)(row1)) + i;
+      // data_buf1=*r1++;
+      data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
+
+      acc_0 = fpmac(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  lap_ijp // l, 4*h, g
+      acc_0 = fpmac(acc_0, data_buf2, 4, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  l, 4*h, g, i
+      v8float flx_out1 =
+          fpadd(null_v8float(), out_flx_inter1, 0, 0x76543210); // still fly_ijm
+
+      acc_0 = fpmac(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  // l, 4*h, g, i, d
+
+      // Calculates lap_ijp - lap_ij
+      flux_sub = fpsub(acc_0, concat(lap_ij, undef_v8float()), 0, 0x76543210);
+
+      acc_1 = fpmul(data_buf2, 3, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ijp - lap_ij) * h
+      acc_1 = fpmsc(
+          acc_1, data_buf2, 2, 0x76543210, flux_sub, 0,
+          0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g
+
+      // Calculates final fly_ij (comparison > 0)
+      unsigned int flx_compare_ij = fpge(acc_1, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter2 = fpselect16(
+          flx_compare_ij, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      // fly_ijm -fly_ij
+      v8float flx_out2 = fpsub(flx_out1, out_flx_inter2, 0, 0x76543210);
+      // NOTE: fbsub does not support v16-v8 so instead of calculating fly_ij -
+      // fly_ijm - flx_imj + flx_ij
+      //               we calculate -(-fly_ij + fly_ijm + flx_imj - flx_ij)
+      //  Therefore, flux coeff is positive as well.
+
+      // //***********************************************************************STARTING
+      // X
+      // FLUX*****************************************************************************************************************************************************
+      //            //////// **************************LAP_imj sincer2=R2 are
+      //            already loaded********
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+
+      //////// **************************LAP_ipj for fly_ij sincer2=R2 are
+      ///already loaded********
+      acc_0 = fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+
+      row0_ptr = ((v8float *)(row0)) + i;
+      // r2 = ptr_in + 0*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm
+      data_buf2 = upd_w(data_buf2, 0, *row0_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row0_ptr);
+
+      // ///////// **************************LAP_imj since R1=buff 1
+      // ************************************
+
+      acc_1 = fpmsc(acc_1, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, 4*c
+      acc_1 = fpmac(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b
+      acc_1 = fpmac(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); /// // g, 4*c, b, a
+
+      row4_ptr = ((v8float *)(row4)) + i;
+      // r2 = ptr_in + 4*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm
+      data_buf2 = upd_w(data_buf2, 0, *row4_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row4_ptr);
+      //////// **************************LAP_ipj for fly_ij since r2=R4********
+      acc_1 = fpmac(acc_1, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a, d
+      acc_0 = fpmac(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///   // g, m
+
+      row2_ptr = ((v8float *)(row2)) + i;
+      // r2 = ptr_in + 2*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm
+      data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+
+      // flx_imj = lap_ij - lap_imj
+      flux_sub = fpsub(lap_ij, concat(acc_1, undef_v8float()), 0, 0x76543210);
+
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); ///   (lap_ij - lap_imj) * g
+      acc_1 = fpmsc(
+          acc_1, data_buf1, 2, 0x76543210, flux_sub, 0,
+          0x00000000); ///    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c
+
+      // Calculates final flx_imj (comparison > 0)
+      unsigned int fly_compare_ijm =
+          fpge(acc_1, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter3 = fpselect16(
+          fly_compare_ijm, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      row3_ptr = ((v8float *)(row3)) + i;
+      // r1 = ptr_in + 3*COL/8 + i + aor*COL/8; // load for LAP_ijp for fly_ij
+      // data_buf1=*r1++;
+      data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+      ////// **************************since r1=R1********
+      acc_0 = fpmsc(acc_0, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); ///  //g, m , k * 4
+
+      v8float flx_out3 = fpadd(flx_out2, out_flx_inter3, 0,
+                               0x76543210); // adds fly_ijm -fly_ij + flx_imj
+
+      acc_0 = fpmac(acc_0, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //g, m , k * 4, j
+      acc_0 = fpmac(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///   //g, m , k * 4, j, l
+      // lap_0=srs(acc_0,0); //LAP_ijp
+      ///////// **************************fly_ij
+      ///*************************************
+      //  flx_ij = lap_ipj - lap_ij
+      flux_sub = fpsub(acc_0, concat(lap_ij, undef_v8float()), 0, 0x76543210);
+
+      // below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
+      acc_1 = fpmul(data_buf1, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); //  (lap_ipj - lap_ij) * k
+
+      // LOAD DATA FOR NEXT ITERATION
+      row3_ptr = ((v8float *)(row3)) + i + 1;
+      // r1 = ptr_in + 3*COL/8 + i + 1 + aor*COL/8;
+      // data_buf1=*r1++;
+      data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+
+      acc_1 =
+          fpmsc(acc_1, data_buf2, 2, 0x76543210, flux_sub, 0,
+                0x00000000); //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g
+
+      // final flx_ij (comparison > 0 )
+      unsigned int fly_compare_ij = fpge(acc_1, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter4 = fpselect16(
+          fly_compare_ij, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      v8float flx_out4 =
+          fpsub(flx_out3, out_flx_inter4, 0,
+                0x76543210); // adds  fly_ijm -fly_ij + flx_imj -flx_ij
 
-//align to 16 bytes boundary, equivalent to "alignas(v4int32)"
-void vec_hdiff_fp32(float* restrict row0, float* restrict row1,float* restrict row2,float* restrict row3,float* restrict row4, float* restrict out)
-{
-
- // const float *restrict w = weights;
-    alignas(32) float weights[8] = {-4,-4,-4,-4,-4,-4,-4,-4};
-    alignas(32) float weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) float weights_rest[8] = {-1,-1,-1,-1,-1,-1,-1,-1};
-    alignas(32) float flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8float coeffs         = *(v8float*) weights;  //  8 x int32 = 256b W vector
-    v8float coeffs1        = *(v8float*) weights1;  //  8 x int32 = 256b W vector
-    v8float coeffs_rest    = *(v8float*) weights_rest;  //  8 x int32 = 256b W vector
-    v8float flux_out_coeff = *(v8float*) flux_out;
-
-    // v8float * restrict ptr_in = (v8float *) in;
-    v8float * ptr_out = (v8float *) out;
-    v8float * restrict row0_ptr=(v8float *)row0;
-    v8float * restrict row1_ptr=(v8float *)row1;
-    v8float * restrict row2_ptr=(v8float *)row2;
-    v8float * restrict row3_ptr=(v8float *)row3;
-    v8float * restrict row4_ptr=(v8float *)row4;
-    v8float * restrict r1;
-    // v8float * restrict r2=ptr_in+1*COL/8;
-
-    v16float   data_buf1=null_v16float();
-    v16float  data_buf2=null_v16float();
-    
-    v8float acc_0 = null_v8float();
-    v8float acc_1 = null_v8float();
-
-    //  v8acc80 acc_1=null_v8acc80();        
-    v8float lap_ij = null_v8float();      //  8 x int32 = 256b W vector
-    v8float lap_0  = null_v8float();      //  8 x int32 = 256b W vector
-
-
-
-        data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-        data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
-    
-        for (unsigned i = 0; i < COL/8; i++)
-            chess_prepare_for_pipelining
-                    chess_loop_range(1,)
-        {   
-           
-                v8float flux_sub;
-                               
-                // buf_2=R1, and buf_1=R3
-                ///////// **************************LAP_ij**************************************
-                lap_ij=fpmul (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///  //c      
-                ///////// **************************LAP_ijm**************************************
-                acc_1=fpmul(data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);        //b
-            
-                    ///////// **************************LAP_ij**************************************
-                lap_ij=fpmac   (lap_ij,data_buf1,2,0x76543210,coeffs_rest,    0,0x00000000);///  //c,k 
-                ///////// **************************LAP_imj**************************************
-                acc_1=fpmac   (acc_1,data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);///  //b,j
-                
-
-                row2_ptr=((v8float *) (row2))+i;
-   
-                data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
-                data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-      
-                ///////// **************************LAP_ij**************************************
-                lap_ij=fpmac   (lap_ij,data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);///  //c,k,f
-                lap_ij=fpmsc   (lap_ij,data_buf2,2,0x76543210,coeffs,    0,0x00000000);///  //c,k,f,4*g
-                lap_ij=fpmac   (lap_ij,data_buf2,3,0x76543210,coeffs_rest,    0,0x00000000);///  c,k,f,4*g,h
-                    ///////// **************************LAP_ijm**************************************               
-                acc_1=fpmac   (acc_1,data_buf2,0,0x76543210,coeffs_rest,    0,0x00000000);///  //b,j,e         
-                acc_1=fpmsc   (acc_1,data_buf2,1,0x76543210,coeffs,    0,0x00000000);///         //b,j,e,4*f   
-                acc_1=fpmac   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///     //b,j,e,4*f,g  
-               
-                //Calculate  lap_ij - lap_ijm
-                flux_sub = fpsub(lap_ij, concat(acc_1,undef_v8float()), 0, 0x76543210); // flx_imj = lap_ij - lap_ijm;
-                
-
-                 //*****************FLUX //below reuisng acc_1 for flux calculation
-                acc_1=fpmul   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);///  (lap_ij - lap_ijm)*g
-                acc_1=fpmsc   (acc_1,data_buf2,1,0x76543210,flux_sub,    0,0x00000000);// (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
-
-                // compare > 0
-                unsigned int flx_compare_imj=fpge (acc_1, null_v16float(), 0,0x76543210); /// flx_ijm * (test_in[d][c][r] - test_in[d][c][r-1]) > 0 ? 0 :
-                
-                    // ///////// **************************lap_ipj flx_ij**************************************
-                acc_0=fpmul   (data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);/// // l ; R1 is already loaded
-                // ///////// **************************lap_ipj flx_ij**************************************
-                acc_0=fpmsc   (acc_0,data_buf2,3,0x76543210,coeffs,    0,0x00000000);///   // l, 4*h
-
-               //Calculate final fly_ijm
-                v16float out_flx_inter1=fpselect16(flx_compare_imj,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-                  
-                // r1 = ptr_in+1 * COL/8+i + aor*COL/8;
-                row1_ptr=((v8float *) (row1))+i;
-                // data_buf1=*r1++;     
-                data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
-                data_buf1 = upd_w(data_buf1, 1, *row1_ptr); 
-
-                acc_0=fpmac  (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///  lap_ijp // l, 4*h, g
-                acc_0=fpmac   (acc_0,data_buf2,4,0x76543210,coeffs_rest,    0,0x00000000);///  l, 4*h, g, i   
-                v8float flx_out1=fpadd(null_v8float(),out_flx_inter1,0,0x76543210);   //still fly_ijm
-                
-               
-                acc_0=fpmac   (acc_0,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);///  // l, 4*h, g, i, d   
-                
-                //Calculates lap_ijp - lap_ij
-                flux_sub = fpsub(acc_0, concat(lap_ij,undef_v8float()), 0, 0x76543210); 
-               
-                acc_1=fpmul   (data_buf2,3,0x76543210,flux_sub,    0,0x00000000); // (lap_ijp - lap_ij) * h  
-                acc_1=fpmsc   (acc_1,data_buf2,2,0x76543210,flux_sub,    0,0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g                     
-
-                //Calculates final fly_ij (comparison > 0)
-                unsigned int flx_compare_ij=fpge (acc_1, null_v16float(), 0,0x76543210); 
-                v16float out_flx_inter2=fpselect16(flx_compare_ij,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-                        
-                //fly_ijm -fly_ij
-                v8float flx_out2=fpsub(flx_out1,out_flx_inter2,0,0x76543210);
-                //NOTE: fbsub does not support v16-v8 so instead of calculating fly_ij - fly_ijm - flx_imj + flx_ij
-                //              we calculate -(-fly_ij + fly_ijm + flx_imj - flx_ij)
-                // Therefore, flux coeff is positive as well.
- 
-    // //***********************************************************************STARTING X FLUX*****************************************************************************************************************************************************
-            //            //////// **************************LAP_imj sincer2=R2 are already loaded********
-                acc_1=fpmul    ( data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);        // g  
-                        
-                //////// **************************LAP_ipj for fly_ij sincer2=R2 are already loaded********
-                acc_0=fpmul   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);// g   
-
-                row0_ptr=((v8float *) (row0))+i;
-                // r2 = ptr_in + 0*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm 
-                data_buf2 = upd_w(data_buf2, 0, *row0_ptr++);
-                data_buf2 = upd_w(data_buf2, 1, *row0_ptr);
-
-                    // ///////// **************************LAP_imj since R1=buff 1 ************************************
-        
-                acc_1=fpmsc    (acc_1, data_buf1,2,0x76543210,coeffs,    0,0x00000000);      // g, 4*c
-                acc_1=fpmac    (acc_1, data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b
-                acc_1=fpmac   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);/// // g, 4*c, b, a
-                
-                row4_ptr=((v8float *) (row4))+i;
-                // r2 = ptr_in + 4*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm 
-                data_buf2 = upd_w(data_buf2, 0, *row4_ptr++);
-                data_buf2 = upd_w(data_buf2, 1, *row4_ptr);
-                    //////// **************************LAP_ipj for fly_ij since r2=R4********
-                acc_1=fpmac    ( acc_1,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b, a, d  
-                acc_0=fpmac   (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///   // g, m
-                
-
-                row2_ptr=((v8float *) (row2))+i;
-                // r2 = ptr_in + 2*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm 
-                data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
-                data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-                
-                
-                //flx_imj = lap_ij - lap_imj
-                flux_sub = fpsub(lap_ij, concat(acc_1,undef_v8float()), 0, 0x76543210); 
-               
-                acc_1=fpmul   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);///   (lap_ij - lap_imj) * g
-                acc_1=fpmsc   (acc_1,data_buf1,2,0x76543210,flux_sub,    0,0x00000000);///    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c          
-                
-                //Calculates final flx_imj (comparison > 0)
-                unsigned int fly_compare_ijm=fpge (acc_1, null_v16float(), 0,0x76543210);
-                v16float out_flx_inter3=fpselect16(fly_compare_ijm,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-        
-                row3_ptr=((v8float *) (row3))+i;
-                // r1 = ptr_in + 3*COL/8 + i + aor*COL/8; // load for LAP_ijp for fly_ij
-                // data_buf1=*r1++;
-                data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-                data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-                ////// **************************since r1=R1********
-                acc_0=fpmsc   (acc_0,data_buf1,2,0x76543210,coeffs,    0,0x00000000);///  //g, m , k * 4
-
-                v8float flx_out3=fpadd(flx_out2,out_flx_inter3,0,0x76543210);     //adds fly_ijm -fly_ij + flx_imj 
-
-                acc_0=fpmac   (acc_0,data_buf1, 1,0x76543210,coeffs_rest,    0,0x00000000);///  //g, m , k * 4, j   
-                acc_0=fpmac   (acc_0,data_buf1, 3,0x76543210,coeffs_rest,    0,0x00000000);///   //g, m , k * 4, j, l   
-                // lap_0=srs(acc_0,0); //LAP_ijp
-                ///////// **************************fly_ij *************************************
-                //  flx_ij = lap_ipj - lap_ij
-                flux_sub = fpsub(acc_0, concat(lap_ij,undef_v8float()), 0, 0x76543210);
-           
-                //below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
-                acc_1=fpmul   (data_buf1,2,0x76543210,flux_sub,    0,0x00000000);//  (lap_ipj - lap_ij) * k       
-                
-                //LOAD DATA FOR NEXT ITERATION
-                row3_ptr=((v8float *) (row3))+i+1;
-                // r1 = ptr_in + 3*COL/8 + i + 1 + aor*COL/8;
-                // data_buf1=*r1++;
-                data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-                data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-                
-                acc_1=fpmsc   (acc_1,data_buf2,2,0x76543210,flux_sub,    0,0x00000000); //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g   
-
-                 // final flx_ij (comparison > 0 )
-                unsigned int fly_compare_ij=fpge (acc_1, null_v16float(), 0,0x76543210);
-                v16float out_flx_inter4=fpselect16(fly_compare_ij,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-                
-                v8float flx_out4=fpsub(flx_out3,out_flx_inter4,0,0x76543210); //adds  fly_ijm -fly_ij + flx_imj -flx_ij
-               
-                // r1=R1, r2=R0
-           
-                v8float   final_output=fpmul  (concat(flx_out4,null_v8float()),0,0x76543210,flux_out_coeff,    0,0x00000000);  // Multiply by +7s
-                final_output=fpmac(final_output,data_buf2,  2, 0x76543210,coeffs1, 0 , 0x76543210); 
-                //LOAD DATA FOR NEXT ITERATION
-                row1_ptr=((v8float *) (row1))+i+1;
-                // r2 = ptr_in + 1*COL/8 + i + 1 + aor*COL/8;
-                data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
-                data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
-                *ptr_out++ =  final_output; 
-                // *ptr_out++ =  srs(final_output,0);       
-                //  window_writeincr(out, final_output);   
-        // }
+      // r1=R1, r2=R0
 
+      v8float final_output =
+          fpmul(concat(flx_out4, null_v8float()), 0, 0x76543210, flux_out_coeff,
+                0, 0x00000000); // Multiply by +7s
+      final_output =
+          fpmac(final_output, data_buf2, 2, 0x76543210, coeffs1, 0, 0x76543210);
+      // LOAD DATA FOR NEXT ITERATION
+      row1_ptr = ((v8float *)(row1)) + i + 1;
+      // r2 = ptr_in + 1*COL/8 + i + 1 + aor*COL/8;
+      data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
+      *ptr_out++ = final_output;
+      // *ptr_out++ =  srs(final_output,0);
+      //  window_writeincr(out, final_output);
+      // }
     }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/include.h b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/include.h
index 6ab94ff..689c33b 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/include.h
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/include.h
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/test.cpp b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/test.cpp
index 4a0e9e5..7a0723b 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/test.cpp
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong/test.cpp
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -45,8 +45,8 @@ int main(int argc, char *argv[]) {
 
   mlir_aie_acquire_lock(_xaie, 7, 1, 14, 0, 0); // for timing
   EventMonitor pc0(_xaie, 7, 1, 0, XAIE_EVENT_LOCK_14_ACQ_MEM,
-                 XAIE_EVENT_LOCK_14_REL_MEM, XAIE_EVENT_NONE_MEM,
-                 XAIE_MEM_MOD);
+                   XAIE_EVENT_LOCK_14_REL_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
   pc0.set();
 
   usleep(sleep_u);
@@ -98,10 +98,6 @@ int main(int argc, char *argv[]) {
   printf("before core start\n");
   mlir_aie_print_tile_status(_xaie, 7, 1);
 
-  
-  
-
-
   printf("Release lock for accessing DDR.\n");
   mlir_aie_release_of_0_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_3_lock_0(_xaie, 0, 0);
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/chess_main.cc b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/chess_main.cc
index f1d5093..f4ee1b5 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/chess_main.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/chess_main.cc
@@ -1,19 +1,18 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
 #include "hdiff.h"
 
-int main()
-{
-    int32_t din1[10] = {};
-    int32_t din2[10] = {};
-    int32_t din3[10] = {};
-    int32_t din4[10] = {};
-    int32_t din5[10] = {};
-    int32_t dout[10] = {};
-    vec_hdiff(din1,din2,din3, din4, din5,  dout); 
-    return 1;
+int main() {
+  int32_t din1[10] = {};
+  int32_t din2[10] = {};
+  int32_t din3[10] = {};
+  int32_t din4[10] = {};
+  int32_t din5[10] = {};
+  int32_t dout[10] = {};
+  vec_hdiff(din1, din2, din3, din4, din5, dout);
+  return 1;
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/hdiff.cc b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/hdiff.cc
index 4c7c062..0df5b10 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/hdiff.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/hdiff.cc
@@ -1,214 +1,268 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-#include "./include.h"
 #include "hdiff.h"
+#include "./include.h"
 #define kernel_load 14
 // typedef int int32;
 
-
-//align to 16 bytes boundary, equivalent to "alignas(v4int32)"
-void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict row2,int32_t* restrict row3,int32_t* restrict row4, int32_t* restrict out)
-{
-
- // const int32_t *restrict w = weights;
-    alignas(32) int32_t weights[8] = {-4,-4,-4,-4,-4,-4,-4,-4};
-    alignas(32) int32_t weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) int32_t weights_rest[8] = {-1,-1,-1,-1,-1,-1,-1,-1};
-    alignas(32) int32_t flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8int32 coeffs         = *(v8int32*) weights;  //  8 x int32 = 256b W vector
-    v8int32 coeffs1        = *(v8int32*) weights1;  //  8 x int32 = 256b W vector
-    v8int32 coeffs_rest    = *(v8int32*) weights_rest;  //  8 x int32 = 256b W vector
-    v8int32 flux_out_coeff = *(v8int32*) flux_out;
-
-    // v8int32 * restrict ptr_in = (v8int32 *) in;
-    v8int32 * ptr_out = (v8int32 *) out;
-    v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    v8int32 * restrict row2_ptr=(v8int32 *)row2;
-    v8int32 * restrict row3_ptr=(v8int32 *)row3;
-    v8int32 * restrict row4_ptr=(v8int32 *)row4;
-    v8int32 * restrict r1;
-    // v8int32 * restrict r2=ptr_in+1*COL/8;
-
-    v16int32 data_buf1 = null_v16int32();
-    v16int32 data_buf2 = null_v16int32();;
-    
-    v8acc80 acc_0 = null_v8acc80();
-    v8acc80 acc_1 = null_v8acc80();
-
-    //  v8acc80 acc_1=null_v8acc80();        
-    v8int32 lap_ij = null_v8int32();      //  8 x int32 = 256b W vector
-    v8int32 lap_0  = null_v8int32();      //  8 x int32 = 256b W vector
-
-
-
-        data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-        data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
-    
-        for (unsigned i = 0; i < COL/8; i++)
-            chess_prepare_for_pipelining
-                    chess_loop_range(1,)
-        {   
-            v16int32 flux_sub;
-
-            acc_0=lmul8   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);          //c           
-            acc_1=lmul8   (data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);          //b
-          
-            acc_0=lmac8   (acc_0,data_buf1,2,0x76543210,coeffs_rest,    0,0x00000000);    //c,k
-            acc_1=lmac8   (acc_1,data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);    //b,j
-          
-            // r2 = ptr_in+2 * COL/8+i ;
-            r1=row2_ptr+i;
-            data_buf2 = upd_w(data_buf2, 0, *(r1)++);
-            data_buf2 = upd_w(data_buf2, 1, *(r1));
-
-            acc_0=lmac8   (acc_0,data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000); //c,k,f
-            acc_0=lmsc8   (acc_0,data_buf2,2,0x76543210,coeffs,    0,0x00000000);      //c,k,f,4*g
-            acc_0=lmac8   (acc_0,data_buf2,3,0x76543210,coeffs_rest,    0,0x00000000);  //c,k,f,4*g,h
-            
-            lap_ij=srs(acc_0,0); //store lap_ij
-
-            acc_1=lmac8   (acc_1,data_buf2,0,0x76543210,coeffs_rest,    0,0x00000000); //b,j,e
-            acc_1=lmsc8   (acc_1,data_buf2,1,0x76543210,coeffs,    0,0x00000000);      //b,j,e,4*f
-            acc_1=lmac8   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);  //b,j,e,4*f,g  
-           
-            //lap_ijm
-            lap_0=srs(acc_1,0);
-    
-            //Calculate  lap_ij - lap_ijm
-            flux_sub = sub16(concat(lap_ij,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_0,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 ); 
-            
-            //
-            acc_1=lmul8   (data_buf2,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);           // (lap_ij - lap_ijm)*g
-            acc_1=lmsc8   (acc_1,data_buf2,1,0x76543210,ext_w(flux_sub,0),    0,0x00000000);     // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
-
-            // compare > 0
-            unsigned int flx_compare_imj=gt16(concat(srs(acc_1,0),undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            
-            acc_0=lmul8   (data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);   // l
-            acc_0=lmsc8   (acc_0,data_buf2,3,0x76543210,coeffs,    0,0x00000000);  // l, 4*h
-            
-            //Calculate final fly_ijm
-            v16int32 out_flx_inter1=select16(flx_compare_imj,flux_sub,null_v16int32()); 
-
-            // r1 = ptr_in+1 * COL/8+i ;
-            r1=row1_ptr+i;
-            data_buf1 = upd_w(data_buf1, 0, *(r1)++);
-            data_buf1 = upd_w(data_buf1, 1, *(r1));    
-
-            acc_0=lmac8  (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);  // l, 4*h, g
-            acc_0=lmac8   (acc_0,data_buf2,4,0x76543210,coeffs_rest,    0,0x00000000); // l, 4*h, g, i 
-            v16int32 flx_out1=add16(null_v16int32(),out_flx_inter1);     //still fly_ijm
-                      
-            acc_0=lmac8   (acc_0,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);// l, 4*h, g, i, d 
-            
-            //Calculates lap_ijp
-            lap_0=srs(acc_0,0); 
-
-            //Calculates lap_ijp - lap_ij
-            flux_sub = sub16(concat(lap_0,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_ij,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 );
-            
-            acc_0=lmul8   (data_buf2,3,0x76543210,ext_w(flux_sub,0),    0,0x00000000);            // (lap_ijp - lap_ij) * h       
-            acc_0=lmsc8   (acc_0,data_buf2,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);      //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g           
-
-            //Calculates final fly_ij (comparison > 0)
-            unsigned int flx_compare_ij=gt16(concat(srs(acc_0,0),undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter2=select16(flx_compare_ij,flux_sub,null_v16int32());    
-
-            //add fly_ij - fly_ijm
-            v16int32 flx_out2=sub16(out_flx_inter2,flx_out1);                             
-
-            //***********************************************************************STARTING X FLUX*****************************************************************************************************************************************************
-            
-            acc_1=lmul8    ( data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000); // g                     
-            acc_0=lmul8   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);   // g
-
-            // r2 = ptr_in + 0*COL/8 + i ; 
-            r1=row0_ptr+i;
-            data_buf2 = upd_w(data_buf2, 0, *(r1)++);
-            data_buf2 = upd_w(data_buf2, 1, *(r1));
-                  
-            acc_1=lmsc8    (acc_1, data_buf1,2,0x76543210,coeffs,    0,0x00000000);             // g, 4*c
-            acc_1=lmac8    (acc_1, data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);        // g, 4*c, b
-            acc_1=lmac8   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);          // g, 4*c, b, a
-          
-            // r2 = ptr_in + 4*COL/8 + i ; 
-            r1=row4_ptr+i;
-            data_buf2 = upd_w(data_buf2, 0, *(r1)++);
-            data_buf2 = upd_w(data_buf2, 1, *(r1));
-
-            acc_1=lmac8    ( acc_1,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b, a, d               
-            acc_0=lmac8   (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);         // g, m
-            
-            // r2 = ptr_in + 2*COL/8 + i ; 
-            r1=row2_ptr+i;
-            data_buf2 = upd_w(data_buf2, 0, *(r1)++);
-            data_buf2 = upd_w(data_buf2, 1, *(r1));
-            
-            //Calculates lap_imj
-            lap_0=srs(acc_1,0); 
-
-            //flx_imj = lap_ij - lap_imj
-            flux_sub = sub16(concat(lap_ij,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_0,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 ); 
-            
-            acc_1=lmul8   (data_buf2,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);       //   (lap_ij - lap_imj) * g
-            acc_1=lmsc8   (acc_1,data_buf1,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000); //    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c  
-     
-            //Calculates final flx_imj (comparison > 0)
-            unsigned int fly_compare_ijm=gt16(concat(srs(acc_1,0),undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter3=select16(fly_compare_ijm,flux_sub,null_v16int32());
-
-            // r1 = ptr_in + 3*COL/8 + i ;
-            r1=row3_ptr+i;
-            data_buf1 = upd_w(data_buf1, 0, *(r1)++);
-            data_buf1 = upd_w(data_buf1, 1, *(r1));
-
-            acc_0=lmsc8   (acc_0,data_buf1,2,0x76543210,coeffs,    0,0x00000000); //g, m , k * 4
-
-            v16int32 flx_out3=sub16(flx_out2,out_flx_inter3);                     //adds fly_ij - fly_ijm - flx_imj
-
-            acc_0=lmac8   (acc_0,data_buf1, 1,0x76543210,coeffs_rest,    0,0x00000000);     //g, m , k * 4, j 
-            acc_0=lmac8   (acc_0,data_buf1, 3,0x76543210,coeffs_rest,    0,0x00000000);     //g, m , k * 4, j, l  
-     
-            //  flx_ij = lap_ipj - lap_ij
-            flux_sub = sub16(concat(srs(acc_0,0),undef_v8int32()), 0, 0x76543210, 0xFEDCBA98, concat(lap_ij,undef_v8int32()),   0,  0x76543210, 0xFEDCBA98 ); 
-
-            //below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
-            acc_1=lmul8   (data_buf1,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);      //  (lap_ipj - lap_ij) * k       
-            
-            //LOAD DATA FOR NEXT ITERATION
-            // r1 = ptr_in + 3*COL/8 + i + 1 ;
-            r1=row3_ptr+i+1;
-            data_buf1 = upd_w(data_buf1, 0, *(r1)++);
-            data_buf1 = upd_w(data_buf1, 1, *(r1));
-            
-            acc_1=lmsc8   (acc_1,data_buf2,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);    //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g   
-
-            // final flx_ij (comparison > 0 )
-            unsigned int fly_compare_ij=gt16(concat(srs(acc_1,0),undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter4=select16(fly_compare_ij,flux_sub,null_v16int32()); 
-
-            v16int32 flx_out4=add16(flx_out3,out_flx_inter4); //adds fly_ij - fly_ijm - flx_imj + flx_ij
-
-            v8acc80 final_output = lmul8  (flx_out4, 0, 0x76543210, flux_out_coeff,    0,0x00000000);  // Multiply by -7s
-            final_output=lmac8(final_output, data_buf2,  2, 0x76543210,concat(coeffs1, undef_v8int32()), 0 , 0x76543210); 
-
-            //LOAD DATA FOR NEXT ITERATION
-            // r2 = ptr_in + 1*COL/8 + i + 1 ;
-            r1=row1_ptr+i+1;
-            data_buf2 = upd_w(data_buf2, 0, *(r1)++);
-            data_buf2 = upd_w(data_buf2, 1, *(r1));
-
-            // window_writeincr(out, srs(final_output,0));
-            *ptr_out++ =  srs(final_output,0);       
-        // }
-
+// align to 16 bytes boundary, equivalent to "alignas(v4int32)"
+void vec_hdiff(int32_t *restrict row0, int32_t *restrict row1,
+               int32_t *restrict row2, int32_t *restrict row3,
+               int32_t *restrict row4, int32_t *restrict out) {
+
+  // const int32_t *restrict w = weights;
+  alignas(32) int32_t weights[8] = {-4, -4, -4, -4, -4, -4, -4, -4};
+  alignas(32) int32_t weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) int32_t weights_rest[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
+  alignas(32) int32_t flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8int32 coeffs = *(v8int32 *)weights;           //  8 x int32 = 256b W vector
+  v8int32 coeffs1 = *(v8int32 *)weights1;         //  8 x int32 = 256b W vector
+  v8int32 coeffs_rest = *(v8int32 *)weights_rest; //  8 x int32 = 256b W vector
+  v8int32 flux_out_coeff = *(v8int32 *)flux_out;
+
+  // v8int32 * restrict ptr_in = (v8int32 *) in;
+  v8int32 *ptr_out = (v8int32 *)out;
+  v8int32 *restrict row0_ptr = (v8int32 *)row0;
+  v8int32 *restrict row1_ptr = (v8int32 *)row1;
+  v8int32 *restrict row2_ptr = (v8int32 *)row2;
+  v8int32 *restrict row3_ptr = (v8int32 *)row3;
+  v8int32 *restrict row4_ptr = (v8int32 *)row4;
+  v8int32 *restrict r1;
+  // v8int32 * restrict r2=ptr_in+1*COL/8;
+
+  v16int32 data_buf1 = null_v16int32();
+  v16int32 data_buf2 = null_v16int32();
+  ;
+
+  v8acc80 acc_0 = null_v8acc80();
+  v8acc80 acc_1 = null_v8acc80();
+
+  //  v8acc80 acc_1=null_v8acc80();
+  v8int32 lap_ij = null_v8int32(); //  8 x int32 = 256b W vector
+  v8int32 lap_0 = null_v8int32();  //  8 x int32 = 256b W vector
+
+  data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+  data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v16int32 flux_sub;
+
+      acc_0 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // c
+      acc_1 = lmul8(data_buf2, 1, 0x76543210, coeffs_rest, 0, 0x00000000); // b
+
+      acc_0 = lmac8(acc_0, data_buf1, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k
+      acc_1 = lmac8(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j
+
+      // r2 = ptr_in+2 * COL/8+i ;
+      r1 = row2_ptr + i;
+      data_buf2 = upd_w(data_buf2, 0, *(r1)++);
+      data_buf2 = upd_w(data_buf2, 1, *(r1));
+
+      acc_0 = lmac8(acc_0, data_buf2, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k,f
+      acc_0 = lmsc8(acc_0, data_buf2, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // c,k,f,4*g
+      acc_0 = lmac8(acc_0, data_buf2, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k,f,4*g,h
+
+      lap_ij = srs(acc_0, 0); // store lap_ij
+
+      acc_1 = lmac8(acc_1, data_buf2, 0, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j,e
+      acc_1 = lmsc8(acc_1, data_buf2, 1, 0x76543210, coeffs, 0,
+                    0x00000000); // b,j,e,4*f
+      acc_1 = lmac8(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j,e,4*f,g
+
+      // lap_ijm
+      lap_0 = srs(acc_1, 0);
+
+      // Calculate  lap_ij - lap_ijm
+      flux_sub =
+          sub16(concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+
+      //
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, ext_w(flux_sub, 0), 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g
+      acc_1 = lmsc8(acc_1, data_buf2, 1, 0x76543210, ext_w(flux_sub, 0), 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
+
+      // compare > 0
+      unsigned int flx_compare_imj =
+          gt16(concat(srs(acc_1, 0), undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+
+      acc_0 = lmul8(data_buf1, 3, 0x76543210, coeffs_rest, 0, 0x00000000); // l
+      acc_0 = lmsc8(acc_0, data_buf2, 3, 0x76543210, coeffs, 0,
+                    0x00000000); // l, 4*h
+
+      // Calculate final fly_ijm
+      v16int32 out_flx_inter1 =
+          select16(flx_compare_imj, flux_sub, null_v16int32());
+
+      // r1 = ptr_in+1 * COL/8+i ;
+      r1 = row1_ptr + i;
+      data_buf1 = upd_w(data_buf1, 0, *(r1)++);
+      data_buf1 = upd_w(data_buf1, 1, *(r1));
+
+      acc_0 = lmac8(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g
+      acc_0 = lmac8(acc_0, data_buf2, 4, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g, i
+      v16int32 flx_out1 =
+          add16(null_v16int32(), out_flx_inter1); // still fly_ijm
+
+      acc_0 = lmac8(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g, i, d
+
+      // Calculates lap_ijp
+      lap_0 = srs(acc_0, 0);
+
+      // Calculates lap_ijp - lap_ij
+      flux_sub =
+          sub16(concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+
+      acc_0 = lmul8(data_buf2, 3, 0x76543210, ext_w(flux_sub, 0), 0,
+                    0x00000000); // (lap_ijp - lap_ij) * h
+      acc_0 = lmsc8(
+          acc_0, data_buf2, 2, 0x76543210, ext_w(flux_sub, 0), 0,
+          0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g
+
+      // Calculates final fly_ij (comparison > 0)
+      unsigned int flx_compare_ij =
+          gt16(concat(srs(acc_0, 0), undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter2 =
+          select16(flx_compare_ij, flux_sub, null_v16int32());
+
+      // add fly_ij - fly_ijm
+      v16int32 flx_out2 = sub16(out_flx_inter2, flx_out1);
+
+      //***********************************************************************STARTING
+      //X
+      //FLUX*****************************************************************************************************************************************************
+
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+      acc_0 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+
+      // r2 = ptr_in + 0*COL/8 + i ;
+      r1 = row0_ptr + i;
+      data_buf2 = upd_w(data_buf2, 0, *(r1)++);
+      data_buf2 = upd_w(data_buf2, 1, *(r1));
+
+      acc_1 = lmsc8(acc_1, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, 4*c
+      acc_1 = lmac8(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b
+      acc_1 = lmac8(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a
+
+      // r2 = ptr_in + 4*COL/8 + i ;
+      r1 = row4_ptr + i;
+      data_buf2 = upd_w(data_buf2, 0, *(r1)++);
+      data_buf2 = upd_w(data_buf2, 1, *(r1));
+
+      acc_1 = lmac8(acc_1, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a, d
+      acc_0 = lmac8(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m
+
+      // r2 = ptr_in + 2*COL/8 + i ;
+      r1 = row2_ptr + i;
+      data_buf2 = upd_w(data_buf2, 0, *(r1)++);
+      data_buf2 = upd_w(data_buf2, 1, *(r1));
+
+      // Calculates lap_imj
+      lap_0 = srs(acc_1, 0);
+
+      // flx_imj = lap_ij - lap_imj
+      flux_sub =
+          sub16(concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, ext_w(flux_sub, 0), 0,
+                    0x00000000); //   (lap_ij - lap_imj) * g
+      acc_1 = lmsc8(
+          acc_1, data_buf1, 2, 0x76543210, ext_w(flux_sub, 0), 0,
+          0x00000000); //    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c
+
+      // Calculates final flx_imj (comparison > 0)
+      unsigned int fly_compare_ijm =
+          gt16(concat(srs(acc_1, 0), undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter3 =
+          select16(fly_compare_ijm, flux_sub, null_v16int32());
+
+      // r1 = ptr_in + 3*COL/8 + i ;
+      r1 = row3_ptr + i;
+      data_buf1 = upd_w(data_buf1, 0, *(r1)++);
+      data_buf1 = upd_w(data_buf1, 1, *(r1));
+
+      acc_0 = lmsc8(acc_0, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, m , k * 4
+
+      v16int32 flx_out3 =
+          sub16(flx_out2, out_flx_inter3); // adds fly_ij - fly_ijm - flx_imj
+
+      acc_0 = lmac8(acc_0, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m , k * 4, j
+      acc_0 = lmac8(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m , k * 4, j, l
+
+      //  flx_ij = lap_ipj - lap_ij
+      flux_sub = sub16(concat(srs(acc_0, 0), undef_v8int32()), 0, 0x76543210,
+                       0xFEDCBA98, concat(lap_ij, undef_v8int32()), 0,
+                       0x76543210, 0xFEDCBA98);
+
+      // below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
+      acc_1 = lmul8(data_buf1, 2, 0x76543210, ext_w(flux_sub, 0), 0,
+                    0x00000000); //  (lap_ipj - lap_ij) * k
+
+      // LOAD DATA FOR NEXT ITERATION
+      //  r1 = ptr_in + 3*COL/8 + i + 1 ;
+      r1 = row3_ptr + i + 1;
+      data_buf1 = upd_w(data_buf1, 0, *(r1)++);
+      data_buf1 = upd_w(data_buf1, 1, *(r1));
+
+      acc_1 =
+          lmsc8(acc_1, data_buf2, 2, 0x76543210, ext_w(flux_sub, 0), 0,
+                0x00000000); //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g
+
+      // final flx_ij (comparison > 0 )
+      unsigned int fly_compare_ij =
+          gt16(concat(srs(acc_1, 0), undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter4 =
+          select16(fly_compare_ij, flux_sub, null_v16int32());
+
+      v16int32 flx_out4 = add16(
+          flx_out3, out_flx_inter4); // adds fly_ij - fly_ijm - flx_imj + flx_ij
+
+      v8acc80 final_output = lmul8(flx_out4, 0, 0x76543210, flux_out_coeff, 0,
+                                   0x00000000); // Multiply by -7s
+      final_output = lmac8(final_output, data_buf2, 2, 0x76543210,
+                           concat(coeffs1, undef_v8int32()), 0, 0x76543210);
+
+      // LOAD DATA FOR NEXT ITERATION
+      //  r2 = ptr_in + 1*COL/8 + i + 1 ;
+      r1 = row1_ptr + i + 1;
+      data_buf2 = upd_w(data_buf2, 0, *(r1)++);
+      data_buf2 = upd_w(data_buf2, 1, *(r1));
+
+      // window_writeincr(out, srs(final_output,0));
+      *ptr_out++ = srs(final_output, 0);
+      // }
     }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/hdiff.h b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/hdiff.h
index 8772e72..576dfd9 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/hdiff.h
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/hdiff.h
@@ -1,11 +1,11 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-
 extern "C" {
-void vec_hdiff(int32_t* restrict in0,int32_t* restrict in1,int32_t* restrict in2,int32_t* restrict in3,int32_t* restrict in4, int32_t* restrict out);
+void vec_hdiff(int32_t *restrict in0, int32_t *restrict in1,
+               int32_t *restrict in2, int32_t *restrict in3,
+               int32_t *restrict in4, int32_t *restrict out);
 }
-
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/include.h b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/include.h
index f127d86..e74fe84 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/include.h
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/include.h
@@ -1,10 +1,9 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-
 #pragma once
 // #define WITH_MARGIN
 #define VECTORIZED_KERNEL
@@ -12,43 +11,43 @@
 // #define  MULTI_4x4
 // #include <adf.h>
 #include <stdint.h>
-#define GRIDROW     256
-#define GRIDCOL     256
-#define GRIDDEPTH   1
-#define TOTAL_INPUT GRIDROW*GRIDCOL*GRIDDEPTH
-
-#define ROW			256
-#define COL			256
-#define TILE_SIZE  COL
+#define GRIDROW 256
+#define GRIDCOL 256
+#define GRIDDEPTH 1
+#define TOTAL_INPUT GRIDROW *GRIDCOL *GRIDDEPTH
 
-#define WMARGIN     256       // Margin before the frame
+#define ROW 256
+#define COL 256
+#define TILE_SIZE COL
 
+#define WMARGIN 256 // Margin before the frame
 
-#define NBYTES		4		// datatype byte-width
+#define NBYTES 4 // datatype byte-width
 
-#define AVAIL_CORES 25*25
+#define AVAIL_CORES 25 * 25
 
-#define CORE_REQUIRED TOTAL_INPUT/TILE_SIZE
+#define CORE_REQUIRED TOTAL_INPUT / TILE_SIZE
 
 #ifdef MULTI_CORE
-    #ifdef  MULTI_2x2
-        #define HW_ROW 2
-        #define HW_COL 2
-    #else 
-        #define HW_ROW 4
-        #define HW_COL 4
-    #endif
-
-    #define USED_CORE HW_ROW*HW_COL
-    #define NITER    TOTAL_INPUT/(USED_CORE*TILE_SIZE)   // Number of iteration
+#ifdef MULTI_2x2
+#define HW_ROW 2
+#define HW_COL 2
+#else
+#define HW_ROW 4
+#define HW_COL 4
+#endif
+
+#define USED_CORE HW_ROW *HW_COL
+#define NITER TOTAL_INPUT / (USED_CORE * TILE_SIZE) // Number of iteration
 #else
 
-#define NITER    TOTAL_INPUT/(TILE_SIZE)    // Number of iteration
+#define NITER TOTAL_INPUT / (TILE_SIZE) // Number of iteration
 #endif
 
 #ifdef WITH_MARGIN
-#define INPUT_FILE "./data/TestInputS.txt"    // Input file name and location
+#define INPUT_FILE "./data/TestInputS.txt" // Input file name and location
 #else
-#define INPUT_FILE "./data/dataset_256x256x64.txt"    // Input file name and location
+#define INPUT_FILE                                                             \
+  "./data/dataset_256x256x64.txt" // Input file name and location
 #endif
-#define OUTPUT_FILE "./data/TestOutputS.txt"    // Output file name and location
\ No newline at end of file
+#define OUTPUT_FILE "./data/TestOutputS.txt" // Output file name and location
\ No newline at end of file
diff --git a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/test.cpp b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/test.cpp
index 045afbb..0a3e583 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/test.cpp
+++ b/reference_designs/horizontal_diffusion/HDIFF_single_AIE_objectFIFO_ping_pong_scaled/test.cpp
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -13,9 +13,9 @@
 #include <stdlib.h>
 #include <sys/mman.h>
 #include <thread>
+#include <time.h>
 #include <unistd.h>
 #include <xaiengine.h>
-#include <time.h>  
 #define HIGH_ADDR(addr) ((addr & 0xffffffff00000000) >> 32)
 #define LOW_ADDR(addr) (addr & 0x00000000ffffffff)
 #define MLIR_STACK_OFFSET 4096
@@ -27,7 +27,7 @@
 
 int main(int argc, char *argv[]) {
   printf("test start.\n");
-  clock_t t; 
+  clock_t t;
 
   aie_libxaie_ctx_t *_xaie = mlir_aie_init_libxaie();
   mlir_aie_init_device(_xaie);
@@ -36,9 +36,8 @@ int main(int argc, char *argv[]) {
   usleep(sleep_u);
   printf("before configure cores.\n");
 
-  for (int i=0; i<AIE_COL;i++)
-  {
-    for (int j=START_ROW; j<START_ROW+BROAD_CORES;j++)
+  for (int i = 0; i < AIE_COL; i++) {
+    for (int j = START_ROW; j < START_ROW + BROAD_CORES; j++)
       mlir_aie_clear_tile_memory(_xaie, i, j);
   }
 
@@ -51,8 +50,8 @@ int main(int argc, char *argv[]) {
 
   mlir_aie_acquire_lock(_xaie, 7, 3, 14, 0, 0); // for timing
   EventMonitor pc0(_xaie, 7, 3, 0, XAIE_EVENT_LOCK_14_ACQ_MEM,
-          XAIE_EVENT_LOCK_14_REL_MEM, XAIE_EVENT_NONE_MEM,
-          XAIE_MEM_MOD);
+                   XAIE_EVENT_LOCK_14_REL_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
   pc0.set();
 
   usleep(sleep_u);
@@ -63,8 +62,8 @@ int main(int argc, char *argv[]) {
 
   printf("Finish configure\n");
 
-  #define DMA_COUNT_IN 1536
-  #define DMA_COUNT_OUT 512
+#define DMA_COUNT_IN 1536
+#define DMA_COUNT_OUT 512
   int *ddr_ptr_in_0 = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT_IN);
   int *ddr_ptr_in_1 = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT_IN);
   int *ddr_ptr_in_2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT_IN);
@@ -98,7 +97,6 @@ int main(int argc, char *argv[]) {
   int *ddr_ptr_in_30 = mlir_aie_mem_alloc(_xaie, 30, DMA_COUNT_IN);
   int *ddr_ptr_in_31 = mlir_aie_mem_alloc(_xaie, 31, DMA_COUNT_IN);
 
-
   int *ddr_ptr_out_0_2 = mlir_aie_mem_alloc(_xaie, 32, DMA_COUNT_OUT);
   int *ddr_ptr_out_1_2 = mlir_aie_mem_alloc(_xaie, 33, DMA_COUNT_OUT);
   int *ddr_ptr_out_2_2 = mlir_aie_mem_alloc(_xaie, 34, DMA_COUNT_OUT);
@@ -132,8 +130,6 @@ int main(int argc, char *argv[]) {
   int *ddr_ptr_out_30_2 = mlir_aie_mem_alloc(_xaie, 62, DMA_COUNT_OUT);
   int *ddr_ptr_out_31_2 = mlir_aie_mem_alloc(_xaie, 63, DMA_COUNT_OUT);
 
-
-
   // initialize the external buffers
   for (int i = 0; i < DMA_COUNT_IN; i++) {
     *(ddr_ptr_in_0 + i) = i;  // input
@@ -146,31 +142,30 @@ int main(int argc, char *argv[]) {
     *(ddr_ptr_in_7 + i) = i;  // input
     *(ddr_ptr_in_8 + i) = i;  // input
     *(ddr_ptr_in_9 + i) = i;  // input
-    *(ddr_ptr_in_10 + i) = i;  // input
-    *(ddr_ptr_in_11 + i) = i;  // input
-    *(ddr_ptr_in_12 + i) = i;  // input
-    *(ddr_ptr_in_13 + i) = i;  // input
-    *(ddr_ptr_in_14 + i) = i;  // input
-    *(ddr_ptr_in_15 + i) = i;  // input
-    *(ddr_ptr_in_16 + i) = i;  // input
-    *(ddr_ptr_in_17 + i) = i;  // input
-    *(ddr_ptr_in_18 + i) = i;  // input
-    *(ddr_ptr_in_19 + i) = i;  // input
-    *(ddr_ptr_in_20 + i) = i;  // input
-    *(ddr_ptr_in_21 + i) = i;  // input
-    *(ddr_ptr_in_22 + i) = i;  // input
-    *(ddr_ptr_in_23 + i) = i;  // input
-    *(ddr_ptr_in_24 + i) = i;  // input
-    *(ddr_ptr_in_25 + i) = i;  // input
-    *(ddr_ptr_in_26 + i) = i;  // input
-    *(ddr_ptr_in_27 + i) = i;  // input
-    *(ddr_ptr_in_28 + i) = i;  // input
-    *(ddr_ptr_in_29 + i) = i;  // input
-    *(ddr_ptr_in_30 + i) = i;  // input
-    *(ddr_ptr_in_31 + i) = i;  // input
+    *(ddr_ptr_in_10 + i) = i; // input
+    *(ddr_ptr_in_11 + i) = i; // input
+    *(ddr_ptr_in_12 + i) = i; // input
+    *(ddr_ptr_in_13 + i) = i; // input
+    *(ddr_ptr_in_14 + i) = i; // input
+    *(ddr_ptr_in_15 + i) = i; // input
+    *(ddr_ptr_in_16 + i) = i; // input
+    *(ddr_ptr_in_17 + i) = i; // input
+    *(ddr_ptr_in_18 + i) = i; // input
+    *(ddr_ptr_in_19 + i) = i; // input
+    *(ddr_ptr_in_20 + i) = i; // input
+    *(ddr_ptr_in_21 + i) = i; // input
+    *(ddr_ptr_in_22 + i) = i; // input
+    *(ddr_ptr_in_23 + i) = i; // input
+    *(ddr_ptr_in_24 + i) = i; // input
+    *(ddr_ptr_in_25 + i) = i; // input
+    *(ddr_ptr_in_26 + i) = i; // input
+    *(ddr_ptr_in_27 + i) = i; // input
+    *(ddr_ptr_in_28 + i) = i; // input
+    *(ddr_ptr_in_29 + i) = i; // input
+    *(ddr_ptr_in_30 + i) = i; // input
+    *(ddr_ptr_in_31 + i) = i; // input
   }
 
-
   for (int i = 0; i < DMA_COUNT_OUT; i++) {
     *(ddr_ptr_out_0_2 + i) = 0;
     *(ddr_ptr_out_1_2 + i) = 0;
@@ -270,96 +265,93 @@ int main(int argc, char *argv[]) {
   mlir_aie_sync_mem_dev(_xaie, 62);
   mlir_aie_sync_mem_dev(_xaie, 63);
 
-
-
-
-  #ifdef LIBXAIENGINEV2
-
-    mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0); 
-    mlir_aie_external_set_addr_ddr_buffer_in_1((u64)ddr_ptr_in_1); 
-    mlir_aie_external_set_addr_ddr_buffer_in_2((u64)ddr_ptr_in_2); 
-    mlir_aie_external_set_addr_ddr_buffer_in_3((u64)ddr_ptr_in_3); 
-    mlir_aie_external_set_addr_ddr_buffer_in_4((u64)ddr_ptr_in_4); 
-    mlir_aie_external_set_addr_ddr_buffer_in_5((u64)ddr_ptr_in_5); 
-    mlir_aie_external_set_addr_ddr_buffer_in_6((u64)ddr_ptr_in_6); 
-    mlir_aie_external_set_addr_ddr_buffer_in_7((u64)ddr_ptr_in_7); 
-    mlir_aie_external_set_addr_ddr_buffer_in_8((u64)ddr_ptr_in_8); 
-    mlir_aie_external_set_addr_ddr_buffer_in_9((u64)ddr_ptr_in_9); 
-    mlir_aie_external_set_addr_ddr_buffer_in_10((u64)ddr_ptr_in_10); 
-    mlir_aie_external_set_addr_ddr_buffer_in_11((u64)ddr_ptr_in_11); 
-    mlir_aie_external_set_addr_ddr_buffer_in_12((u64)ddr_ptr_in_12); 
-    mlir_aie_external_set_addr_ddr_buffer_in_13((u64)ddr_ptr_in_13); 
-    mlir_aie_external_set_addr_ddr_buffer_in_14((u64)ddr_ptr_in_14); 
-    mlir_aie_external_set_addr_ddr_buffer_in_15((u64)ddr_ptr_in_15); 
-    mlir_aie_external_set_addr_ddr_buffer_in_16((u64)ddr_ptr_in_16); 
-    mlir_aie_external_set_addr_ddr_buffer_in_17((u64)ddr_ptr_in_17); 
-    mlir_aie_external_set_addr_ddr_buffer_in_18((u64)ddr_ptr_in_18); 
-    mlir_aie_external_set_addr_ddr_buffer_in_19((u64)ddr_ptr_in_19); 
-    mlir_aie_external_set_addr_ddr_buffer_in_20((u64)ddr_ptr_in_20); 
-    mlir_aie_external_set_addr_ddr_buffer_in_21((u64)ddr_ptr_in_21); 
-    mlir_aie_external_set_addr_ddr_buffer_in_22((u64)ddr_ptr_in_22); 
-    mlir_aie_external_set_addr_ddr_buffer_in_23((u64)ddr_ptr_in_23); 
-    mlir_aie_external_set_addr_ddr_buffer_in_24((u64)ddr_ptr_in_24); 
-    mlir_aie_external_set_addr_ddr_buffer_in_25((u64)ddr_ptr_in_25); 
-    mlir_aie_external_set_addr_ddr_buffer_in_26((u64)ddr_ptr_in_26); 
-    mlir_aie_external_set_addr_ddr_buffer_in_27((u64)ddr_ptr_in_27); 
-    mlir_aie_external_set_addr_ddr_buffer_in_28((u64)ddr_ptr_in_28); 
-    mlir_aie_external_set_addr_ddr_buffer_in_29((u64)ddr_ptr_in_29); 
-    mlir_aie_external_set_addr_ddr_buffer_in_30((u64)ddr_ptr_in_30); 
-    mlir_aie_external_set_addr_ddr_buffer_in_31((u64)ddr_ptr_in_31); 
-
-    mlir_aie_external_set_addr_ddr_buffer_out_0_2((u64)ddr_ptr_out_0_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_1_2((u64)ddr_ptr_out_1_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_2_2((u64)ddr_ptr_out_2_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_3_2((u64)ddr_ptr_out_3_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_4_2((u64)ddr_ptr_out_4_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_5_2((u64)ddr_ptr_out_5_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_6_2((u64)ddr_ptr_out_6_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_7_2((u64)ddr_ptr_out_7_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_8_2((u64)ddr_ptr_out_8_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_9_2((u64)ddr_ptr_out_9_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_10_2((u64)ddr_ptr_out_10_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_11_2((u64)ddr_ptr_out_11_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_12_2((u64)ddr_ptr_out_12_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_13_2((u64)ddr_ptr_out_13_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_14_2((u64)ddr_ptr_out_14_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_15_2((u64)ddr_ptr_out_15_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_16_2((u64)ddr_ptr_out_16_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_17_2((u64)ddr_ptr_out_17_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_18_2((u64)ddr_ptr_out_18_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_19_2((u64)ddr_ptr_out_19_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_20_2((u64)ddr_ptr_out_20_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_21_2((u64)ddr_ptr_out_21_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_22_2((u64)ddr_ptr_out_22_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_23_2((u64)ddr_ptr_out_23_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_24_2((u64)ddr_ptr_out_24_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_25_2((u64)ddr_ptr_out_25_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_26_2((u64)ddr_ptr_out_26_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_27_2((u64)ddr_ptr_out_27_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_28_2((u64)ddr_ptr_out_28_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_29_2((u64)ddr_ptr_out_29_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_30_2((u64)ddr_ptr_out_30_2); 
-    mlir_aie_external_set_addr_ddr_buffer_out_31_2((u64)ddr_ptr_out_31_2); 
-
-    mlir_aie_configure_shimdma_20(_xaie);
-    mlir_aie_configure_shimdma_30(_xaie);
-    mlir_aie_configure_shimdma_60(_xaie);
-    mlir_aie_configure_shimdma_70(_xaie);
-    mlir_aie_configure_shimdma_100(_xaie);
-    mlir_aie_configure_shimdma_110(_xaie);
-    mlir_aie_configure_shimdma_180(_xaie);
-    mlir_aie_configure_shimdma_190(_xaie);
-    mlir_aie_configure_shimdma_260(_xaie);
-    mlir_aie_configure_shimdma_270(_xaie);
-    mlir_aie_configure_shimdma_340(_xaie);
-    mlir_aie_configure_shimdma_350(_xaie);
-    mlir_aie_configure_shimdma_420(_xaie);
-    mlir_aie_configure_shimdma_430(_xaie);
-    mlir_aie_configure_shimdma_460(_xaie);
-    mlir_aie_configure_shimdma_470(_xaie);
-
-    //   mlir_aie_configure_shimdma_100(_xaie);
-  #endif
+#ifdef LIBXAIENGINEV2
+
+  mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0);
+  mlir_aie_external_set_addr_ddr_buffer_in_1((u64)ddr_ptr_in_1);
+  mlir_aie_external_set_addr_ddr_buffer_in_2((u64)ddr_ptr_in_2);
+  mlir_aie_external_set_addr_ddr_buffer_in_3((u64)ddr_ptr_in_3);
+  mlir_aie_external_set_addr_ddr_buffer_in_4((u64)ddr_ptr_in_4);
+  mlir_aie_external_set_addr_ddr_buffer_in_5((u64)ddr_ptr_in_5);
+  mlir_aie_external_set_addr_ddr_buffer_in_6((u64)ddr_ptr_in_6);
+  mlir_aie_external_set_addr_ddr_buffer_in_7((u64)ddr_ptr_in_7);
+  mlir_aie_external_set_addr_ddr_buffer_in_8((u64)ddr_ptr_in_8);
+  mlir_aie_external_set_addr_ddr_buffer_in_9((u64)ddr_ptr_in_9);
+  mlir_aie_external_set_addr_ddr_buffer_in_10((u64)ddr_ptr_in_10);
+  mlir_aie_external_set_addr_ddr_buffer_in_11((u64)ddr_ptr_in_11);
+  mlir_aie_external_set_addr_ddr_buffer_in_12((u64)ddr_ptr_in_12);
+  mlir_aie_external_set_addr_ddr_buffer_in_13((u64)ddr_ptr_in_13);
+  mlir_aie_external_set_addr_ddr_buffer_in_14((u64)ddr_ptr_in_14);
+  mlir_aie_external_set_addr_ddr_buffer_in_15((u64)ddr_ptr_in_15);
+  mlir_aie_external_set_addr_ddr_buffer_in_16((u64)ddr_ptr_in_16);
+  mlir_aie_external_set_addr_ddr_buffer_in_17((u64)ddr_ptr_in_17);
+  mlir_aie_external_set_addr_ddr_buffer_in_18((u64)ddr_ptr_in_18);
+  mlir_aie_external_set_addr_ddr_buffer_in_19((u64)ddr_ptr_in_19);
+  mlir_aie_external_set_addr_ddr_buffer_in_20((u64)ddr_ptr_in_20);
+  mlir_aie_external_set_addr_ddr_buffer_in_21((u64)ddr_ptr_in_21);
+  mlir_aie_external_set_addr_ddr_buffer_in_22((u64)ddr_ptr_in_22);
+  mlir_aie_external_set_addr_ddr_buffer_in_23((u64)ddr_ptr_in_23);
+  mlir_aie_external_set_addr_ddr_buffer_in_24((u64)ddr_ptr_in_24);
+  mlir_aie_external_set_addr_ddr_buffer_in_25((u64)ddr_ptr_in_25);
+  mlir_aie_external_set_addr_ddr_buffer_in_26((u64)ddr_ptr_in_26);
+  mlir_aie_external_set_addr_ddr_buffer_in_27((u64)ddr_ptr_in_27);
+  mlir_aie_external_set_addr_ddr_buffer_in_28((u64)ddr_ptr_in_28);
+  mlir_aie_external_set_addr_ddr_buffer_in_29((u64)ddr_ptr_in_29);
+  mlir_aie_external_set_addr_ddr_buffer_in_30((u64)ddr_ptr_in_30);
+  mlir_aie_external_set_addr_ddr_buffer_in_31((u64)ddr_ptr_in_31);
+
+  mlir_aie_external_set_addr_ddr_buffer_out_0_2((u64)ddr_ptr_out_0_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_1_2((u64)ddr_ptr_out_1_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_2_2((u64)ddr_ptr_out_2_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_3_2((u64)ddr_ptr_out_3_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_4_2((u64)ddr_ptr_out_4_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_5_2((u64)ddr_ptr_out_5_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_6_2((u64)ddr_ptr_out_6_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_7_2((u64)ddr_ptr_out_7_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_8_2((u64)ddr_ptr_out_8_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_9_2((u64)ddr_ptr_out_9_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_10_2((u64)ddr_ptr_out_10_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_11_2((u64)ddr_ptr_out_11_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_12_2((u64)ddr_ptr_out_12_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_13_2((u64)ddr_ptr_out_13_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_14_2((u64)ddr_ptr_out_14_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_15_2((u64)ddr_ptr_out_15_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_16_2((u64)ddr_ptr_out_16_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_17_2((u64)ddr_ptr_out_17_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_18_2((u64)ddr_ptr_out_18_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_19_2((u64)ddr_ptr_out_19_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_20_2((u64)ddr_ptr_out_20_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_21_2((u64)ddr_ptr_out_21_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_22_2((u64)ddr_ptr_out_22_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_23_2((u64)ddr_ptr_out_23_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_24_2((u64)ddr_ptr_out_24_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_25_2((u64)ddr_ptr_out_25_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_26_2((u64)ddr_ptr_out_26_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_27_2((u64)ddr_ptr_out_27_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_28_2((u64)ddr_ptr_out_28_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_29_2((u64)ddr_ptr_out_29_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_30_2((u64)ddr_ptr_out_30_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_31_2((u64)ddr_ptr_out_31_2);
+
+  mlir_aie_configure_shimdma_20(_xaie);
+  mlir_aie_configure_shimdma_30(_xaie);
+  mlir_aie_configure_shimdma_60(_xaie);
+  mlir_aie_configure_shimdma_70(_xaie);
+  mlir_aie_configure_shimdma_100(_xaie);
+  mlir_aie_configure_shimdma_110(_xaie);
+  mlir_aie_configure_shimdma_180(_xaie);
+  mlir_aie_configure_shimdma_190(_xaie);
+  mlir_aie_configure_shimdma_260(_xaie);
+  mlir_aie_configure_shimdma_270(_xaie);
+  mlir_aie_configure_shimdma_340(_xaie);
+  mlir_aie_configure_shimdma_350(_xaie);
+  mlir_aie_configure_shimdma_420(_xaie);
+  mlir_aie_configure_shimdma_430(_xaie);
+  mlir_aie_configure_shimdma_460(_xaie);
+  mlir_aie_configure_shimdma_470(_xaie);
+
+  //   mlir_aie_configure_shimdma_100(_xaie);
+#endif
 
   printf("Release lock for accessing DDR.\n");
 
@@ -368,16 +360,14 @@ int main(int argc, char *argv[]) {
   mlir_aie_release_of_44_lock_0(_xaie, 1, 0);
   mlir_aie_release_of_47_lock_0(_xaie, 0, 0);
 
-
   mlir_aie_release_of_64_lock_0(_xaie, 1, 0);
   mlir_aie_release_of_67_lock_0(_xaie, 0, 0);
   mlir_aie_release_of_68_lock_0(_xaie, 1, 0);
   mlir_aie_release_of_71_lock_0(_xaie, 0, 0);
 
-
   mlir_aie_release_of_96_lock_0(_xaie, 1, 0);
   mlir_aie_release_of_99_lock_0(_xaie, 0, 0);
-  mlir_aie_release_of_100_lock_0(_xaie, 1, 0);   
+  mlir_aie_release_of_100_lock_0(_xaie, 1, 0);
   mlir_aie_release_of_103_lock_0(_xaie, 0, 0);
 
   mlir_aie_release_of_80_lock_0(_xaie, 1, 0);
@@ -395,8 +385,6 @@ int main(int argc, char *argv[]) {
   mlir_aie_release_of_124_lock_0(_xaie, 1, 0);
   mlir_aie_release_of_127_lock_0(_xaie, 0, 0);
 
-
-
   mlir_aie_release_of_88_lock_0(_xaie, 1, 0);
   mlir_aie_release_of_91_lock_0(_xaie, 0, 0);
   mlir_aie_release_of_92_lock_0(_xaie, 1, 0);
@@ -423,7 +411,6 @@ int main(int argc, char *argv[]) {
   mlir_aie_release_of_108_lock_0(_xaie, 1, 0);
   mlir_aie_release_of_111_lock_0(_xaie, 0, 0);
 
-
   mlir_aie_release_of_0_lock_0(_xaie, 1, 0);
   mlir_aie_release_of_3_lock_0(_xaie, 0, 0);
   mlir_aie_release_of_4_lock_0(_xaie, 1, 0);
@@ -449,59 +436,91 @@ int main(int argc, char *argv[]) {
   mlir_aie_release_of_76_lock_0(_xaie, 1, 0);
   mlir_aie_release_of_79_lock_0(_xaie, 0, 0);
 
-
   printf("Start cores\n");
-  t = clock(); 
+  t = clock();
   ///// --- start counter-----
   mlir_aie_start_cores(_xaie);
 
   mlir_aie_release_lock(_xaie, 7, 3, 14, 0, 0); // for timing
-  t = clock() - t; 
+  t = clock() - t;
 
-  printf ("It took %ld clicks (%f seconds).\n",t,((float)t)/CLOCKS_PER_SEC);
+  printf("It took %ld clicks (%f seconds).\n", t, ((float)t) / CLOCKS_PER_SEC);
 
   usleep(sleep_u);
   printf("after core start\n");
   // mlir_aie_print_tile_status(_xaie, 7, 3);
 
   usleep(sleep_u);
-  // /mnt/scratch/gagsingh/mlir-aie/install/bin/aie-opt --aie-objectFifo-stateful-transform aie.mlir
+  // /mnt/scratch/gagsingh/mlir-aie/install/bin/aie-opt
+  // --aie-objectFifo-stateful-transform aie.mlir
 
   //   mlir_aie_acquire_of_17_lock_0(_xaie, 1, 0);
   //   mlir_aie_acquire_of_15_lock_0(_xaie, 1, 0);
 
-  mlir_aie_sync_mem_cpu(_xaie, 32); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 33); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 34); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 35); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 36); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 37); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 38); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 39); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 40); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 41); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 42); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 43); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 44); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 45); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 46); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 47); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 48); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 49); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 50); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 51); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 52); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 53); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 54); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 55); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 56); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 57); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 58); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 59); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 60); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 61); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 62); //// only used in libaiev2 //sync up with output
-  mlir_aie_sync_mem_cpu(_xaie, 63); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        32); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        33); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        34); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        35); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        36); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        37); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        38); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        39); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        40); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        41); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        42); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        43); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        44); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        45); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        46); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        47); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        48); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        49); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        50); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        51); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        52); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        53); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        54); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        55); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        56); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        57); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        58); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        59); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        60); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        61); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        62); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        63); //// only used in libaiev2 //sync up with output
   ///// --- end counter-----
   // for (int i =0; i < 256; i ++ ){
   //       printf("Location %d:  %d\n", i, ddr_ptr_out[i]);
@@ -511,8 +530,7 @@ int main(int argc, char *argv[]) {
   if (!errors) {
     printf("PASS!\n");
     res = 0;
-  } 
-  else {
+  } else {
     printf("Fail!\n");
     res = -1;
   }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/chess_main.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/chess_main.cc
index f1d5093..f4ee1b5 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/chess_main.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/chess_main.cc
@@ -1,19 +1,18 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
 #include "hdiff.h"
 
-int main()
-{
-    int32_t din1[10] = {};
-    int32_t din2[10] = {};
-    int32_t din3[10] = {};
-    int32_t din4[10] = {};
-    int32_t din5[10] = {};
-    int32_t dout[10] = {};
-    vec_hdiff(din1,din2,din3, din4, din5,  dout); 
-    return 1;
+int main() {
+  int32_t din1[10] = {};
+  int32_t din2[10] = {};
+  int32_t din3[10] = {};
+  int32_t din4[10] = {};
+  int32_t din5[10] = {};
+  int32_t dout[10] = {};
+  vec_hdiff(din1, din2, din3, din4, din5, dout);
+  return 1;
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff.h b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff.h
index 60a3d2d..0a91f1d 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff.h
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff.h
@@ -1,20 +1,41 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
 extern "C" {
-void hdiff_lap(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict row2,int32_t* restrict row3,int32_t* restrict row4, int32_t* restrict out_flux1, int32_t* restrict out_flux2, int32_t* restrict out_flux3, int32_t* restrict out_flux4 );
-void hdiff_flux1(int32_t* restrict row1, int32_t* restrict row2,int32_t* restrict row3, int32_t* restrict flux_forward1,int32_t* restrict flux_forward2,int32_t* restrict flux_forward3,int32_t* restrict flux_forward4,  int32_t* restrict flux_inter1,int32_t* restrict flux_inter2,int32_t* restrict flux_inter3,int32_t* restrict flux_inter4,int32_t* restrict flux_inter5);
-void hdiff_flux2(int32_t* restrict flux_inter1,int32_t* restrict flux_inter2,int32_t* restrict flux_inter3,int32_t* restrict flux_inter4,int32_t* restrict flux_inter5,  int32_t * restrict out);
-
-void hdiff_lap_fp32(float* restrict row0, float* restrict row1,float* restrict row2,float* restrict row3,float* restrict row4, float* restrict out_flux1, float* restrict out_flux2, float* restrict out_flux3, float* restrict out_flux4 );
-void hdiff_flux1_fp32(float* restrict row1, float* restrict row2,float* restrict row3,\
- float* restrict flux_forward1,float* restrict flux_forward2,float* restrict flux_forward3,float* restrict flux_forward4, \
-  float * restrict flux_inter1,float * restrict flux_inter2,float * restrict flux_inter3,float * restrict flux_inter4,float * restrict flux_inter5);
+void hdiff_lap(int32_t *restrict row0, int32_t *restrict row1,
+               int32_t *restrict row2, int32_t *restrict row3,
+               int32_t *restrict row4, int32_t *restrict out_flux1,
+               int32_t *restrict out_flux2, int32_t *restrict out_flux3,
+               int32_t *restrict out_flux4);
+void hdiff_flux1(int32_t *restrict row1, int32_t *restrict row2,
+                 int32_t *restrict row3, int32_t *restrict flux_forward1,
+                 int32_t *restrict flux_forward2,
+                 int32_t *restrict flux_forward3,
+                 int32_t *restrict flux_forward4, int32_t *restrict flux_inter1,
+                 int32_t *restrict flux_inter2, int32_t *restrict flux_inter3,
+                 int32_t *restrict flux_inter4, int32_t *restrict flux_inter5);
+void hdiff_flux2(int32_t *restrict flux_inter1, int32_t *restrict flux_inter2,
+                 int32_t *restrict flux_inter3, int32_t *restrict flux_inter4,
+                 int32_t *restrict flux_inter5, int32_t *restrict out);
 
-void hdiff_flux2_fp32(float* restrict flux_inter1,float* restrict flux_inter2, float* restrict flux_inter3,float* restrict flux_inter4,float* restrict flux_inter5, float * restrict out);
+void hdiff_lap_fp32(float *restrict row0, float *restrict row1,
+                    float *restrict row2, float *restrict row3,
+                    float *restrict row4, float *restrict out_flux1,
+                    float *restrict out_flux2, float *restrict out_flux3,
+                    float *restrict out_flux4);
+void hdiff_flux1_fp32(float *restrict row1, float *restrict row2,
+                      float *restrict row3, float *restrict flux_forward1,
+                      float *restrict flux_forward2,
+                      float *restrict flux_forward3,
+                      float *restrict flux_forward4,
+                      float *restrict flux_inter1, float *restrict flux_inter2,
+                      float *restrict flux_inter3, float *restrict flux_inter4,
+                      float *restrict flux_inter5);
 
+void hdiff_flux2_fp32(float *restrict flux_inter1, float *restrict flux_inter2,
+                      float *restrict flux_inter3, float *restrict flux_inter4,
+                      float *restrict flux_inter5, float *restrict out);
 }
-
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux1.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux1.cc
index 8882757..a7177a2 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux1.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux1.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,134 +9,135 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,  int32_t * restrict out)
+// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,
+// int32_t * restrict out)
 // {
-void hdiff_flux1(int32_t* restrict row1, int32_t* restrict row2,int32_t* restrict row3,\
- int32_t* restrict flux_forward1,int32_t* restrict flux_forward2,int32_t* restrict flux_forward3,int32_t* restrict flux_forward4, \
-  int32_t * restrict flux_inter1,int32_t * restrict flux_inter2,int32_t * restrict flux_inter3,int32_t * restrict flux_inter4,int32_t * restrict flux_inter5)
-{
-    // v8int32 * restrict  ptr_in = (v8int32 *) in;
-    v8int32 * restrict  ptr_forward = (v8int32 *) flux_forward1;
-    v8int32 * ptr_out = (v8int32 *) flux_inter1;
-    
-    v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    v8int32 * restrict row2_ptr=(v8int32 *)row2;
-    v8int32 * restrict row3_ptr=(v8int32 *)row3;
-
-    // v8int32 * restrict r1=(v8int32 *)row1_ptr;
-    // v8int32 * restrict r2=(v8int32 *)row2_ptr;
-
-    // v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    // v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    // v8int32 * restrict row2_ptr=(v8int32 *)row2;
-
-    v16int32   data_buf1=null_v16int32();
-    v16int32  data_buf2=null_v16int32();
-
-    v8acc80 acc_0=null_v8acc80();
-    v8acc80 acc_1=null_v8acc80();
-          //  8 x int32 = 256b W vector
-
-  
-        // r1 = ptr_in + 1*COL/8 + aor*COL/8;
-        // r2 = ptr_in + 2*COL/8 + aor*COL/8;
-        data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
-
-        data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-
-        
-    // buf_2=R2 , and buf_1=R3
-        
-    for (unsigned i = 0; i < COL/8; i++)
-        chess_prepare_for_pipelining
-        chess_loop_range(1,)
-        {
-            v8int32  flux_sub;
-            // printf("inside flux");
-            // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
-            ptr_forward = (v8int32 *) flux_forward1+i;
-            flux_sub=*ptr_forward;
-            // flux_sub=window_readincr_v8(flux_cascade);
-            acc_1=lmul8   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);           // (lap_ij - lap_ijm)*g
-            acc_1=lmsc8   (acc_1,data_buf2,1,0x76543210,flux_sub,    0,0x00000000);     // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
-            
-            ptr_out = (v8int32 *) flux_inter1+2*i;
-            *ptr_out++=  flux_sub;
-            *ptr_out= srs(acc_1,0);
-
-           
-    /////////////////////////////////////////////////////////////////////////////////////
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_forward2+i;
-            flux_sub=*ptr_forward;
-            
-            acc_0=lmul8   (data_buf2,3,0x76543210,flux_sub,    0,0x00000000);            // (lap_ijp - lap_ij) * h       
-            acc_0=lmsc8   (acc_0,data_buf2,2,0x76543210,flux_sub,    0,0x00000000);      //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g           
-
-            ptr_out = (v8int32 *) flux_inter2+2*i;
-            *ptr_out++= flux_sub;
-            *ptr_out= srs(acc_0,0);
-                         
-/////////////////////////////////////////////////////////////////////////////////////
-
-            /// retrieving flx_imj = lap_ij - lap_imj
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_forward3+i;
-            flux_sub=*ptr_forward;
-            acc_1=lmul8   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);       //   (lap_ij - lap_imj) * g
-            acc_1=lmsc8   (acc_1,data_buf1,2,0x76543210,flux_sub,    0,0x00000000); //    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c  
-            
-          
-            ptr_out = (v8int32 *) flux_inter3+2*i;
-            *ptr_out++= flux_sub;
-            *ptr_out= srs(acc_1,0);
-            
-            row3_ptr=((v8int32 *) (row3))+i;
-            data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
-
-            
-         
-/////////////////////////////////////////////////////////////////////////////////////
-             // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-             //re†rieving flx_ij = lap_ipj - lap_ij
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_forward4+i;
-            flux_sub=*ptr_forward;
-
-            //below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
-            acc_1=lmul8   (data_buf1,2,0x76543210,flux_sub,    0,0x00000000);      //  (lap_ipj - lap_ij) * k       
-            acc_1=lmsc8   (acc_1,data_buf2,2,0x76543210,flux_sub,    0,0x00000000);    //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g   
-
-            ptr_out = (v8int32 *) flux_inter4+2*i;
-            *ptr_out++= flux_sub;
-            *ptr_out= srs(acc_1,0);
-
-            // r1 = ptr_in + 1*COL/8 + i+1+ aor*COL/8;
-            //LOAD DATA FOR NEXT ITERATION  
-            row1_ptr=((v8int32 *) (row1))+i+1;
-            data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));
-
-            ptr_out = (v8int32 *) flux_inter5+2*i;
-            *ptr_out++= ext_w(data_buf2,1);
-            *ptr_out= ext_w(data_buf2,0);
-
-          //LOAD DATA FOR NEXT ITERATION         
-            row2_ptr=((v8int32 *) (row2))+i+1;
-            // data_buf1=*r1++;
-            data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-
-
-                      
-        }
-    
-
+void hdiff_flux1(int32_t *restrict row1, int32_t *restrict row2,
+                 int32_t *restrict row3, int32_t *restrict flux_forward1,
+                 int32_t *restrict flux_forward2,
+                 int32_t *restrict flux_forward3,
+                 int32_t *restrict flux_forward4, int32_t *restrict flux_inter1,
+                 int32_t *restrict flux_inter2, int32_t *restrict flux_inter3,
+                 int32_t *restrict flux_inter4, int32_t *restrict flux_inter5) {
+  // v8int32 * restrict  ptr_in = (v8int32 *) in;
+  v8int32 *restrict ptr_forward = (v8int32 *)flux_forward1;
+  v8int32 *ptr_out = (v8int32 *)flux_inter1;
+
+  v8int32 *restrict row1_ptr = (v8int32 *)row1;
+  v8int32 *restrict row2_ptr = (v8int32 *)row2;
+  v8int32 *restrict row3_ptr = (v8int32 *)row3;
+
+  // v8int32 * restrict r1=(v8int32 *)row1_ptr;
+  // v8int32 * restrict r2=(v8int32 *)row2_ptr;
+
+  // v8int32 * restrict row0_ptr=(v8int32 *)row0;
+  // v8int32 * restrict row1_ptr=(v8int32 *)row1;
+  // v8int32 * restrict row2_ptr=(v8int32 *)row2;
+
+  v16int32 data_buf1 = null_v16int32();
+  v16int32 data_buf2 = null_v16int32();
+
+  v8acc80 acc_0 = null_v8acc80();
+  v8acc80 acc_1 = null_v8acc80();
+  //  8 x int32 = 256b W vector
+
+  // r1 = ptr_in + 1*COL/8 + aor*COL/8;
+  // r2 = ptr_in + 2*COL/8 + aor*COL/8;
+  data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
+
+  data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+
+  // buf_2=R2 , and buf_1=R3
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v8int32 flux_sub;
+      // printf("inside flux");
+      // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
+      ptr_forward = (v8int32 *)flux_forward1 + i;
+      flux_sub = *ptr_forward;
+      // flux_sub=window_readincr_v8(flux_cascade);
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g
+      acc_1 = lmsc8(acc_1, data_buf2, 1, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
+
+      ptr_out = (v8int32 *)flux_inter1 + 2 * i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = srs(acc_1, 0);
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_forward2 + i;
+      flux_sub = *ptr_forward;
+
+      acc_0 = lmul8(data_buf2, 3, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ijp - lap_ij) * h
+      acc_0 = lmsc8(
+          acc_0, data_buf2, 2, 0x76543210, flux_sub, 0,
+          0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g
+
+      ptr_out = (v8int32 *)flux_inter2 + 2 * i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = srs(acc_0, 0);
+
+      /////////////////////////////////////////////////////////////////////////////////////
+
+      /// retrieving flx_imj = lap_ij - lap_imj
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_forward3 + i;
+      flux_sub = *ptr_forward;
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); //   (lap_ij - lap_imj) * g
+      acc_1 = lmsc8(
+          acc_1, data_buf1, 2, 0x76543210, flux_sub, 0,
+          0x00000000); //    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c
+
+      ptr_out = (v8int32 *)flux_inter3 + 2 * i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = srs(acc_1, 0);
+
+      row3_ptr = ((v8int32 *)(row3)) + i;
+      data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // re†rieving flx_ij = lap_ipj - lap_ij
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_forward4 + i;
+      flux_sub = *ptr_forward;
+
+      // below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
+      acc_1 = lmul8(data_buf1, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); //  (lap_ipj - lap_ij) * k
+      acc_1 =
+          lmsc8(acc_1, data_buf2, 2, 0x76543210, flux_sub, 0,
+                0x00000000); //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g
+
+      ptr_out = (v8int32 *)flux_inter4 + 2 * i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = srs(acc_1, 0);
+
+      // r1 = ptr_in + 1*COL/8 + i+1+ aor*COL/8;
+      // LOAD DATA FOR NEXT ITERATION
+      row1_ptr = ((v8int32 *)(row1)) + i + 1;
+      data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));
+
+      ptr_out = (v8int32 *)flux_inter5 + 2 * i;
+      *ptr_out++ = ext_w(data_buf2, 1);
+      *ptr_out = ext_w(data_buf2, 0);
+
+      // LOAD DATA FOR NEXT ITERATION
+      row2_ptr = ((v8int32 *)(row2)) + i + 1;
+      // data_buf1=*r1++;
+      data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+    }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux1_fp32.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux1_fp32.cc
index b2c2cb1..a142ee2 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux1_fp32.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux1_fp32.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,144 +9,144 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,  int32_t * restrict out)
+// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,
+// int32_t * restrict out)
 // {
-void hdiff_flux1_fp32(float* restrict row1, float* restrict row2,float* restrict row3,\
- float* restrict flux_forward1,float* restrict flux_forward2,float* restrict flux_forward3,float* restrict flux_forward4, \
-  float * restrict flux_inter1,float * restrict flux_inter2,float * restrict flux_inter3,float * restrict flux_inter4,float * restrict flux_inter5)
-{
-    
-    alignas(32) float weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) float flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8float coeffs1        = *(v8float*) weights1;  //  8 x int32 = 256b W vector
-    v8float flux_out_coeff = *(v8float*) flux_out;
-
-    // v8int32 * restrict  ptr_in = (v8int32 *) in;
-    v8float * restrict  ptr_forward = (v8float *) flux_forward1;
-    v8float * ptr_out = (v8float *) flux_inter1;
-    
-    v8float * restrict row1_ptr=(v8float *)row1;
-    v8float * restrict row2_ptr=(v8float *)row2;
-    v8float * restrict row3_ptr=(v8float *)row3;
-
-    // v8float * restrict r1=(v8float *)row1_ptr;
-    // v8float * restrict r2=(v8float *)row2_ptr;
-
-    // v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    // v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    // v8int32 * restrict row2_ptr=(v8int32 *)row2;
-
-    v16float   data_buf1=null_v16float();
-    v16float  data_buf2=null_v16float();
-
-    v8float acc_0=null_v8float();
-    v8float acc_1=null_v8float();
-          //  8 x int32 = 256b W vector
-
-  
-        // r1 = ptr_in + 1*COL/8 + aor*COL/8;
-        // r2 = ptr_in + 2*COL/8 + aor*COL/8;
-        data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
-
-        data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-
-        
-    // buf_2=R2 , and buf_1=R3
-        
-    for (unsigned i = 0; i < COL/8; i++)
-        chess_prepare_for_pipelining
-        chess_loop_range(1,)
-        {
-            v8float flux_sub;
-            // printf("inside flux");
-            // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
-            ptr_forward = (v8float *) flux_forward1+i;
-            flux_sub=*ptr_forward;
-            // flux_sub=window_readincr_v8(flux_cascade);
-            acc_1=fpmul   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);///  (lap_ij - lap_ijm)*g
-            acc_1=fpmsc   (acc_1,data_buf2,1,0x76543210,flux_sub,    0,0x00000000);// (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
-
-            ptr_out = (v8float *) flux_inter1+i;
-            *ptr_out++=  flux_sub;
-            *ptr_out= acc_1;
-
-           
-    /////////////////////////////////////////////////////////////////////////////////////
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8float *) flux_forward2+i;
-            flux_sub=*ptr_forward;
-            
-            acc_0=fpmul   (data_buf2,3,0x76543210,flux_sub,    0,0x00000000); // (lap_ijp - lap_ij) * h    
-            acc_0=fpmsc   (acc_1,data_buf2,2,0x76543210,flux_sub,    0,0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g                     
-
-            ptr_out = (v8float *) flux_inter2+i;
-            *ptr_out++= flux_sub;
-            *ptr_out= acc_0;
-                         
-/////////////////////////////////////////////////////////////////////////////////////
-
-            /// retrieving flx_imj = lap_ij - lap_imj
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8float *) flux_forward3+i;
-            flux_sub=*ptr_forward;
-            acc_1=fpmul   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);///   (lap_ij - lap_imj) * g
-            acc_1=fpmsc   (acc_1,data_buf1,2,0x76543210,flux_sub,    0,0x00000000);///    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c          
-                
-          
-            ptr_out = (v8float *) flux_inter3+i;
-            *ptr_out++= flux_sub;
-            *ptr_out= acc_1;
-            
-            row3_ptr=((v8float *) (row3))+i;
-
-            data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-            data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-
-            
-         
-/////////////////////////////////////////////////////////////////////////////////////
-             // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-             //re†rieving flx_ij = lap_ipj - lap_ij
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8float *) flux_forward4+i;
-            flux_sub=*ptr_forward;
-
-            //below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
-            acc_1=fpmul   (data_buf1,2,0x76543210,flux_sub,    0,0x00000000);//  (lap_ipj - lap_ij) * k       
-
-            acc_1=fpmsc   (acc_1,data_buf2,2,0x76543210,flux_sub,    0,0x00000000);    //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g   
-
-            ptr_out = (v8float *) flux_inter4+i;
-            *ptr_out++= flux_sub;
-            *ptr_out= acc_1;
-
-            // r1 = ptr_in + 1*COL/8 + i+1+ aor*COL/8;
-            row1_ptr=((v8float *) (row1))+i+1;
-            data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
-            data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
-
-            
-
-            ptr_out = (v8float *) flux_inter5+i;
-            *ptr_out++= ext_w(data_buf2,1);
-            *ptr_out= ext_w(data_buf2,0);
-
-          //LOAD DATA FOR NEXT ITERATION         
-            row2_ptr=((v8float *) (row2))+i+1;
-            // data_buf1=*r1++;
-            data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
-            data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-
-
-                      
-        }
-    
-
+void hdiff_flux1_fp32(float *restrict row1, float *restrict row2,
+                      float *restrict row3, float *restrict flux_forward1,
+                      float *restrict flux_forward2,
+                      float *restrict flux_forward3,
+                      float *restrict flux_forward4,
+                      float *restrict flux_inter1, float *restrict flux_inter2,
+                      float *restrict flux_inter3, float *restrict flux_inter4,
+                      float *restrict flux_inter5) {
+
+  alignas(32) float weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) float flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8float coeffs1 = *(v8float *)weights1; //  8 x int32 = 256b W vector
+  v8float flux_out_coeff = *(v8float *)flux_out;
+
+  // v8int32 * restrict  ptr_in = (v8int32 *) in;
+  v8float *restrict ptr_forward = (v8float *)flux_forward1;
+  v8float *ptr_out = (v8float *)flux_inter1;
+
+  v8float *restrict row1_ptr = (v8float *)row1;
+  v8float *restrict row2_ptr = (v8float *)row2;
+  v8float *restrict row3_ptr = (v8float *)row3;
+
+  // v8float * restrict r1=(v8float *)row1_ptr;
+  // v8float * restrict r2=(v8float *)row2_ptr;
+
+  // v8int32 * restrict row0_ptr=(v8int32 *)row0;
+  // v8int32 * restrict row1_ptr=(v8int32 *)row1;
+  // v8int32 * restrict row2_ptr=(v8int32 *)row2;
+
+  v16float data_buf1 = null_v16float();
+  v16float data_buf2 = null_v16float();
+
+  v8float acc_0 = null_v8float();
+  v8float acc_1 = null_v8float();
+  //  8 x int32 = 256b W vector
+
+  // r1 = ptr_in + 1*COL/8 + aor*COL/8;
+  // r2 = ptr_in + 2*COL/8 + aor*COL/8;
+  data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
+
+  data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+
+  // buf_2=R2 , and buf_1=R3
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v8float flux_sub;
+      // printf("inside flux");
+      // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
+      ptr_forward = (v8float *)flux_forward1 + i;
+      flux_sub = *ptr_forward;
+      // flux_sub=window_readincr_v8(flux_cascade);
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); ///  (lap_ij - lap_ijm)*g
+      acc_1 = fpmsc(acc_1, data_buf2, 1, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
+
+      ptr_out = (v8float *)flux_inter1 + i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = acc_1;
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_forward2 + i;
+      flux_sub = *ptr_forward;
+
+      acc_0 = fpmul(data_buf2, 3, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ijp - lap_ij) * h
+      acc_0 = fpmsc(
+          acc_1, data_buf2, 2, 0x76543210, flux_sub, 0,
+          0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g
+
+      ptr_out = (v8float *)flux_inter2 + i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = acc_0;
+
+      /////////////////////////////////////////////////////////////////////////////////////
+
+      /// retrieving flx_imj = lap_ij - lap_imj
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_forward3 + i;
+      flux_sub = *ptr_forward;
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); ///   (lap_ij - lap_imj) * g
+      acc_1 = fpmsc(
+          acc_1, data_buf1, 2, 0x76543210, flux_sub, 0,
+          0x00000000); ///    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c
+
+      ptr_out = (v8float *)flux_inter3 + i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = acc_1;
+
+      row3_ptr = ((v8float *)(row3)) + i;
+
+      data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // re†rieving flx_ij = lap_ipj - lap_ij
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_forward4 + i;
+      flux_sub = *ptr_forward;
+
+      // below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
+      acc_1 = fpmul(data_buf1, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); //  (lap_ipj - lap_ij) * k
+
+      acc_1 =
+          fpmsc(acc_1, data_buf2, 2, 0x76543210, flux_sub, 0,
+                0x00000000); //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g
+
+      ptr_out = (v8float *)flux_inter4 + i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = acc_1;
+
+      // r1 = ptr_in + 1*COL/8 + i+1+ aor*COL/8;
+      row1_ptr = ((v8float *)(row1)) + i + 1;
+      data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
+
+      ptr_out = (v8float *)flux_inter5 + i;
+      *ptr_out++ = ext_w(data_buf2, 1);
+      *ptr_out = ext_w(data_buf2, 0);
+
+      // LOAD DATA FOR NEXT ITERATION
+      row2_ptr = ((v8float *)(row2)) + i + 1;
+      // data_buf1=*r1++;
+      data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+    }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux2.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux2.cc
index d61fee9..1a55fb6 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux2.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux2.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,121 +9,130 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,  int32_t * restrict out)
+// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,
+// int32_t * restrict out)
 // {
-void hdiff_flux2(int32_t* restrict flux_inter1,int32_t* restrict flux_inter2, int32_t* restrict flux_inter3,int32_t* restrict flux_inter4,int32_t* restrict flux_inter5, int32_t * restrict out)
-{
-    
-    alignas(32) int32_t weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) int32_t flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8int32 coeffs1         = *(v8int32*) weights1;  //  8 x int32 = 256b W vector
-    v8int32 flux_out_coeff=*(v8int32*)flux_out;
-
-    // v8int32 * restrict  ptr_in = (v8int32 *) in;
-    v8int32 * restrict  ptr_forward = (v8int32 *) flux_inter1;
-    v8int32 * ptr_out = (v8int32 *) out;
-    
-
-
-    // v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    // v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    // v8int32 * restrict row2_ptr=(v8int32 *)row2;
-
-    // v16int32   data_buf1=null_v16int32();
-    v16int32  data_buf2=null_v16int32();
-
-    v8acc80 acc_0=null_v8acc80();
-    v8acc80 acc_1=null_v8acc80();
-          //  8 x int32 = 256b W vector
-
-  
-        // // r1 = ptr_in + 1*COL/8 + aor*COL/8;
-        // // r2 = ptr_in + 2*COL/8 + aor*COL/8;
-        // data_buf1 = upd_w(data_buf1, 0, *r1++);
-        // data_buf1 = upd_w(data_buf1, 1, *r1);
-
-        // data_buf2 = upd_w(data_buf2, 0, *r2++);
-        // data_buf2 = upd_w(data_buf2, 1, *r2);
-
-        
-    // buf_2=R2 , and buf_1=R3
-        
-    for (unsigned i = 0; i < COL/8; i++)
-        chess_prepare_for_pipelining
-        chess_loop_range(1,)
-        {
-            v8int32  flux_sub;
-            v8int32  flux_interm_sub;
-            // printf("inside flux");
-            // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
-            ptr_forward = (v8int32 *) flux_inter1+2*i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-       
-            // compare > 0
-            unsigned int flx_compare_imj=gt16(concat(flux_interm_sub,undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-                        
-            // //Calculate final fly_ijm
-            v16int32 out_flx_inter1=select16(flx_compare_imj,concat(flux_sub,undef_v8int32()),null_v16int32()); 
-
-            //v16int32 flx_out1=add16(null_v16int32(),out_flx_inter1);     //still fly_ijm
-                
-    /////////////////////////////////////////////////////////////////////////////////////
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_inter2+2*i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-    
-            //Calculates final fly_ij (comparison > 0)
-            unsigned int flx_compare_ij=gt16(concat(flux_interm_sub,undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter2=select16(flx_compare_ij,concat(flux_sub,undef_v8int32()),null_v16int32());    
-
-            //add fly_ij - fly_ijm
-            v16int32 flx_out2=sub16(out_flx_inter2,out_flx_inter1);                             
-/////////////////////////////////////////////////////////////////////////////////////
-
-            /// retrieving flx_imj = lap_ij - lap_imj
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_inter3+2*i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-
-            //Calculates final flx_imj (comparison > 0)
-            unsigned int fly_compare_ijm=gt16(concat(flux_interm_sub,undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter3=select16(fly_compare_ijm,concat(flux_sub,undef_v8int32()),null_v16int32());
-
-            v16int32 flx_out3=sub16(flx_out2,out_flx_inter3);                     //adds fly_ij - fly_ijm - flx_imj
-/////////////////////////////////////////////////////////////////////////////////////
-             // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-             //re†rieving flx_ij = lap_ipj - lap_ij
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_inter4+2*i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-
-            // final flx_ij (comparison > 0 )
-            unsigned int fly_compare_ij=gt16(concat(flux_interm_sub,undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter4=select16(fly_compare_ij,concat(flux_sub,undef_v8int32()),null_v16int32()); 
-
-            v16int32 flx_out4=add16(flx_out3,out_flx_inter4); //adds fly_ij - fly_ijm - flx_imj + flx_ij
-            
-            ptr_forward = (v8int32 *) flux_inter5+2*i;
-            v8int32 tmp1 =*ptr_forward++;
-            v8int32 tmp2 = *ptr_forward;
-            data_buf2 = concat(tmp2,tmp1);
-
-            v8acc80 final_output = lmul8  (flx_out4, 0, 0x76543210, flux_out_coeff,    0,0x00000000);  // Multiply by -7s
-            final_output=lmac8(final_output, data_buf2,  2, 0x76543210,concat(coeffs1, undef_v8int32()), 0 , 0x76543210); 
-
-            // window_writeincr(out, srs(final_output,0));
-            *ptr_out++ =  srs(final_output,0);  
-                      
-        }
-    
-
+void hdiff_flux2(int32_t *restrict flux_inter1, int32_t *restrict flux_inter2,
+                 int32_t *restrict flux_inter3, int32_t *restrict flux_inter4,
+                 int32_t *restrict flux_inter5, int32_t *restrict out) {
+
+  alignas(32) int32_t weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) int32_t flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8int32 coeffs1 = *(v8int32 *)weights1; //  8 x int32 = 256b W vector
+  v8int32 flux_out_coeff = *(v8int32 *)flux_out;
+
+  // v8int32 * restrict  ptr_in = (v8int32 *) in;
+  v8int32 *restrict ptr_forward = (v8int32 *)flux_inter1;
+  v8int32 *ptr_out = (v8int32 *)out;
+
+  // v8int32 * restrict row0_ptr=(v8int32 *)row0;
+  // v8int32 * restrict row1_ptr=(v8int32 *)row1;
+  // v8int32 * restrict row2_ptr=(v8int32 *)row2;
+
+  // v16int32   data_buf1=null_v16int32();
+  v16int32 data_buf2 = null_v16int32();
+
+  v8acc80 acc_0 = null_v8acc80();
+  v8acc80 acc_1 = null_v8acc80();
+  //  8 x int32 = 256b W vector
+
+  // // r1 = ptr_in + 1*COL/8 + aor*COL/8;
+  // // r2 = ptr_in + 2*COL/8 + aor*COL/8;
+  // data_buf1 = upd_w(data_buf1, 0, *r1++);
+  // data_buf1 = upd_w(data_buf1, 1, *r1);
+
+  // data_buf2 = upd_w(data_buf2, 0, *r2++);
+  // data_buf2 = upd_w(data_buf2, 1, *r2);
+
+  // buf_2=R2 , and buf_1=R3
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v8int32 flux_sub;
+      v8int32 flux_interm_sub;
+      // printf("inside flux");
+      // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
+      ptr_forward = (v8int32 *)flux_inter1 + 2 * i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // compare > 0
+      unsigned int flx_compare_imj =
+          gt16(concat(flux_interm_sub, undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+
+      // //Calculate final fly_ijm
+      v16int32 out_flx_inter1 = select16(
+          flx_compare_imj, concat(flux_sub, undef_v8int32()), null_v16int32());
+
+      // v16int32 flx_out1=add16(null_v16int32(),out_flx_inter1);     //still
+      // fly_ijm
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_inter2 + 2 * i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // Calculates final fly_ij (comparison > 0)
+      unsigned int flx_compare_ij =
+          gt16(concat(flux_interm_sub, undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter2 = select16(
+          flx_compare_ij, concat(flux_sub, undef_v8int32()), null_v16int32());
+
+      // add fly_ij - fly_ijm
+      v16int32 flx_out2 = sub16(out_flx_inter2, out_flx_inter1);
+      /////////////////////////////////////////////////////////////////////////////////////
+
+      /// retrieving flx_imj = lap_ij - lap_imj
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_inter3 + 2 * i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // Calculates final flx_imj (comparison > 0)
+      unsigned int fly_compare_ijm =
+          gt16(concat(flux_interm_sub, undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter3 = select16(
+          fly_compare_ijm, concat(flux_sub, undef_v8int32()), null_v16int32());
+
+      v16int32 flx_out3 =
+          sub16(flx_out2, out_flx_inter3); // adds fly_ij - fly_ijm - flx_imj
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // re†rieving flx_ij = lap_ipj - lap_ij
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_inter4 + 2 * i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // final flx_ij (comparison > 0 )
+      unsigned int fly_compare_ij =
+          gt16(concat(flux_interm_sub, undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter4 = select16(
+          fly_compare_ij, concat(flux_sub, undef_v8int32()), null_v16int32());
+
+      v16int32 flx_out4 = add16(
+          flx_out3, out_flx_inter4); // adds fly_ij - fly_ijm - flx_imj + flx_ij
+
+      ptr_forward = (v8int32 *)flux_inter5 + 2 * i;
+      v8int32 tmp1 = *ptr_forward++;
+      v8int32 tmp2 = *ptr_forward;
+      data_buf2 = concat(tmp2, tmp1);
+
+      v8acc80 final_output = lmul8(flx_out4, 0, 0x76543210, flux_out_coeff, 0,
+                                   0x00000000); // Multiply by -7s
+      final_output = lmac8(final_output, data_buf2, 2, 0x76543210,
+                           concat(coeffs1, undef_v8int32()), 0, 0x76543210);
+
+      // window_writeincr(out, srs(final_output,0));
+      *ptr_out++ = srs(final_output, 0);
+    }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux2_fp32.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux2_fp32.cc
index b9181d2..e71dd6f 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux2_fp32.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_flux2_fp32.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,121 +9,132 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,  int32_t * restrict out)
+// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,
+// int32_t * restrict out)
 // {
-void hdiff_flux2_fp32(float* restrict flux_inter1,float* restrict flux_inter2, float* restrict flux_inter3,float* restrict flux_inter4,float* restrict flux_inter5, float * restrict out)
-{
-    
-    alignas(32) float weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) float flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8float coeffs1        = *(v8float*) weights1;  //  8 x int32 = 256b W vector
-    v8float flux_out_coeff = *(v8float*) flux_out;
-
-    // v8int32 * restrict  ptr_in = (v8int32 *) in;
-    v8float * restrict  ptr_forward = (v8float *) flux_inter1;
-    v8float * ptr_out = (v8float *) out;
-    
-
-
-    // v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    // v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    // v8int32 * restrict row2_ptr=(v8int32 *)row2;
-
-    // v16int32   data_buf1=null_v16int32();
-    v16float  data_buf2=null_v16float();
-
-    v8float acc_0 = null_v8float();
-    v8float acc_1 = null_v8float();
-          //  8 x int32 = 256b W vector
-
-  
-        // // r1 = ptr_in + 1*COL/8 + aor*COL/8;
-        // // r2 = ptr_in + 2*COL/8 + aor*COL/8;
-        // data_buf1 = upd_w(data_buf1, 0, *r1++);
-        // data_buf1 = upd_w(data_buf1, 1, *r1);
-
-        // data_buf2 = upd_w(data_buf2, 0, *r2++);
-        // data_buf2 = upd_w(data_buf2, 1, *r2);
-
-        
-    // buf_2=R2 , and buf_1=R3
-        
-    for (unsigned i = 0; i < COL/8; i++)
-        chess_prepare_for_pipelining
-        chess_loop_range(1,)
-        {
-            v8float  flux_sub;
-            v8float  flux_interm_sub;
-            // printf("inside flux");
-            // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
-            ptr_forward = (v8float *) flux_inter1+i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-       
-            // compare > 0
-            unsigned int flx_compare_imj=fpge (acc_1, null_v16float(), 0,0x76543210); /// flx_ijm * (test_in[d][c][r] - test_in[d][c][r-1]) > 0 ? 0 :
-                         
-            // //Calculate final fly_ijm
-            v16float out_flx_inter1=fpselect16(flx_compare_imj,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-                  
-            v8float flx_out1=fpadd(null_v8float(),out_flx_inter1,0,0x76543210);   //still fly_ijm
-
-    /////////////////////////////////////////////////////////////////////////////////////
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8float *) flux_inter2+i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-    
-            //Calculates final fly_ij (comparison > 0)
-            unsigned int flx_compare_ij=fpge (acc_1, null_v16float(), 0,0x76543210); 
-            v16float out_flx_inter2=fpselect16(flx_compare_ij,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-                        
-                //fly_ijm -fly_ij
-            v8float flx_out2=fpsub(flx_out1,out_flx_inter2,0,0x76543210);                          
-/////////////////////////////////////////////////////////////////////////////////////
-
-            /// retrieving flx_imj = lap_ij - lap_imj
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8float *) flux_inter3+i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-
-            //Calculates final flx_imj (comparison > 0)
-            unsigned int fly_compare_ijm=fpge (acc_1, null_v16float(), 0,0x76543210);
-            v16float out_flx_inter3=fpselect16(fly_compare_ijm,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-        
-            v8float flx_out3=fpadd(flx_out2,out_flx_inter3,0,0x76543210);     //adds fly_ijm -fly_ij + flx_imj 
-
-/////////////////////////////////////////////////////////////////////////////////////
-             // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-             //re†rieving flx_ij = lap_ipj - lap_ij
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8float *) flux_inter4+i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-
-            // final flx_ij (comparison > 0 )
-            unsigned int fly_compare_ij=fpge (acc_1, null_v16float(), 0,0x76543210);
-            v16float out_flx_inter4=fpselect16(fly_compare_ij,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-            
-            v8float flx_out4=fpsub(flx_out3,out_flx_inter4,0,0x76543210); //adds  fly_ijm -fly_ij + flx_imj -flx_ij
-            
-            ptr_forward = (v8float *) flux_inter5+i;
-            v8float tmp1 =*ptr_forward++;
-            v8float tmp2 = *ptr_forward;
-            data_buf2 = concat(tmp1,tmp2);
-
-            v8float   final_output=fpmul  (concat(flx_out4,null_v8float()),0,0x76543210,flux_out_coeff,    0,0x00000000);  // Multiply by +7s
-            final_output=fpmac(final_output,data_buf2,  2, 0x76543210,coeffs1, 0 , 0x76543210); 
-            // window_writeincr(out, srs(final_output,0));
-            *ptr_out++ =  final_output;  
-                      
-        }
-    
-
+void hdiff_flux2_fp32(float *restrict flux_inter1, float *restrict flux_inter2,
+                      float *restrict flux_inter3, float *restrict flux_inter4,
+                      float *restrict flux_inter5, float *restrict out) {
+
+  alignas(32) float weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) float flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8float coeffs1 = *(v8float *)weights1; //  8 x int32 = 256b W vector
+  v8float flux_out_coeff = *(v8float *)flux_out;
+
+  // v8int32 * restrict  ptr_in = (v8int32 *) in;
+  v8float *restrict ptr_forward = (v8float *)flux_inter1;
+  v8float *ptr_out = (v8float *)out;
+
+  // v8int32 * restrict row0_ptr=(v8int32 *)row0;
+  // v8int32 * restrict row1_ptr=(v8int32 *)row1;
+  // v8int32 * restrict row2_ptr=(v8int32 *)row2;
+
+  // v16int32   data_buf1=null_v16int32();
+  v16float data_buf2 = null_v16float();
+
+  v8float acc_0 = null_v8float();
+  v8float acc_1 = null_v8float();
+  //  8 x int32 = 256b W vector
+
+  // // r1 = ptr_in + 1*COL/8 + aor*COL/8;
+  // // r2 = ptr_in + 2*COL/8 + aor*COL/8;
+  // data_buf1 = upd_w(data_buf1, 0, *r1++);
+  // data_buf1 = upd_w(data_buf1, 1, *r1);
+
+  // data_buf2 = upd_w(data_buf2, 0, *r2++);
+  // data_buf2 = upd_w(data_buf2, 1, *r2);
+
+  // buf_2=R2 , and buf_1=R3
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v8float flux_sub;
+      v8float flux_interm_sub;
+      // printf("inside flux");
+      // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
+      ptr_forward = (v8float *)flux_inter1 + i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // compare > 0
+      unsigned int flx_compare_imj =
+          fpge(acc_1, null_v16float(), 0,
+               0x76543210); /// flx_ijm * (test_in[d][c][r] -
+                            /// test_in[d][c][r-1]) > 0 ? 0 :
+
+      // //Calculate final fly_ijm
+      v16float out_flx_inter1 = fpselect16(
+          flx_compare_imj, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      v8float flx_out1 =
+          fpadd(null_v8float(), out_flx_inter1, 0, 0x76543210); // still fly_ijm
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_inter2 + i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // Calculates final fly_ij (comparison > 0)
+      unsigned int flx_compare_ij = fpge(acc_1, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter2 = fpselect16(
+          flx_compare_ij, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      // fly_ijm -fly_ij
+      v8float flx_out2 = fpsub(flx_out1, out_flx_inter2, 0, 0x76543210);
+      /////////////////////////////////////////////////////////////////////////////////////
+
+      /// retrieving flx_imj = lap_ij - lap_imj
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_inter3 + i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // Calculates final flx_imj (comparison > 0)
+      unsigned int fly_compare_ijm =
+          fpge(acc_1, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter3 = fpselect16(
+          fly_compare_ijm, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      v8float flx_out3 = fpadd(flx_out2, out_flx_inter3, 0,
+                               0x76543210); // adds fly_ijm -fly_ij + flx_imj
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // re†rieving flx_ij = lap_ipj - lap_ij
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_inter4 + i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // final flx_ij (comparison > 0 )
+      unsigned int fly_compare_ij = fpge(acc_1, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter4 = fpselect16(
+          fly_compare_ij, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      v8float flx_out4 =
+          fpsub(flx_out3, out_flx_inter4, 0,
+                0x76543210); // adds  fly_ijm -fly_ij + flx_imj -flx_ij
+
+      ptr_forward = (v8float *)flux_inter5 + i;
+      v8float tmp1 = *ptr_forward++;
+      v8float tmp2 = *ptr_forward;
+      data_buf2 = concat(tmp1, tmp2);
+
+      v8float final_output =
+          fpmul(concat(flx_out4, null_v8float()), 0, 0x76543210, flux_out_coeff,
+                0, 0x00000000); // Multiply by +7s
+      final_output =
+          fpmac(final_output, data_buf2, 2, 0x76543210, coeffs1, 0, 0x76543210);
+      // window_writeincr(out, srs(final_output,0));
+      *ptr_out++ = final_output;
+    }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_lap.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_lap.cc
index 63a0ee7..6bcae3f 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_lap.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_lap.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,171 +9,194 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-//align to 16 bytes boundary, equivalent to "alignas(v4int32)"
-void hdiff_lap(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict row2,int32_t* restrict row3,int32_t* restrict row4, int32_t* restrict out_flux1, int32_t* restrict out_flux2, int32_t* restrict out_flux3, int32_t* restrict out_flux4 )
-{
-
- // const int32_t *restrict w = weights;
-    alignas(32) int32_t weights[8] = {-4,-4,-4,-4,-4,-4,-4,-4};
-    alignas(32) int32_t weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) int32_t weights_rest[8] = {-1,-1,-1,-1,-1,-1,-1,-1};
-    alignas(32) int32_t flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8int32 coeffs         = *(v8int32*) weights;  //  8 x int32 = 256b W vector
-    v8int32 coeffs1        = *(v8int32*) weights1;  //  8 x int32 = 256b W vector
-    v8int32 coeffs_rest    = *(v8int32*) weights_rest;  //  8 x int32 = 256b W vector
-    v8int32 flux_out_coeff = *(v8int32*) flux_out;
-
-    // v8int32 * restrict ptr_in = (v8int32 *) in;
-    v8int32 * ptr_out = (v8int32 *) out_flux1;
-    v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    v8int32 * restrict row2_ptr=(v8int32 *)row2;
-    v8int32 * restrict row3_ptr=(v8int32 *)row3;
-    v8int32 * restrict row4_ptr=(v8int32 *)row4;
-    v8int32 * restrict r1;
-    // v8int32 * restrict r2;
-    // v8int32 * restrict r2=ptr_in+1*COL/8;
-
-    v16int32 data_buf1 = null_v16int32();
-    v16int32 data_buf2 = null_v16int32();;
-    
-    v8acc80 acc_0 = null_v8acc80();
-    v8acc80 acc_1 = null_v8acc80();
-
-    //  v8acc80 acc_1=null_v8acc80();        
-    v8int32 lap_ij = null_v8int32();      //  8 x int32 = 256b W vector
-    v8int32 lap_0  = null_v8int32();      //  8 x int32 = 256b W vector
-
-
-
-        data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-        data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
-    
-        for (unsigned i = 0; i < COL/8; i++)
-            chess_prepare_for_pipelining
-                    chess_loop_range(1,)
-        {   
-            v16int32 flux_sub;
-
-            acc_0=lmul8   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);          //c           
-            acc_1=lmul8   (data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);          //b
-          
-            acc_0=lmac8   (acc_0,data_buf1,2,0x76543210,coeffs_rest,    0,0x00000000);    //c,k
-            acc_1=lmac8   (acc_1,data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);    //b,j
-          
-            // r2 = ptr_in+2 * COL/8+i ;
-            row2_ptr=((v8int32 *) (row2))+i;
-            data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
-
-            acc_0=lmac8   (acc_0,data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000); //c,k,f
-            acc_0=lmsc8   (acc_0,data_buf2,2,0x76543210,coeffs,    0,0x00000000);      //c,k,f,4*g
-            acc_0=lmac8   (acc_0,data_buf2,3,0x76543210,coeffs_rest,    0,0x00000000);  //c,k,f,4*g,h
-            
-            lap_ij=srs(acc_0,0); //store lap_ij
-
-            acc_1=lmac8   (acc_1,data_buf2,0,0x76543210,coeffs_rest,    0,0x00000000); //b,j,e
-            acc_1=lmsc8   (acc_1,data_buf2,1,0x76543210,coeffs,    0,0x00000000);      //b,j,e,4*f
-            acc_1=lmac8   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);  //b,j,e,4*f,g  
-           
-            //lap_ijm
-            lap_0=srs(acc_1,0);
-            
-            //Calculate  lap_ij - lap_ijm
-            flux_sub = sub16(concat(lap_ij,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_0,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 ); 
-            ptr_out = (v8int32 *) out_flux1+i;
-            *ptr_out =  ext_w(flux_sub,0);
-            //
-          
-            acc_0=lmul8   (data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);   // l
-            acc_0=lmsc8   (acc_0,data_buf2,3,0x76543210,coeffs,    0,0x00000000);  // l, 4*h
-        
-
-            // r1 = ptr_in+1 * COL/8+i ;
-            row1_ptr=((v8int32 *) (row1))+i;
-            data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));     
-
-            acc_0=lmac8  (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);  // l, 4*h, g
-            acc_0=lmac8   (acc_0,data_buf2,4,0x76543210,coeffs_rest,    0,0x00000000); // l, 4*h, g, i 
-
-                      
-            acc_0=lmac8   (acc_0,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);// l, 4*h, g, i, d 
-            
-            //Calculates lap_ijp
-            lap_0=srs(acc_0,0); 
-
-            //Calculates lap_ijp - lap_ij
-            flux_sub = sub16(concat(lap_0,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_ij,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 );
-            ptr_out= (v8int32 *) out_flux2+i;
-            *ptr_out=  ext_w(flux_sub,0);
-                 
-
-            //***********************************************************************STARTING X FLUX*****************************************************************************************************************************************************
-            
-            acc_1=lmul8    ( data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000); // g                     
-            acc_0=lmul8   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);   // g
-
-            // r2 = ptr_in + 0*COL/8 + i ; 
-            row0_ptr=((v8int32 *) (row0))+i;
-            data_buf2 = upd_w(data_buf2, 0, *(row0_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row0_ptr));
-                  
-            acc_1=lmsc8    (acc_1, data_buf1,2,0x76543210,coeffs,    0,0x00000000);             // g, 4*c
-            acc_1=lmac8    (acc_1, data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);        // g, 4*c, b
-            acc_1=lmac8   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);          // g, 4*c, b, a
-          
-            // r2 = ptr_in + 4*COL/8 + i ; 
-            row4_ptr=((v8int32 *) (row4))+i;
-            data_buf2 = upd_w(data_buf2, 0, *(row4_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row4_ptr));
-
-            acc_1=lmac8    ( acc_1,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b, a, d               
-            acc_0=lmac8   (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);         // g, m
-   
-            
-            //Calculates lap_imj
-            lap_0=srs(acc_1,0); 
-
-            flux_sub = sub16(concat(lap_ij,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_0,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 ); 
-            ptr_out= (v8int32 *) out_flux3+i;
-            *ptr_out =  ext_w(flux_sub,0);
-
-            
-            // r1 = ptr_in + 3*COL/8 + i ;
-            row3_ptr=((v8int32 *) (row3))+i;
-            data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
-
-            acc_0=lmsc8   (acc_0,data_buf1,2,0x76543210,coeffs,    0,0x00000000); //g, m , k * 4
-
-            // v16int32 flx_out3=sub16(flx_out2,out_flx_inter3);                     //adds fly_ij - fly_ijm - flx_imj
-
-            acc_0=lmac8   (acc_0,data_buf1, 1,0x76543210,coeffs_rest,    0,0x00000000);     //g, m , k * 4, j 
-            
-            //LOAD DATA FOR NEXT ITERATION
-            row1_ptr=((v8int32 *) (row1))+i+1;
-            data_buf2 = upd_w(data_buf2, 0, *(row1_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row1_ptr));
-
-            acc_0=lmac8   (acc_0,data_buf1, 3,0x76543210,coeffs_rest,    0,0x00000000);     //g, m , k * 4, j, l  
-
-            //  flx_ij = lap_ipj - lap_ij
-            flux_sub = sub16(concat(srs(acc_0,0),undef_v8int32()), 0, 0x76543210, 0xFEDCBA98, concat(lap_ij,undef_v8int32()),   0,  0x76543210, 0xFEDCBA98 ); 
-            ptr_out= (v8int32 *) out_flux4+i;
-            *ptr_out =  ext_w(flux_sub,0);
-
-             
-            //LOAD DATA FOR NEXT ITERATION
-            row3_ptr=((v8int32 *) (row3))+i+1;
-            data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
-
-        // }
-
+// align to 16 bytes boundary, equivalent to "alignas(v4int32)"
+void hdiff_lap(int32_t *restrict row0, int32_t *restrict row1,
+               int32_t *restrict row2, int32_t *restrict row3,
+               int32_t *restrict row4, int32_t *restrict out_flux1,
+               int32_t *restrict out_flux2, int32_t *restrict out_flux3,
+               int32_t *restrict out_flux4) {
+
+  // const int32_t *restrict w = weights;
+  alignas(32) int32_t weights[8] = {-4, -4, -4, -4, -4, -4, -4, -4};
+  alignas(32) int32_t weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) int32_t weights_rest[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
+  alignas(32) int32_t flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8int32 coeffs = *(v8int32 *)weights;           //  8 x int32 = 256b W vector
+  v8int32 coeffs1 = *(v8int32 *)weights1;         //  8 x int32 = 256b W vector
+  v8int32 coeffs_rest = *(v8int32 *)weights_rest; //  8 x int32 = 256b W vector
+  v8int32 flux_out_coeff = *(v8int32 *)flux_out;
+
+  // v8int32 * restrict ptr_in = (v8int32 *) in;
+  v8int32 *ptr_out = (v8int32 *)out_flux1;
+  v8int32 *restrict row0_ptr = (v8int32 *)row0;
+  v8int32 *restrict row1_ptr = (v8int32 *)row1;
+  v8int32 *restrict row2_ptr = (v8int32 *)row2;
+  v8int32 *restrict row3_ptr = (v8int32 *)row3;
+  v8int32 *restrict row4_ptr = (v8int32 *)row4;
+  v8int32 *restrict r1;
+  // v8int32 * restrict r2;
+  // v8int32 * restrict r2=ptr_in+1*COL/8;
+
+  v16int32 data_buf1 = null_v16int32();
+  v16int32 data_buf2 = null_v16int32();
+  ;
+
+  v8acc80 acc_0 = null_v8acc80();
+  v8acc80 acc_1 = null_v8acc80();
+
+  //  v8acc80 acc_1=null_v8acc80();
+  v8int32 lap_ij = null_v8int32(); //  8 x int32 = 256b W vector
+  v8int32 lap_0 = null_v8int32();  //  8 x int32 = 256b W vector
+
+  data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+  data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v16int32 flux_sub;
+
+      acc_0 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // c
+      acc_1 = lmul8(data_buf2, 1, 0x76543210, coeffs_rest, 0, 0x00000000); // b
+
+      acc_0 = lmac8(acc_0, data_buf1, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k
+      acc_1 = lmac8(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j
+
+      // r2 = ptr_in+2 * COL/8+i ;
+      row2_ptr = ((v8int32 *)(row2)) + i;
+      data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
+
+      acc_0 = lmac8(acc_0, data_buf2, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k,f
+      acc_0 = lmsc8(acc_0, data_buf2, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // c,k,f,4*g
+      acc_0 = lmac8(acc_0, data_buf2, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k,f,4*g,h
+
+      lap_ij = srs(acc_0, 0); // store lap_ij
+
+      acc_1 = lmac8(acc_1, data_buf2, 0, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j,e
+      acc_1 = lmsc8(acc_1, data_buf2, 1, 0x76543210, coeffs, 0,
+                    0x00000000); // b,j,e,4*f
+      acc_1 = lmac8(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j,e,4*f,g
+
+      // lap_ijm
+      lap_0 = srs(acc_1, 0);
+
+      // Calculate  lap_ij - lap_ijm
+      flux_sub =
+          sub16(concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+      ptr_out = (v8int32 *)out_flux1 + i;
+      *ptr_out = ext_w(flux_sub, 0);
+      //
+
+      acc_0 = lmul8(data_buf1, 3, 0x76543210, coeffs_rest, 0, 0x00000000); // l
+      acc_0 = lmsc8(acc_0, data_buf2, 3, 0x76543210, coeffs, 0,
+                    0x00000000); // l, 4*h
+
+      // r1 = ptr_in+1 * COL/8+i ;
+      row1_ptr = ((v8int32 *)(row1)) + i;
+      data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));
+
+      acc_0 = lmac8(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g
+      acc_0 = lmac8(acc_0, data_buf2, 4, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g, i
+
+      acc_0 = lmac8(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g, i, d
+
+      // Calculates lap_ijp
+      lap_0 = srs(acc_0, 0);
+
+      // Calculates lap_ijp - lap_ij
+      flux_sub =
+          sub16(concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+      ptr_out = (v8int32 *)out_flux2 + i;
+      *ptr_out = ext_w(flux_sub, 0);
+
+      //***********************************************************************STARTING
+      //X
+      //FLUX*****************************************************************************************************************************************************
+
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+      acc_0 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+
+      // r2 = ptr_in + 0*COL/8 + i ;
+      row0_ptr = ((v8int32 *)(row0)) + i;
+      data_buf2 = upd_w(data_buf2, 0, *(row0_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row0_ptr));
+
+      acc_1 = lmsc8(acc_1, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, 4*c
+      acc_1 = lmac8(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b
+      acc_1 = lmac8(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a
+
+      // r2 = ptr_in + 4*COL/8 + i ;
+      row4_ptr = ((v8int32 *)(row4)) + i;
+      data_buf2 = upd_w(data_buf2, 0, *(row4_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row4_ptr));
+
+      acc_1 = lmac8(acc_1, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a, d
+      acc_0 = lmac8(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m
+
+      // Calculates lap_imj
+      lap_0 = srs(acc_1, 0);
+
+      flux_sub =
+          sub16(concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+      ptr_out = (v8int32 *)out_flux3 + i;
+      *ptr_out = ext_w(flux_sub, 0);
+
+      // r1 = ptr_in + 3*COL/8 + i ;
+      row3_ptr = ((v8int32 *)(row3)) + i;
+      data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
+
+      acc_0 = lmsc8(acc_0, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, m , k * 4
+
+      // v16int32 flx_out3=sub16(flx_out2,out_flx_inter3); //adds fly_ij -
+      // fly_ijm - flx_imj
+
+      acc_0 = lmac8(acc_0, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m , k * 4, j
+
+      // LOAD DATA FOR NEXT ITERATION
+      row1_ptr = ((v8int32 *)(row1)) + i + 1;
+      data_buf2 = upd_w(data_buf2, 0, *(row1_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row1_ptr));
+
+      acc_0 = lmac8(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m , k * 4, j, l
+
+      //  flx_ij = lap_ipj - lap_ij
+      flux_sub = sub16(concat(srs(acc_0, 0), undef_v8int32()), 0, 0x76543210,
+                       0xFEDCBA98, concat(lap_ij, undef_v8int32()), 0,
+                       0x76543210, 0xFEDCBA98);
+      ptr_out = (v8int32 *)out_flux4 + i;
+      *ptr_out = ext_w(flux_sub, 0);
+
+      // LOAD DATA FOR NEXT ITERATION
+      row3_ptr = ((v8int32 *)(row3)) + i + 1;
+      data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
+
+      // }
     }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_lap_fp32.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_lap_fp32.cc
index c134825..dbc760e 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_lap_fp32.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/hdiff_lap_fp32.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,168 +9,182 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-//align to 16 bytes boundary, equivalent to "alignas(v4int32)"
-void hdiff_lap_fp32(float* restrict row0, float* restrict row1,float* restrict row2,float* restrict row3,float* restrict row4, float* restrict out_flux1, float* restrict out_flux2, float* restrict out_flux3, float* restrict out_flux4 )
-{
-
- // const float *restrict w = weights;
-    alignas(32) float weights[8] = {-4,-4,-4,-4,-4,-4,-4,-4};
-    alignas(32) float weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) float weights_rest[8] = {-1,-1,-1,-1,-1,-1,-1,-1};
-    alignas(32) float flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8float coeffs         = *(v8float*) weights;  //  8 x int32 = 256b W vector
-    v8float coeffs1        = *(v8float*) weights1;  //  8 x int32 = 256b W vector
-    v8float coeffs_rest    = *(v8float*) weights_rest;  //  8 x int32 = 256b W vector
-    v8float flux_out_coeff = *(v8float*) flux_out;
-
-    // v8float * restrict ptr_in = (v8float *) in;
-    v8float * ptr_out = (v8float *) out_flux1;
-    v8float * restrict row0_ptr=(v8float *)row0;
-    v8float * restrict row1_ptr=(v8float *)row1;
-    v8float * restrict row2_ptr=(v8float *)row2;
-    v8float * restrict row3_ptr=(v8float *)row3;
-    v8float * restrict row4_ptr=(v8float *)row4;
-    v8float * restrict r1;
-    // v8float * restrict r2=ptr_in+1*COL/8;
-
-    v16float   data_buf1=null_v16float();
-    v16float  data_buf2=null_v16float();
-    
-    v8float acc_0 = null_v8float();
-    v8float acc_1 = null_v8float();
-
-    //  v8acc80 acc_1=null_v8acc80();        
-    v8float lap_ij = null_v8float();      //  8 x int32 = 256b W vector
-    v8float lap_0  = null_v8float();      //  8 x int32 = 256b W vector
-
-
-
-        data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-        data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
-    
-        for (unsigned i = 0; i < COL/8; i++)
-            chess_prepare_for_pipelining
-                    chess_loop_range(1,)
-        {   
-            v8float flux_sub;
-
-            lap_ij=fpmul (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///  //c            
-            acc_1=fpmul(data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);        //b
-          
-            lap_ij=fpmac   (lap_ij,data_buf1,2,0x76543210,coeffs_rest,    0,0x00000000);///  //c,k 
-            acc_1=fpmac   (acc_1,data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);///  //b,j
-          
-            // r2 = ptr_in+2 * COL/8+i ;
-            row2_ptr=((v8float *) (row2))+i;
-            data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
-
-            ///////// **************************LAP_ij**************************************
-            lap_ij=fpmac   (lap_ij,data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);///  //c,k,f
-            lap_ij=fpmsc   (lap_ij,data_buf2,2,0x76543210,coeffs,    0,0x00000000);///  //c,k,f,4*g
-            lap_ij=fpmac   (lap_ij,data_buf2,3,0x76543210,coeffs_rest,    0,0x00000000);///  c,k,f,4*g,h
-        
-                ///////// **************************LAP_ijm**************************************               
-            acc_1=fpmac   (acc_1,data_buf2,0,0x76543210,coeffs_rest,    0,0x00000000);///  //b,j,e         
-            acc_1=fpmsc   (acc_1,data_buf2,1,0x76543210,coeffs,    0,0x00000000);///         //b,j,e,4*f   
-            acc_1=fpmac   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///     //b,j,e,4*f,g   
-        
-            //Calculate  lap_ij - lap_ijm
-            flux_sub = fpsub(lap_ij, concat(acc_1,undef_v8float()), 0, 0x76543210); // flx_imj = lap_ij - lap_ijm;
-            ptr_out = (v8float *) out_flux1+i;
-            *ptr_out =  flux_sub;
-            //
-          
-            acc_0=fpmul   (data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);/// // l ; R1 is already loaded
-            acc_0=fpmsc   (acc_0,data_buf2,3,0x76543210,coeffs,    0,0x00000000);///   // l, 4*h
-        
-
-            // r1 = ptr_in+1 * COL/8+i ;
-            row1_ptr=((v8float *) (row1))+i;
-            data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));    
-
-            acc_0=fpmac  (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///  lap_ijp // l, 4*h, g
-            acc_0=fpmac   (acc_0,data_buf2,4,0x76543210,coeffs_rest,    0,0x00000000);///  l, 4*h, g, i   
-
-                      
-            acc_0=fpmac   (acc_0,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);///  // l, 4*h, g, i, d  
-
-            flux_sub = fpsub(acc_0, concat(lap_ij,undef_v8float()), 0, 0x76543210); 
-            ptr_out= (v8float *) out_flux2+i;
-            *ptr_out=  flux_sub;
-                 
-
-          
-            acc_1=fpmul    ( data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);        // g                
-            acc_0=fpmul   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);// g   
-
-            // r2 = ptr_in + 0*COL/8 + i ; 
-            row0_ptr=((v8float *) (row0))+i;
-            // r2 = ptr_in + 0*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm 
-            data_buf2 = upd_w(data_buf2, 0, *row0_ptr++);
-            data_buf2 = upd_w(data_buf2, 1, *row0_ptr);
-                
-            acc_1=fpmsc    (acc_1, data_buf1,2,0x76543210,coeffs,    0,0x00000000);      // g, 4*c
-            acc_1=fpmac    (acc_1, data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b
-            acc_1=fpmac   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);/// // g, 4*c, b, a
-          
-            // r2 = ptr_in + 4*COL/8 + i ; 
-            row4_ptr=((v8float *) (row4))+i;
-            // r2 = ptr_in + 4*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm 
-            data_buf2 = upd_w(data_buf2, 0, *row4_ptr++);
-            data_buf2 = upd_w(data_buf2, 1, *row4_ptr);
-                //////// **************************LAP_ipj for fly_ij since r2=R4********
-            acc_1=fpmac    ( acc_1,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b, a, d  
-            acc_0=fpmac   (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///   // g, m
-
-            
-            // //Calculates lap_imj
-            // lap_0=srs(acc_1,0); 
-
-            flux_sub = fpsub(lap_ij, concat(acc_1,undef_v8float()), 0, 0x76543210); 
-            ptr_out= (v8float *) out_flux3+i;
-            *ptr_out =  flux_sub;
-
-            
-            // r1 = ptr_in + 3*COL/8 + i ;
-            row3_ptr=((v8float *) (row3))+i;
-            // r1 = ptr_in + 3*COL/8 + i + aor*COL/8; // load for LAP_ijp for fly_ij
-            // data_buf1=*r1++;
-            data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-            data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-
-            acc_0=fpmsc   (acc_0,data_buf1,2,0x76543210,coeffs,    0,0x00000000);///  //g, m , k * 4
-
-            // v16int32 flx_out3=sub16(flx_out2,out_flx_inter3);                     //adds fly_ij - fly_ijm - flx_imj
-
-            acc_0=fpmac   (acc_0,data_buf1, 1,0x76543210,coeffs_rest,    0,0x00000000);///  //g, m , k * 4, j   
-           
-           //LOAD DATA FOR NEXT ITERATION
-            // r2 = ptr_in + 1*COL/8 + i + 1 ;
-            row1_ptr=((v8float *) (row1))+i+1;
-            data_buf2 = upd_w(data_buf2, 0, *(row1_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row1_ptr));
-            acc_0=fpmac   (acc_0,data_buf1, 3,0x76543210,coeffs_rest,    0,0x00000000);///   //g, m , k * 4, j, l 
-           
-
-            //  flx_ij = lap_ipj - lap_ij
-            flux_sub = fpsub(acc_0, concat(lap_ij,undef_v8float()), 0, 0x76543210);
-            ptr_out= (v8float *) out_flux4+i;
-            *ptr_out =  flux_sub;
-
-             //LOAD DATA FOR NEXT ITERATION
-            row3_ptr=((v8float *) (row3))+i+1;
-            data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
-             
-            
-
-        // }
-
+// align to 16 bytes boundary, equivalent to "alignas(v4int32)"
+void hdiff_lap_fp32(float *restrict row0, float *restrict row1,
+                    float *restrict row2, float *restrict row3,
+                    float *restrict row4, float *restrict out_flux1,
+                    float *restrict out_flux2, float *restrict out_flux3,
+                    float *restrict out_flux4) {
+
+  // const float *restrict w = weights;
+  alignas(32) float weights[8] = {-4, -4, -4, -4, -4, -4, -4, -4};
+  alignas(32) float weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) float weights_rest[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
+  alignas(32) float flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8float coeffs = *(v8float *)weights;           //  8 x int32 = 256b W vector
+  v8float coeffs1 = *(v8float *)weights1;         //  8 x int32 = 256b W vector
+  v8float coeffs_rest = *(v8float *)weights_rest; //  8 x int32 = 256b W vector
+  v8float flux_out_coeff = *(v8float *)flux_out;
+
+  // v8float * restrict ptr_in = (v8float *) in;
+  v8float *ptr_out = (v8float *)out_flux1;
+  v8float *restrict row0_ptr = (v8float *)row0;
+  v8float *restrict row1_ptr = (v8float *)row1;
+  v8float *restrict row2_ptr = (v8float *)row2;
+  v8float *restrict row3_ptr = (v8float *)row3;
+  v8float *restrict row4_ptr = (v8float *)row4;
+  v8float *restrict r1;
+  // v8float * restrict r2=ptr_in+1*COL/8;
+
+  v16float data_buf1 = null_v16float();
+  v16float data_buf2 = null_v16float();
+
+  v8float acc_0 = null_v8float();
+  v8float acc_1 = null_v8float();
+
+  //  v8acc80 acc_1=null_v8acc80();
+  v8float lap_ij = null_v8float(); //  8 x int32 = 256b W vector
+  v8float lap_0 = null_v8float();  //  8 x int32 = 256b W vector
+
+  data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+  data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v8float flux_sub;
+
+      lap_ij =
+          fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); ///  //c
+      acc_1 = fpmul(data_buf2, 1, 0x76543210, coeffs_rest, 0, 0x00000000); // b
+
+      lap_ij = fpmac(lap_ij, data_buf1, 2, 0x76543210, coeffs_rest, 0,
+                     0x00000000); ///  //c,k
+      acc_1 = fpmac(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //b,j
+
+      // r2 = ptr_in+2 * COL/8+i ;
+      row2_ptr = ((v8float *)(row2)) + i;
+      data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
+
+      /////////
+      ///**************************LAP_ij**************************************
+      lap_ij = fpmac(lap_ij, data_buf2, 1, 0x76543210, coeffs_rest, 0,
+                     0x00000000); ///  //c,k,f
+      lap_ij = fpmsc(lap_ij, data_buf2, 2, 0x76543210, coeffs, 0,
+                     0x00000000); ///  //c,k,f,4*g
+      lap_ij = fpmac(lap_ij, data_buf2, 3, 0x76543210, coeffs_rest, 0,
+                     0x00000000); ///  c,k,f,4*g,h
+
+      /////////
+      ///**************************LAP_ijm**************************************
+      acc_1 = fpmac(acc_1, data_buf2, 0, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //b,j,e
+      acc_1 = fpmsc(acc_1, data_buf2, 1, 0x76543210, coeffs, 0,
+                    0x00000000); ///         //b,j,e,4*f
+      acc_1 = fpmac(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///     //b,j,e,4*f,g
+
+      // Calculate  lap_ij - lap_ijm
+      flux_sub = fpsub(lap_ij, concat(acc_1, undef_v8float()), 0,
+                       0x76543210); // flx_imj = lap_ij - lap_ijm;
+      ptr_out = (v8float *)out_flux1 + i;
+      *ptr_out = flux_sub;
+      //
+
+      acc_0 = fpmul(data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); /// // l ; R1 is already loaded
+      acc_0 = fpmsc(acc_0, data_buf2, 3, 0x76543210, coeffs, 0,
+                    0x00000000); ///   // l, 4*h
+
+      // r1 = ptr_in+1 * COL/8+i ;
+      row1_ptr = ((v8float *)(row1)) + i;
+      data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));
+
+      acc_0 = fpmac(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  lap_ijp // l, 4*h, g
+      acc_0 = fpmac(acc_0, data_buf2, 4, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  l, 4*h, g, i
+
+      acc_0 = fpmac(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  // l, 4*h, g, i, d
+
+      flux_sub = fpsub(acc_0, concat(lap_ij, undef_v8float()), 0, 0x76543210);
+      ptr_out = (v8float *)out_flux2 + i;
+      *ptr_out = flux_sub;
+
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+      acc_0 = fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+
+      // r2 = ptr_in + 0*COL/8 + i ;
+      row0_ptr = ((v8float *)(row0)) + i;
+      // r2 = ptr_in + 0*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm
+      data_buf2 = upd_w(data_buf2, 0, *row0_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row0_ptr);
+
+      acc_1 = fpmsc(acc_1, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, 4*c
+      acc_1 = fpmac(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b
+      acc_1 = fpmac(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); /// // g, 4*c, b, a
+
+      // r2 = ptr_in + 4*COL/8 + i ;
+      row4_ptr = ((v8float *)(row4)) + i;
+      // r2 = ptr_in + 4*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm
+      data_buf2 = upd_w(data_buf2, 0, *row4_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row4_ptr);
+      //////// **************************LAP_ipj for fly_ij since r2=R4********
+      acc_1 = fpmac(acc_1, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a, d
+      acc_0 = fpmac(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///   // g, m
+
+      // //Calculates lap_imj
+      // lap_0=srs(acc_1,0);
+
+      flux_sub = fpsub(lap_ij, concat(acc_1, undef_v8float()), 0, 0x76543210);
+      ptr_out = (v8float *)out_flux3 + i;
+      *ptr_out = flux_sub;
+
+      // r1 = ptr_in + 3*COL/8 + i ;
+      row3_ptr = ((v8float *)(row3)) + i;
+      // r1 = ptr_in + 3*COL/8 + i + aor*COL/8; // load for LAP_ijp for fly_ij
+      // data_buf1=*r1++;
+      data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+
+      acc_0 = fpmsc(acc_0, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); ///  //g, m , k * 4
+
+      // v16int32 flx_out3=sub16(flx_out2,out_flx_inter3); //adds fly_ij -
+      // fly_ijm - flx_imj
+
+      acc_0 = fpmac(acc_0, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //g, m , k * 4, j
+
+      // LOAD DATA FOR NEXT ITERATION
+      //  r2 = ptr_in + 1*COL/8 + i + 1 ;
+      row1_ptr = ((v8float *)(row1)) + i + 1;
+      data_buf2 = upd_w(data_buf2, 0, *(row1_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row1_ptr));
+      acc_0 = fpmac(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///   //g, m , k * 4, j, l
+
+      //  flx_ij = lap_ipj - lap_ij
+      flux_sub = fpsub(acc_0, concat(lap_ij, undef_v8float()), 0, 0x76543210);
+      ptr_out = (v8float *)out_flux4 + i;
+      *ptr_out = flux_sub;
+
+      // LOAD DATA FOR NEXT ITERATION
+      row3_ptr = ((v8float *)(row3)) + i + 1;
+      data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
+
+      // }
     }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/include.h b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/include.h
index 6ab94ff..e74fe84 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/include.h
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/include.h
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -11,43 +11,43 @@
 // #define  MULTI_4x4
 // #include <adf.h>
 #include <stdint.h>
-#define GRIDROW     256
-#define GRIDCOL     256
-#define GRIDDEPTH   1
-#define TOTAL_INPUT GRIDROW*GRIDCOL*GRIDDEPTH
-
-#define ROW			256
-#define COL			256
-#define TILE_SIZE  COL
+#define GRIDROW 256
+#define GRIDCOL 256
+#define GRIDDEPTH 1
+#define TOTAL_INPUT GRIDROW *GRIDCOL *GRIDDEPTH
 
-#define WMARGIN     256       // Margin before the frame
+#define ROW 256
+#define COL 256
+#define TILE_SIZE COL
 
+#define WMARGIN 256 // Margin before the frame
 
-#define NBYTES		4		// datatype byte-width
+#define NBYTES 4 // datatype byte-width
 
-#define AVAIL_CORES 25*25
+#define AVAIL_CORES 25 * 25
 
-#define CORE_REQUIRED TOTAL_INPUT/TILE_SIZE
+#define CORE_REQUIRED TOTAL_INPUT / TILE_SIZE
 
 #ifdef MULTI_CORE
-    #ifdef  MULTI_2x2
-        #define HW_ROW 2
-        #define HW_COL 2
-    #else 
-        #define HW_ROW 4
-        #define HW_COL 4
-    #endif
-
-    #define USED_CORE HW_ROW*HW_COL
-    #define NITER    TOTAL_INPUT/(USED_CORE*TILE_SIZE)   // Number of iteration
+#ifdef MULTI_2x2
+#define HW_ROW 2
+#define HW_COL 2
+#else
+#define HW_ROW 4
+#define HW_COL 4
+#endif
+
+#define USED_CORE HW_ROW *HW_COL
+#define NITER TOTAL_INPUT / (USED_CORE * TILE_SIZE) // Number of iteration
 #else
 
-#define NITER    TOTAL_INPUT/(TILE_SIZE)    // Number of iteration
+#define NITER TOTAL_INPUT / (TILE_SIZE) // Number of iteration
 #endif
 
 #ifdef WITH_MARGIN
-#define INPUT_FILE "./data/TestInputS.txt"    // Input file name and location
+#define INPUT_FILE "./data/TestInputS.txt" // Input file name and location
 #else
-#define INPUT_FILE "./data/dataset_256x256x64.txt"    // Input file name and location
+#define INPUT_FILE                                                             \
+  "./data/dataset_256x256x64.txt" // Input file name and location
 #endif
-#define OUTPUT_FILE "./data/TestOutputS.txt"    // Output file name and location
\ No newline at end of file
+#define OUTPUT_FILE "./data/TestOutputS.txt" // Output file name and location
\ No newline at end of file
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/test.cpp b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/test.cpp
index 6a2a77e..5c42cfa 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/test.cpp
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong/test.cpp
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -13,9 +13,9 @@
 #include <stdlib.h>
 #include <sys/mman.h>
 #include <thread>
+#include <time.h>
 #include <unistd.h>
 #include <xaiengine.h>
-#include <time.h>  
 #define HIGH_ADDR(addr) ((addr & 0xffffffff00000000) >> 32)
 #define LOW_ADDR(addr) (addr & 0x00000000ffffffff)
 #define MLIR_STACK_OFFSET 4096
@@ -24,7 +24,7 @@
 
 int main(int argc, char *argv[]) {
   printf("test start.\n");
-  clock_t t; 
+  clock_t t;
 
   aie_libxaie_ctx_t *_xaie = mlir_aie_init_libxaie();
   mlir_aie_init_device(_xaie);
@@ -37,7 +37,7 @@ int main(int argc, char *argv[]) {
   mlir_aie_clear_tile_memory(_xaie, 7, 3);
   mlir_aie_clear_tile_memory(_xaie, 7, 2);
   mlir_aie_clear_tile_memory(_xaie, 7, 1);
-//   mlir_aie_clear_tile_memory(_xaie, 6, 4);
+  //   mlir_aie_clear_tile_memory(_xaie, 6, 4);
   mlir_aie_configure_cores(_xaie);
 
   usleep(sleep_u);
@@ -47,13 +47,13 @@ int main(int argc, char *argv[]) {
 
   mlir_aie_acquire_lock(_xaie, 7, 1, 14, 0, 0); // for timing
   // When lock 14 is acquired, we broadcast event 2 from tile t73
-  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(7,1), 
-                        XAIE_MEM_MOD, 2,
-                        XAIE_EVENT_LOCK_14_ACQ_MEM); 
-  // we use broadcast event 2 at tile t75 to start the timer, and the local event lock 14 acquire to stop the timer
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(7, 1), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  // we use broadcast event 2 at tile t75 to start the timer, and the local
+  // event lock 14 acquire to stop the timer
   EventMonitor pc0(_xaie, 7, 3, 0, XAIE_EVENT_BROADCAST_2_MEM,
-                 XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
-                 XAIE_MEM_MOD);
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
   pc0.set();
 
   usleep(sleep_u);
@@ -66,38 +66,39 @@ int main(int argc, char *argv[]) {
 #define DMA_COUNT 1536
   int *ddr_ptr_in = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT);
   int *ddr_ptr_out = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT);
-//   int *mem_ptr2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT);
-//   int *mem_ptr3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT);
-//   int *mem_ptr4 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT);
-//   int *mem_ptr5 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT);
-//   int *mem_ptr6 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT);
-//   int *mem_ptr7 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT);
+  //   int *mem_ptr2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT);
+  //   int *mem_ptr3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT);
+  //   int *mem_ptr4 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT);
+  //   int *mem_ptr5 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT);
+  //   int *mem_ptr6 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT);
+  //   int *mem_ptr7 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT);
 
   // initialize the external buffers
   for (int i = 0; i < DMA_COUNT; i++) {
-    *(ddr_ptr_in + i) = i;  // input
+    *(ddr_ptr_in + i) = i; // input
     *(ddr_ptr_out + i) = 0;
   }
 
   mlir_aie_sync_mem_dev(_xaie, 0); // only used in libaiev2
   mlir_aie_sync_mem_dev(_xaie, 1); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 2); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 3); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 4); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 5); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 6); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 7); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 2); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 3); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 4); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 5); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 6); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 7); // only used in libaiev2
 
 #ifdef LIBXAIENGINEV2
-  mlir_aie_external_set_addr_ddr_test_buffer_in0((u64)ddr_ptr_in); // external set address
+  mlir_aie_external_set_addr_ddr_test_buffer_in0(
+      (u64)ddr_ptr_in); // external set address
   mlir_aie_external_set_addr_ddr_test_buffer_out((u64)ddr_ptr_out);
-//   mlir_aie_external_set_addr_RHS_tile0((u64)mem_ptr2);
-//   mlir_aie_external_set_addr_RHS_tile1((u64)mem_ptr3);
-//   mlir_aie_external_set_addr_RHS_tile2((u64)mem_ptr4);
-//   mlir_aie_external_set_addr_RHS_tile3((u64)mem_ptr5);
-//   mlir_aie_external_set_addr_Out_tile0((u64)mem_ptr6);
-//   mlir_aie_external_set_addr_Out_tile1((u64)mem_ptr7);
-//   mlir_aie_configure_shimdma_60(_xaie);
+  //   mlir_aie_external_set_addr_RHS_tile0((u64)mem_ptr2);
+  //   mlir_aie_external_set_addr_RHS_tile1((u64)mem_ptr3);
+  //   mlir_aie_external_set_addr_RHS_tile2((u64)mem_ptr4);
+  //   mlir_aie_external_set_addr_RHS_tile3((u64)mem_ptr5);
+  //   mlir_aie_external_set_addr_Out_tile0((u64)mem_ptr6);
+  //   mlir_aie_external_set_addr_Out_tile1((u64)mem_ptr7);
+  //   mlir_aie_configure_shimdma_60(_xaie);
   mlir_aie_configure_shimdma_70(_xaie);
 //   mlir_aie_configure_shimdma_100(_xaie);
 #endif
@@ -105,22 +106,18 @@ int main(int argc, char *argv[]) {
   printf("before core start\n");
   mlir_aie_print_tile_status(_xaie, 7, 3);
 
-  
-  
-
-
   printf("Release lock for accessing DDR.\n");
   mlir_aie_release_of_0_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_6_lock_0(_xaie, 0, 0);
 
   printf("Start cores\n");
   ///// --- start counter-----
-  t = clock(); 
+  t = clock();
   mlir_aie_start_cores(_xaie);
   mlir_aie_release_lock(_xaie, 7, 1, 14, 0, 0); // for timing
-  t = clock() - t; 
+  t = clock() - t;
 
-  printf ("It took %ld clicks (%f seconds).\n",t,((float)t)/CLOCKS_PER_SEC);
+  printf("It took %ld clicks (%f seconds).\n", t, ((float)t) / CLOCKS_PER_SEC);
 
   usleep(sleep_u);
   printf("after core start\n");
@@ -128,15 +125,15 @@ int main(int argc, char *argv[]) {
 
   usleep(sleep_u);
 
+  //   mlir_aie_acquire_of_17_lock_0(_xaie, 1, 0);
+  //   mlir_aie_acquire_of_15_lock_0(_xaie, 1, 0);
 
-//   mlir_aie_acquire_of_17_lock_0(_xaie, 1, 0);
-//   mlir_aie_acquire_of_15_lock_0(_xaie, 1, 0);
- 
-  mlir_aie_sync_mem_cpu(_xaie, 1); // only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        1); // only used in libaiev2 //sync up with output
   ///// --- end counter-----
-  for (int i =0; i < 256; i ++ ){
-        printf("Location %d:  %d\n", i, ddr_ptr_out[i]);
-    }
+  for (int i = 0; i < 256; i++) {
+    printf("Location %d:  %d\n", i, ddr_ptr_out[i]);
+  }
 
   int res = 0;
   if (!errors) {
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/chess_main.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/chess_main.cc
index f1d5093..f4ee1b5 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/chess_main.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/chess_main.cc
@@ -1,19 +1,18 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
 #include "hdiff.h"
 
-int main()
-{
-    int32_t din1[10] = {};
-    int32_t din2[10] = {};
-    int32_t din3[10] = {};
-    int32_t din4[10] = {};
-    int32_t din5[10] = {};
-    int32_t dout[10] = {};
-    vec_hdiff(din1,din2,din3, din4, din5,  dout); 
-    return 1;
+int main() {
+  int32_t din1[10] = {};
+  int32_t din2[10] = {};
+  int32_t din3[10] = {};
+  int32_t din4[10] = {};
+  int32_t din5[10] = {};
+  int32_t dout[10] = {};
+  vec_hdiff(din1, din2, din3, din4, din5, dout);
+  return 1;
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/cpp_dump.cpp b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/cpp_dump.cpp
index dd67664..16e0373 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/cpp_dump.cpp
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/cpp_dump.cpp
@@ -1,10 +1,9 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-    
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-
 #include "test_library.h"
 #include <cassert>
 #include <cmath>
@@ -14,23 +13,23 @@
 #include <stdlib.h>
 #include <sys/mman.h>
 #include <thread>
+#include <time.h>
 #include <unistd.h>
 #include <xaiengine.h>
-#include <time.h>  
 #define HIGH_ADDR(addr) ((addr & 0xffffffff00000000) >> 32)
 #define LOW_ADDR(addr) (addr & 0x00000000ffffffff)
 #define MLIR_STACK_OFFSET 4096
-#define B_BLOCK_DEPTH 4 //set how many rows
-#define HDIFF_COL 3 //columns
+#define B_BLOCK_DEPTH 4 // set how many rows
+#define HDIFF_COL 3     // columns
 #define START_ROW 1
-#define INPUT_ROWS 9   
-    
-    #define TOTAL_B_BLOCK 4
- #include "aie_inc.cpp"
+#define INPUT_ROWS 9
+
+#define TOTAL_B_BLOCK 4
+#include "aie_inc.cpp"
 
 int main(int argc, char *argv[]) {
   printf("test start.");
-  clock_t t; 
+  clock_t t;
 
   aie_libxaie_ctx_t *_xaie = mlir_aie_init_libxaie();
   mlir_aie_init_device(_xaie);
@@ -38,15 +37,14 @@ int main(int argc, char *argv[]) {
   u32 sleep_u = 100000;
   usleep(sleep_u);
   printf("before configure cores.");
-   for (int b=0; b<TOTAL_B_BLOCK;b++)
-  {
-    for (int i=0; i<HDIFF_COL;i++){
-      for (int j=START_ROW; j<START_ROW+B_BLOCK_DEPTH;j++)
+  for (int b = 0; b < TOTAL_B_BLOCK; b++) {
+    for (int i = 0; i < HDIFF_COL; i++) {
+      for (int j = START_ROW; j < START_ROW + B_BLOCK_DEPTH; j++)
         mlir_aie_clear_tile_memory(_xaie, i, j);
     }
   }
 
-//   mlir_aie_clear_tile_memory(_xaie, 6, 4);
+  //   mlir_aie_clear_tile_memory(_xaie, 6, 4);
   mlir_aie_configure_cores(_xaie);
 
   usleep(sleep_u);
@@ -54,141 +52,146 @@ int main(int argc, char *argv[]) {
   mlir_aie_configure_switchboxes(_xaie);
   mlir_aie_initialize_locks(_xaie);
 
-      mlir_aie_acquire_lock(_xaie, 0, 1, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0,1), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc0(_xaie, 2, 1, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc0.set();
- 
+  mlir_aie_acquire_lock(_xaie, 0, 1, 14, 0, 0); // for timing
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0, 1), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc0(_xaie, 2, 1, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc0.set();
+
   mlir_aie_acquire_lock(_xaie, 0, 5, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0,5), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc1(_xaie, 2, 5, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc1.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0, 5), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc1(_xaie, 2, 5, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc1.set();
+
   mlir_aie_acquire_lock(_xaie, 3, 1, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3,1), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc2(_xaie, 5, 1, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc2.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3, 1), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc2(_xaie, 5, 1, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc2.set();
+
   mlir_aie_acquire_lock(_xaie, 3, 5, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3,5), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc3(_xaie, 5, 5, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc3.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3, 5), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc3(_xaie, 5, 5, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc3.set();
 
-    usleep(sleep_u);
+  usleep(sleep_u);
   printf("before configure DMA");
   mlir_aie_configure_dmas(_xaie);
   int errors = 0;
-      mlir_aie_init_mems(_xaie, 8);
- 
-    printf("Finish configure");
-  #define DMA_COUNT_IN 256*INPUT_ROWS
-  #define DMA_COUNT_OUT 256*2*B_BLOCK_DEPTH
-
-      int *ddr_ptr_in_0 = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT_IN);
-   int *ddr_ptr_in_1 = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT_IN);
-   int *ddr_ptr_in_2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT_IN);
-   int *ddr_ptr_in_3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT_IN);
-   int *ddr_ptr_out_0 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT_OUT);
-   int *ddr_ptr_out_1 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT_OUT);
-   int *ddr_ptr_out_2 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT_OUT);
-   int *ddr_ptr_out_3 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT_OUT);
-   for (int i = 0; i < DMA_COUNT_IN; i++) {
-     *(ddr_ptr_in_0+ i) = i;
-     *(ddr_ptr_in_1+ i) = i;
-     *(ddr_ptr_in_2+ i) = i;
-     *(ddr_ptr_in_3+ i) = i;
-   }
-   for (int i = 0; i < DMA_COUNT_OUT; i++) {
-     *(ddr_ptr_out_0+ i) = i;
-     *(ddr_ptr_out_1+ i) = i;
-     *(ddr_ptr_out_2+ i) = i;
-     *(ddr_ptr_out_3+ i) = i;
-   }
-   mlir_aie_sync_mem_dev(_xaie, 0);
-   mlir_aie_sync_mem_dev(_xaie, 1);
-   mlir_aie_sync_mem_dev(_xaie, 2);
-   mlir_aie_sync_mem_dev(_xaie, 3);
-   mlir_aie_sync_mem_dev(_xaie, 4);
-   mlir_aie_sync_mem_dev(_xaie, 5);
-   mlir_aie_sync_mem_dev(_xaie, 6);
-   mlir_aie_sync_mem_dev(_xaie, 7);
- #ifdef LIBXAIENGINEV2
-    mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0); 
-     mlir_aie_external_set_addr_ddr_buffer_in_1((u64)ddr_ptr_in_1); 
-     mlir_aie_external_set_addr_ddr_buffer_in_2((u64)ddr_ptr_in_2); 
-     mlir_aie_external_set_addr_ddr_buffer_in_3((u64)ddr_ptr_in_3); 
-     mlir_aie_external_set_addr_ddr_buffer_out_0((u64)ddr_ptr_out_0); 
-     mlir_aie_external_set_addr_ddr_buffer_out_1((u64)ddr_ptr_out_1); 
-     mlir_aie_external_set_addr_ddr_buffer_out_2((u64)ddr_ptr_out_2); 
-     mlir_aie_external_set_addr_ddr_buffer_out_3((u64)ddr_ptr_out_3); 
-     mlir_aie_configure_shimdma_20(_xaie);
-     mlir_aie_configure_shimdma_30(_xaie);
- #endif
-
-    printf("before core start");
+  mlir_aie_init_mems(_xaie, 8);
+
+  printf("Finish configure");
+#define DMA_COUNT_IN 256 * INPUT_ROWS
+#define DMA_COUNT_OUT 256 * 2 * B_BLOCK_DEPTH
+
+  int *ddr_ptr_in_0 = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT_IN);
+  int *ddr_ptr_in_1 = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT_IN);
+  int *ddr_ptr_in_2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT_IN);
+  int *ddr_ptr_in_3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT_IN);
+  int *ddr_ptr_out_0 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT_OUT);
+  int *ddr_ptr_out_1 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT_OUT);
+  int *ddr_ptr_out_2 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT_OUT);
+  int *ddr_ptr_out_3 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT_OUT);
+  for (int i = 0; i < DMA_COUNT_IN; i++) {
+    *(ddr_ptr_in_0 + i) = i;
+    *(ddr_ptr_in_1 + i) = i;
+    *(ddr_ptr_in_2 + i) = i;
+    *(ddr_ptr_in_3 + i) = i;
+  }
+  for (int i = 0; i < DMA_COUNT_OUT; i++) {
+    *(ddr_ptr_out_0 + i) = i;
+    *(ddr_ptr_out_1 + i) = i;
+    *(ddr_ptr_out_2 + i) = i;
+    *(ddr_ptr_out_3 + i) = i;
+  }
+  mlir_aie_sync_mem_dev(_xaie, 0);
+  mlir_aie_sync_mem_dev(_xaie, 1);
+  mlir_aie_sync_mem_dev(_xaie, 2);
+  mlir_aie_sync_mem_dev(_xaie, 3);
+  mlir_aie_sync_mem_dev(_xaie, 4);
+  mlir_aie_sync_mem_dev(_xaie, 5);
+  mlir_aie_sync_mem_dev(_xaie, 6);
+  mlir_aie_sync_mem_dev(_xaie, 7);
+#ifdef LIBXAIENGINEV2
+  mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0);
+  mlir_aie_external_set_addr_ddr_buffer_in_1((u64)ddr_ptr_in_1);
+  mlir_aie_external_set_addr_ddr_buffer_in_2((u64)ddr_ptr_in_2);
+  mlir_aie_external_set_addr_ddr_buffer_in_3((u64)ddr_ptr_in_3);
+  mlir_aie_external_set_addr_ddr_buffer_out_0((u64)ddr_ptr_out_0);
+  mlir_aie_external_set_addr_ddr_buffer_out_1((u64)ddr_ptr_out_1);
+  mlir_aie_external_set_addr_ddr_buffer_out_2((u64)ddr_ptr_out_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_3((u64)ddr_ptr_out_3);
+  mlir_aie_configure_shimdma_20(_xaie);
+  mlir_aie_configure_shimdma_30(_xaie);
+#endif
+
+  printf("before core start");
   // mlir_aie_print_tile_status(_xaie, 7, 3);
 
   printf("Release lock for accessing DDR.");
   mlir_aie_release_of_0_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_15_lock_0(_xaie, 0, 0);
 
-
-/*ADDD ALL THE LOCKS*/
-
-
-
+  /*ADDD ALL THE LOCKS*/
 
   printf("Start cores");
   ///// --- start counter-----
-  t = clock(); 
+  t = clock();
   mlir_aie_start_cores(_xaie);
-      mlir_aie_release_lock(_xaie, 0, 1, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 0, 5, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 3, 1, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 3, 5, 14, 0, 0); // for timing
- 
+  mlir_aie_release_lock(_xaie, 0, 1, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 0, 5, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 3, 1, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 3, 5, 14, 0, 0); // for timing
 
-         t = clock() - t; 
+  t = clock() - t;
 
-  printf ("It took %ld clicks (%f seconds).",t,((float)t)/CLOCKS_PER_SEC);
+  printf("It took %ld clicks (%f seconds).", t, ((float)t) / CLOCKS_PER_SEC);
 
   usleep(sleep_u);
   printf("after core start");
   // mlir_aie_print_tile_status(_xaie, 7, 3);
 
   usleep(sleep_u);
-  mlir_aie_sync_mem_cpu(_xaie, 4); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 5); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 6); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 7); //// only used in libaiev2 //sync up with output
- }
-
-      for (int i =0; i < 512; i ++ ){
-    printf("Location %d:  %d", i, ddr_ptr_out_0[i]);
-  }
+  mlir_aie_sync_mem_cpu(_xaie,
+                        4); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        5); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        6); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        7); //// only used in libaiev2 //sync up with output
+}
 
-  int res = 0;
-  if (!errors) {
-    printf("PASS!");
-    res = 0;
-  } else {
-    printf("Fail!");
-    res = -1;
-  } 
-  printf("PC0 cycles: %d", pc0.diff());
-   printf("PC1 cycles: %d", pc1.diff());
-   printf("PC2 cycles: %d", pc2.diff());
-   printf("PC3 cycles: %d", pc3.diff());
- 
-
-  mlir_aie_deinit_libxaie(_xaie);
-
-  printf("test done.");
-
-  return res;
+for (int i = 0; i < 512; i++) {
+  printf("Location %d:  %d", i, ddr_ptr_out_0[i]);
 }
 
-    
-    
-    
\ No newline at end of file
+int res = 0;
+if (!errors) {
+  printf("PASS!");
+  res = 0;
+} else {
+  printf("Fail!");
+  res = -1;
+}
+printf("PC0 cycles: %d", pc0.diff());
+printf("PC1 cycles: %d", pc1.diff());
+printf("PC2 cycles: %d", pc2.diff());
+printf("PC3 cycles: %d", pc3.diff());
+
+mlir_aie_deinit_libxaie(_xaie);
+
+printf("test done.");
+
+return res;
+}
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff.cc
index 4c7c062..0df5b10 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff.cc
@@ -1,214 +1,268 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-#include "./include.h"
 #include "hdiff.h"
+#include "./include.h"
 #define kernel_load 14
 // typedef int int32;
 
-
-//align to 16 bytes boundary, equivalent to "alignas(v4int32)"
-void vec_hdiff(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict row2,int32_t* restrict row3,int32_t* restrict row4, int32_t* restrict out)
-{
-
- // const int32_t *restrict w = weights;
-    alignas(32) int32_t weights[8] = {-4,-4,-4,-4,-4,-4,-4,-4};
-    alignas(32) int32_t weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) int32_t weights_rest[8] = {-1,-1,-1,-1,-1,-1,-1,-1};
-    alignas(32) int32_t flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8int32 coeffs         = *(v8int32*) weights;  //  8 x int32 = 256b W vector
-    v8int32 coeffs1        = *(v8int32*) weights1;  //  8 x int32 = 256b W vector
-    v8int32 coeffs_rest    = *(v8int32*) weights_rest;  //  8 x int32 = 256b W vector
-    v8int32 flux_out_coeff = *(v8int32*) flux_out;
-
-    // v8int32 * restrict ptr_in = (v8int32 *) in;
-    v8int32 * ptr_out = (v8int32 *) out;
-    v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    v8int32 * restrict row2_ptr=(v8int32 *)row2;
-    v8int32 * restrict row3_ptr=(v8int32 *)row3;
-    v8int32 * restrict row4_ptr=(v8int32 *)row4;
-    v8int32 * restrict r1;
-    // v8int32 * restrict r2=ptr_in+1*COL/8;
-
-    v16int32 data_buf1 = null_v16int32();
-    v16int32 data_buf2 = null_v16int32();;
-    
-    v8acc80 acc_0 = null_v8acc80();
-    v8acc80 acc_1 = null_v8acc80();
-
-    //  v8acc80 acc_1=null_v8acc80();        
-    v8int32 lap_ij = null_v8int32();      //  8 x int32 = 256b W vector
-    v8int32 lap_0  = null_v8int32();      //  8 x int32 = 256b W vector
-
-
-
-        data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-        data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
-    
-        for (unsigned i = 0; i < COL/8; i++)
-            chess_prepare_for_pipelining
-                    chess_loop_range(1,)
-        {   
-            v16int32 flux_sub;
-
-            acc_0=lmul8   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);          //c           
-            acc_1=lmul8   (data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);          //b
-          
-            acc_0=lmac8   (acc_0,data_buf1,2,0x76543210,coeffs_rest,    0,0x00000000);    //c,k
-            acc_1=lmac8   (acc_1,data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);    //b,j
-          
-            // r2 = ptr_in+2 * COL/8+i ;
-            r1=row2_ptr+i;
-            data_buf2 = upd_w(data_buf2, 0, *(r1)++);
-            data_buf2 = upd_w(data_buf2, 1, *(r1));
-
-            acc_0=lmac8   (acc_0,data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000); //c,k,f
-            acc_0=lmsc8   (acc_0,data_buf2,2,0x76543210,coeffs,    0,0x00000000);      //c,k,f,4*g
-            acc_0=lmac8   (acc_0,data_buf2,3,0x76543210,coeffs_rest,    0,0x00000000);  //c,k,f,4*g,h
-            
-            lap_ij=srs(acc_0,0); //store lap_ij
-
-            acc_1=lmac8   (acc_1,data_buf2,0,0x76543210,coeffs_rest,    0,0x00000000); //b,j,e
-            acc_1=lmsc8   (acc_1,data_buf2,1,0x76543210,coeffs,    0,0x00000000);      //b,j,e,4*f
-            acc_1=lmac8   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);  //b,j,e,4*f,g  
-           
-            //lap_ijm
-            lap_0=srs(acc_1,0);
-    
-            //Calculate  lap_ij - lap_ijm
-            flux_sub = sub16(concat(lap_ij,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_0,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 ); 
-            
-            //
-            acc_1=lmul8   (data_buf2,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);           // (lap_ij - lap_ijm)*g
-            acc_1=lmsc8   (acc_1,data_buf2,1,0x76543210,ext_w(flux_sub,0),    0,0x00000000);     // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
-
-            // compare > 0
-            unsigned int flx_compare_imj=gt16(concat(srs(acc_1,0),undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            
-            acc_0=lmul8   (data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);   // l
-            acc_0=lmsc8   (acc_0,data_buf2,3,0x76543210,coeffs,    0,0x00000000);  // l, 4*h
-            
-            //Calculate final fly_ijm
-            v16int32 out_flx_inter1=select16(flx_compare_imj,flux_sub,null_v16int32()); 
-
-            // r1 = ptr_in+1 * COL/8+i ;
-            r1=row1_ptr+i;
-            data_buf1 = upd_w(data_buf1, 0, *(r1)++);
-            data_buf1 = upd_w(data_buf1, 1, *(r1));    
-
-            acc_0=lmac8  (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);  // l, 4*h, g
-            acc_0=lmac8   (acc_0,data_buf2,4,0x76543210,coeffs_rest,    0,0x00000000); // l, 4*h, g, i 
-            v16int32 flx_out1=add16(null_v16int32(),out_flx_inter1);     //still fly_ijm
-                      
-            acc_0=lmac8   (acc_0,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);// l, 4*h, g, i, d 
-            
-            //Calculates lap_ijp
-            lap_0=srs(acc_0,0); 
-
-            //Calculates lap_ijp - lap_ij
-            flux_sub = sub16(concat(lap_0,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_ij,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 );
-            
-            acc_0=lmul8   (data_buf2,3,0x76543210,ext_w(flux_sub,0),    0,0x00000000);            // (lap_ijp - lap_ij) * h       
-            acc_0=lmsc8   (acc_0,data_buf2,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);      //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g           
-
-            //Calculates final fly_ij (comparison > 0)
-            unsigned int flx_compare_ij=gt16(concat(srs(acc_0,0),undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter2=select16(flx_compare_ij,flux_sub,null_v16int32());    
-
-            //add fly_ij - fly_ijm
-            v16int32 flx_out2=sub16(out_flx_inter2,flx_out1);                             
-
-            //***********************************************************************STARTING X FLUX*****************************************************************************************************************************************************
-            
-            acc_1=lmul8    ( data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000); // g                     
-            acc_0=lmul8   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);   // g
-
-            // r2 = ptr_in + 0*COL/8 + i ; 
-            r1=row0_ptr+i;
-            data_buf2 = upd_w(data_buf2, 0, *(r1)++);
-            data_buf2 = upd_w(data_buf2, 1, *(r1));
-                  
-            acc_1=lmsc8    (acc_1, data_buf1,2,0x76543210,coeffs,    0,0x00000000);             // g, 4*c
-            acc_1=lmac8    (acc_1, data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);        // g, 4*c, b
-            acc_1=lmac8   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);          // g, 4*c, b, a
-          
-            // r2 = ptr_in + 4*COL/8 + i ; 
-            r1=row4_ptr+i;
-            data_buf2 = upd_w(data_buf2, 0, *(r1)++);
-            data_buf2 = upd_w(data_buf2, 1, *(r1));
-
-            acc_1=lmac8    ( acc_1,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b, a, d               
-            acc_0=lmac8   (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);         // g, m
-            
-            // r2 = ptr_in + 2*COL/8 + i ; 
-            r1=row2_ptr+i;
-            data_buf2 = upd_w(data_buf2, 0, *(r1)++);
-            data_buf2 = upd_w(data_buf2, 1, *(r1));
-            
-            //Calculates lap_imj
-            lap_0=srs(acc_1,0); 
-
-            //flx_imj = lap_ij - lap_imj
-            flux_sub = sub16(concat(lap_ij,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_0,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 ); 
-            
-            acc_1=lmul8   (data_buf2,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);       //   (lap_ij - lap_imj) * g
-            acc_1=lmsc8   (acc_1,data_buf1,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000); //    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c  
-     
-            //Calculates final flx_imj (comparison > 0)
-            unsigned int fly_compare_ijm=gt16(concat(srs(acc_1,0),undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter3=select16(fly_compare_ijm,flux_sub,null_v16int32());
-
-            // r1 = ptr_in + 3*COL/8 + i ;
-            r1=row3_ptr+i;
-            data_buf1 = upd_w(data_buf1, 0, *(r1)++);
-            data_buf1 = upd_w(data_buf1, 1, *(r1));
-
-            acc_0=lmsc8   (acc_0,data_buf1,2,0x76543210,coeffs,    0,0x00000000); //g, m , k * 4
-
-            v16int32 flx_out3=sub16(flx_out2,out_flx_inter3);                     //adds fly_ij - fly_ijm - flx_imj
-
-            acc_0=lmac8   (acc_0,data_buf1, 1,0x76543210,coeffs_rest,    0,0x00000000);     //g, m , k * 4, j 
-            acc_0=lmac8   (acc_0,data_buf1, 3,0x76543210,coeffs_rest,    0,0x00000000);     //g, m , k * 4, j, l  
-     
-            //  flx_ij = lap_ipj - lap_ij
-            flux_sub = sub16(concat(srs(acc_0,0),undef_v8int32()), 0, 0x76543210, 0xFEDCBA98, concat(lap_ij,undef_v8int32()),   0,  0x76543210, 0xFEDCBA98 ); 
-
-            //below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
-            acc_1=lmul8   (data_buf1,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);      //  (lap_ipj - lap_ij) * k       
-            
-            //LOAD DATA FOR NEXT ITERATION
-            // r1 = ptr_in + 3*COL/8 + i + 1 ;
-            r1=row3_ptr+i+1;
-            data_buf1 = upd_w(data_buf1, 0, *(r1)++);
-            data_buf1 = upd_w(data_buf1, 1, *(r1));
-            
-            acc_1=lmsc8   (acc_1,data_buf2,2,0x76543210,ext_w(flux_sub,0),    0,0x00000000);    //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g   
-
-            // final flx_ij (comparison > 0 )
-            unsigned int fly_compare_ij=gt16(concat(srs(acc_1,0),undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter4=select16(fly_compare_ij,flux_sub,null_v16int32()); 
-
-            v16int32 flx_out4=add16(flx_out3,out_flx_inter4); //adds fly_ij - fly_ijm - flx_imj + flx_ij
-
-            v8acc80 final_output = lmul8  (flx_out4, 0, 0x76543210, flux_out_coeff,    0,0x00000000);  // Multiply by -7s
-            final_output=lmac8(final_output, data_buf2,  2, 0x76543210,concat(coeffs1, undef_v8int32()), 0 , 0x76543210); 
-
-            //LOAD DATA FOR NEXT ITERATION
-            // r2 = ptr_in + 1*COL/8 + i + 1 ;
-            r1=row1_ptr+i+1;
-            data_buf2 = upd_w(data_buf2, 0, *(r1)++);
-            data_buf2 = upd_w(data_buf2, 1, *(r1));
-
-            // window_writeincr(out, srs(final_output,0));
-            *ptr_out++ =  srs(final_output,0);       
-        // }
-
+// align to 16 bytes boundary, equivalent to "alignas(v4int32)"
+void vec_hdiff(int32_t *restrict row0, int32_t *restrict row1,
+               int32_t *restrict row2, int32_t *restrict row3,
+               int32_t *restrict row4, int32_t *restrict out) {
+
+  // const int32_t *restrict w = weights;
+  alignas(32) int32_t weights[8] = {-4, -4, -4, -4, -4, -4, -4, -4};
+  alignas(32) int32_t weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) int32_t weights_rest[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
+  alignas(32) int32_t flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8int32 coeffs = *(v8int32 *)weights;           //  8 x int32 = 256b W vector
+  v8int32 coeffs1 = *(v8int32 *)weights1;         //  8 x int32 = 256b W vector
+  v8int32 coeffs_rest = *(v8int32 *)weights_rest; //  8 x int32 = 256b W vector
+  v8int32 flux_out_coeff = *(v8int32 *)flux_out;
+
+  // v8int32 * restrict ptr_in = (v8int32 *) in;
+  v8int32 *ptr_out = (v8int32 *)out;
+  v8int32 *restrict row0_ptr = (v8int32 *)row0;
+  v8int32 *restrict row1_ptr = (v8int32 *)row1;
+  v8int32 *restrict row2_ptr = (v8int32 *)row2;
+  v8int32 *restrict row3_ptr = (v8int32 *)row3;
+  v8int32 *restrict row4_ptr = (v8int32 *)row4;
+  v8int32 *restrict r1;
+  // v8int32 * restrict r2=ptr_in+1*COL/8;
+
+  v16int32 data_buf1 = null_v16int32();
+  v16int32 data_buf2 = null_v16int32();
+  ;
+
+  v8acc80 acc_0 = null_v8acc80();
+  v8acc80 acc_1 = null_v8acc80();
+
+  //  v8acc80 acc_1=null_v8acc80();
+  v8int32 lap_ij = null_v8int32(); //  8 x int32 = 256b W vector
+  v8int32 lap_0 = null_v8int32();  //  8 x int32 = 256b W vector
+
+  data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+  data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v16int32 flux_sub;
+
+      acc_0 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // c
+      acc_1 = lmul8(data_buf2, 1, 0x76543210, coeffs_rest, 0, 0x00000000); // b
+
+      acc_0 = lmac8(acc_0, data_buf1, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k
+      acc_1 = lmac8(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j
+
+      // r2 = ptr_in+2 * COL/8+i ;
+      r1 = row2_ptr + i;
+      data_buf2 = upd_w(data_buf2, 0, *(r1)++);
+      data_buf2 = upd_w(data_buf2, 1, *(r1));
+
+      acc_0 = lmac8(acc_0, data_buf2, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k,f
+      acc_0 = lmsc8(acc_0, data_buf2, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // c,k,f,4*g
+      acc_0 = lmac8(acc_0, data_buf2, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k,f,4*g,h
+
+      lap_ij = srs(acc_0, 0); // store lap_ij
+
+      acc_1 = lmac8(acc_1, data_buf2, 0, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j,e
+      acc_1 = lmsc8(acc_1, data_buf2, 1, 0x76543210, coeffs, 0,
+                    0x00000000); // b,j,e,4*f
+      acc_1 = lmac8(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j,e,4*f,g
+
+      // lap_ijm
+      lap_0 = srs(acc_1, 0);
+
+      // Calculate  lap_ij - lap_ijm
+      flux_sub =
+          sub16(concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+
+      //
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, ext_w(flux_sub, 0), 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g
+      acc_1 = lmsc8(acc_1, data_buf2, 1, 0x76543210, ext_w(flux_sub, 0), 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
+
+      // compare > 0
+      unsigned int flx_compare_imj =
+          gt16(concat(srs(acc_1, 0), undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+
+      acc_0 = lmul8(data_buf1, 3, 0x76543210, coeffs_rest, 0, 0x00000000); // l
+      acc_0 = lmsc8(acc_0, data_buf2, 3, 0x76543210, coeffs, 0,
+                    0x00000000); // l, 4*h
+
+      // Calculate final fly_ijm
+      v16int32 out_flx_inter1 =
+          select16(flx_compare_imj, flux_sub, null_v16int32());
+
+      // r1 = ptr_in+1 * COL/8+i ;
+      r1 = row1_ptr + i;
+      data_buf1 = upd_w(data_buf1, 0, *(r1)++);
+      data_buf1 = upd_w(data_buf1, 1, *(r1));
+
+      acc_0 = lmac8(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g
+      acc_0 = lmac8(acc_0, data_buf2, 4, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g, i
+      v16int32 flx_out1 =
+          add16(null_v16int32(), out_flx_inter1); // still fly_ijm
+
+      acc_0 = lmac8(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g, i, d
+
+      // Calculates lap_ijp
+      lap_0 = srs(acc_0, 0);
+
+      // Calculates lap_ijp - lap_ij
+      flux_sub =
+          sub16(concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+
+      acc_0 = lmul8(data_buf2, 3, 0x76543210, ext_w(flux_sub, 0), 0,
+                    0x00000000); // (lap_ijp - lap_ij) * h
+      acc_0 = lmsc8(
+          acc_0, data_buf2, 2, 0x76543210, ext_w(flux_sub, 0), 0,
+          0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g
+
+      // Calculates final fly_ij (comparison > 0)
+      unsigned int flx_compare_ij =
+          gt16(concat(srs(acc_0, 0), undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter2 =
+          select16(flx_compare_ij, flux_sub, null_v16int32());
+
+      // add fly_ij - fly_ijm
+      v16int32 flx_out2 = sub16(out_flx_inter2, flx_out1);
+
+      //***********************************************************************STARTING
+      //X
+      //FLUX*****************************************************************************************************************************************************
+
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+      acc_0 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+
+      // r2 = ptr_in + 0*COL/8 + i ;
+      r1 = row0_ptr + i;
+      data_buf2 = upd_w(data_buf2, 0, *(r1)++);
+      data_buf2 = upd_w(data_buf2, 1, *(r1));
+
+      acc_1 = lmsc8(acc_1, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, 4*c
+      acc_1 = lmac8(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b
+      acc_1 = lmac8(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a
+
+      // r2 = ptr_in + 4*COL/8 + i ;
+      r1 = row4_ptr + i;
+      data_buf2 = upd_w(data_buf2, 0, *(r1)++);
+      data_buf2 = upd_w(data_buf2, 1, *(r1));
+
+      acc_1 = lmac8(acc_1, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a, d
+      acc_0 = lmac8(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m
+
+      // r2 = ptr_in + 2*COL/8 + i ;
+      r1 = row2_ptr + i;
+      data_buf2 = upd_w(data_buf2, 0, *(r1)++);
+      data_buf2 = upd_w(data_buf2, 1, *(r1));
+
+      // Calculates lap_imj
+      lap_0 = srs(acc_1, 0);
+
+      // flx_imj = lap_ij - lap_imj
+      flux_sub =
+          sub16(concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, ext_w(flux_sub, 0), 0,
+                    0x00000000); //   (lap_ij - lap_imj) * g
+      acc_1 = lmsc8(
+          acc_1, data_buf1, 2, 0x76543210, ext_w(flux_sub, 0), 0,
+          0x00000000); //    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c
+
+      // Calculates final flx_imj (comparison > 0)
+      unsigned int fly_compare_ijm =
+          gt16(concat(srs(acc_1, 0), undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter3 =
+          select16(fly_compare_ijm, flux_sub, null_v16int32());
+
+      // r1 = ptr_in + 3*COL/8 + i ;
+      r1 = row3_ptr + i;
+      data_buf1 = upd_w(data_buf1, 0, *(r1)++);
+      data_buf1 = upd_w(data_buf1, 1, *(r1));
+
+      acc_0 = lmsc8(acc_0, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, m , k * 4
+
+      v16int32 flx_out3 =
+          sub16(flx_out2, out_flx_inter3); // adds fly_ij - fly_ijm - flx_imj
+
+      acc_0 = lmac8(acc_0, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m , k * 4, j
+      acc_0 = lmac8(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m , k * 4, j, l
+
+      //  flx_ij = lap_ipj - lap_ij
+      flux_sub = sub16(concat(srs(acc_0, 0), undef_v8int32()), 0, 0x76543210,
+                       0xFEDCBA98, concat(lap_ij, undef_v8int32()), 0,
+                       0x76543210, 0xFEDCBA98);
+
+      // below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
+      acc_1 = lmul8(data_buf1, 2, 0x76543210, ext_w(flux_sub, 0), 0,
+                    0x00000000); //  (lap_ipj - lap_ij) * k
+
+      // LOAD DATA FOR NEXT ITERATION
+      //  r1 = ptr_in + 3*COL/8 + i + 1 ;
+      r1 = row3_ptr + i + 1;
+      data_buf1 = upd_w(data_buf1, 0, *(r1)++);
+      data_buf1 = upd_w(data_buf1, 1, *(r1));
+
+      acc_1 =
+          lmsc8(acc_1, data_buf2, 2, 0x76543210, ext_w(flux_sub, 0), 0,
+                0x00000000); //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g
+
+      // final flx_ij (comparison > 0 )
+      unsigned int fly_compare_ij =
+          gt16(concat(srs(acc_1, 0), undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter4 =
+          select16(fly_compare_ij, flux_sub, null_v16int32());
+
+      v16int32 flx_out4 = add16(
+          flx_out3, out_flx_inter4); // adds fly_ij - fly_ijm - flx_imj + flx_ij
+
+      v8acc80 final_output = lmul8(flx_out4, 0, 0x76543210, flux_out_coeff, 0,
+                                   0x00000000); // Multiply by -7s
+      final_output = lmac8(final_output, data_buf2, 2, 0x76543210,
+                           concat(coeffs1, undef_v8int32()), 0, 0x76543210);
+
+      // LOAD DATA FOR NEXT ITERATION
+      //  r2 = ptr_in + 1*COL/8 + i + 1 ;
+      r1 = row1_ptr + i + 1;
+      data_buf2 = upd_w(data_buf2, 0, *(r1)++);
+      data_buf2 = upd_w(data_buf2, 1, *(r1));
+
+      // window_writeincr(out, srs(final_output,0));
+      *ptr_out++ = srs(final_output, 0);
+      // }
     }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff.h b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff.h
index 60a3d2d..0a91f1d 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff.h
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff.h
@@ -1,20 +1,41 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
 extern "C" {
-void hdiff_lap(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict row2,int32_t* restrict row3,int32_t* restrict row4, int32_t* restrict out_flux1, int32_t* restrict out_flux2, int32_t* restrict out_flux3, int32_t* restrict out_flux4 );
-void hdiff_flux1(int32_t* restrict row1, int32_t* restrict row2,int32_t* restrict row3, int32_t* restrict flux_forward1,int32_t* restrict flux_forward2,int32_t* restrict flux_forward3,int32_t* restrict flux_forward4,  int32_t* restrict flux_inter1,int32_t* restrict flux_inter2,int32_t* restrict flux_inter3,int32_t* restrict flux_inter4,int32_t* restrict flux_inter5);
-void hdiff_flux2(int32_t* restrict flux_inter1,int32_t* restrict flux_inter2,int32_t* restrict flux_inter3,int32_t* restrict flux_inter4,int32_t* restrict flux_inter5,  int32_t * restrict out);
-
-void hdiff_lap_fp32(float* restrict row0, float* restrict row1,float* restrict row2,float* restrict row3,float* restrict row4, float* restrict out_flux1, float* restrict out_flux2, float* restrict out_flux3, float* restrict out_flux4 );
-void hdiff_flux1_fp32(float* restrict row1, float* restrict row2,float* restrict row3,\
- float* restrict flux_forward1,float* restrict flux_forward2,float* restrict flux_forward3,float* restrict flux_forward4, \
-  float * restrict flux_inter1,float * restrict flux_inter2,float * restrict flux_inter3,float * restrict flux_inter4,float * restrict flux_inter5);
+void hdiff_lap(int32_t *restrict row0, int32_t *restrict row1,
+               int32_t *restrict row2, int32_t *restrict row3,
+               int32_t *restrict row4, int32_t *restrict out_flux1,
+               int32_t *restrict out_flux2, int32_t *restrict out_flux3,
+               int32_t *restrict out_flux4);
+void hdiff_flux1(int32_t *restrict row1, int32_t *restrict row2,
+                 int32_t *restrict row3, int32_t *restrict flux_forward1,
+                 int32_t *restrict flux_forward2,
+                 int32_t *restrict flux_forward3,
+                 int32_t *restrict flux_forward4, int32_t *restrict flux_inter1,
+                 int32_t *restrict flux_inter2, int32_t *restrict flux_inter3,
+                 int32_t *restrict flux_inter4, int32_t *restrict flux_inter5);
+void hdiff_flux2(int32_t *restrict flux_inter1, int32_t *restrict flux_inter2,
+                 int32_t *restrict flux_inter3, int32_t *restrict flux_inter4,
+                 int32_t *restrict flux_inter5, int32_t *restrict out);
 
-void hdiff_flux2_fp32(float* restrict flux_inter1,float* restrict flux_inter2, float* restrict flux_inter3,float* restrict flux_inter4,float* restrict flux_inter5, float * restrict out);
+void hdiff_lap_fp32(float *restrict row0, float *restrict row1,
+                    float *restrict row2, float *restrict row3,
+                    float *restrict row4, float *restrict out_flux1,
+                    float *restrict out_flux2, float *restrict out_flux3,
+                    float *restrict out_flux4);
+void hdiff_flux1_fp32(float *restrict row1, float *restrict row2,
+                      float *restrict row3, float *restrict flux_forward1,
+                      float *restrict flux_forward2,
+                      float *restrict flux_forward3,
+                      float *restrict flux_forward4,
+                      float *restrict flux_inter1, float *restrict flux_inter2,
+                      float *restrict flux_inter3, float *restrict flux_inter4,
+                      float *restrict flux_inter5);
 
+void hdiff_flux2_fp32(float *restrict flux_inter1, float *restrict flux_inter2,
+                      float *restrict flux_inter3, float *restrict flux_inter4,
+                      float *restrict flux_inter5, float *restrict out);
 }
-
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux1.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux1.cc
index a5cb658..6005a52 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux1.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux1.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,143 +9,142 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,  int32_t * restrict out)
+// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,
+// int32_t * restrict out)
 // {
-void hdiff_flux1(int32_t* restrict row1, int32_t* restrict row2,int32_t* restrict row3,\
- int32_t* restrict flux_forward1,int32_t* restrict flux_forward2,int32_t* restrict flux_forward3,int32_t* restrict flux_forward4, \
-  int32_t * restrict flux_inter1,int32_t * restrict flux_inter2,int32_t * restrict flux_inter3,int32_t * restrict flux_inter4,int32_t * restrict flux_inter5)
-{
-    
-    alignas(32) int32_t weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) int32_t flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8int32 coeffs1         = *(v8int32*) weights1;  //  8 x int32 = 256b W vector
-    v8int32 flux_out_coeff=*(v8int32*)flux_out;
-
-    // v8int32 * restrict  ptr_in = (v8int32 *) in;
-    v8int32 * restrict  ptr_forward = (v8int32 *) flux_forward1;
-    v8int32 * ptr_out = (v8int32 *) flux_inter1;
-    
-    v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    v8int32 * restrict row2_ptr=(v8int32 *)row2;
-    v8int32 * restrict row3_ptr=(v8int32 *)row3;
-
-    // v8int32 * restrict r1=(v8int32 *)row1_ptr;
-    // v8int32 * restrict r2=(v8int32 *)row2_ptr;
-
-    // v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    // v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    // v8int32 * restrict row2_ptr=(v8int32 *)row2;
-
-    v16int32   data_buf1=null_v16int32();
-    v16int32  data_buf2=null_v16int32();
-
-    v8acc80 acc_0=null_v8acc80();
-    v8acc80 acc_1=null_v8acc80();
-          //  8 x int32 = 256b W vector
-
-  
-        // r1 = ptr_in + 1*COL/8 + aor*COL/8;
-        // r2 = ptr_in + 2*COL/8 + aor*COL/8;
-        data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
-
-        data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-
-        
-    // buf_2=R2 , and buf_1=R3
-        
-    for (unsigned i = 0; i < COL/8; i++)
-        chess_prepare_for_pipelining
-        chess_loop_range(1,)
-        {
-            v8int32  flux_sub;
-            // printf("inside flux");
-            // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
-            ptr_forward = (v8int32 *) flux_forward1+i;
-            flux_sub=*ptr_forward;
-            // flux_sub=window_readincr_v8(flux_cascade);
-            acc_1=lmul8   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);           // (lap_ij - lap_ijm)*g
-            acc_1=lmsc8   (acc_1,data_buf2,1,0x76543210,flux_sub,    0,0x00000000);     // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
-            
-            ptr_out = (v8int32 *) flux_inter1+i;
-            *ptr_out++=  flux_sub;
-            *ptr_out= srs(acc_1,0);
-
-           
-    /////////////////////////////////////////////////////////////////////////////////////
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_forward2+i;
-            flux_sub=*ptr_forward++;
-            
-            acc_0=lmul8   (data_buf2,3,0x76543210,flux_sub,    0,0x00000000);            // (lap_ijp - lap_ij) * h       
-            acc_0=lmsc8   (acc_0,data_buf2,2,0x76543210,flux_sub,    0,0x00000000);      //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g           
-
-            ptr_out = (v8int32 *) flux_inter2+i;
-            *ptr_out++= flux_sub;
-            *ptr_out= srs(acc_0,0);
-                         
-/////////////////////////////////////////////////////////////////////////////////////
-
-            /// retrieving flx_imj = lap_ij - lap_imj
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_forward3+i;
-            flux_sub=*ptr_forward;
-            acc_1=lmul8   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);       //   (lap_ij - lap_imj) * g
-            acc_1=lmsc8   (acc_1,data_buf1,2,0x76543210,flux_sub,    0,0x00000000); //    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c  
-            
-          
-            ptr_out = (v8int32 *) flux_inter3+i;
-            *ptr_out++= flux_sub;
-            *ptr_out= srs(acc_1,0);
-            
-            row3_ptr=((v8int32 *) (row3))+i;
-            data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
-
-            
-         
-/////////////////////////////////////////////////////////////////////////////////////
-             // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-             //re†rieving flx_ij = lap_ipj - lap_ij
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_forward4+i;
-            flux_sub=*ptr_forward;
-
-            //below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
-            acc_1=lmul8   (data_buf1,2,0x76543210,flux_sub,    0,0x00000000);      //  (lap_ipj - lap_ij) * k       
-            acc_1=lmsc8   (acc_1,data_buf2,2,0x76543210,flux_sub,    0,0x00000000);    //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g   
-
-            ptr_out = (v8int32 *) flux_inter4+i;
-            *ptr_out++= flux_sub;
-            *ptr_out= srs(acc_1,0);
-
-            // r1 = ptr_in + 1*COL/8 + i+1+ aor*COL/8;
-            //LOAD DATA FOR NEXT ITERATION  
-            row1_ptr=((v8int32 *) (row1))+i+1;
-            data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));
-
-            
-
-            ptr_out = (v8int32 *) flux_inter5+i;
-            *ptr_out++= ext_w(data_buf2,1);
-            *ptr_out= ext_w(data_buf2,0);
-
-          //LOAD DATA FOR NEXT ITERATION         
-            row2_ptr=((v8int32 *) (row2))+i+1;
-            // data_buf1=*r1++;
-            data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-
-
-                      
-        }
-    
-
+void hdiff_flux1(int32_t *restrict row1, int32_t *restrict row2,
+                 int32_t *restrict row3, int32_t *restrict flux_forward1,
+                 int32_t *restrict flux_forward2,
+                 int32_t *restrict flux_forward3,
+                 int32_t *restrict flux_forward4, int32_t *restrict flux_inter1,
+                 int32_t *restrict flux_inter2, int32_t *restrict flux_inter3,
+                 int32_t *restrict flux_inter4, int32_t *restrict flux_inter5) {
+
+  alignas(32) int32_t weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) int32_t flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8int32 coeffs1 = *(v8int32 *)weights1; //  8 x int32 = 256b W vector
+  v8int32 flux_out_coeff = *(v8int32 *)flux_out;
+
+  // v8int32 * restrict  ptr_in = (v8int32 *) in;
+  v8int32 *restrict ptr_forward = (v8int32 *)flux_forward1;
+  v8int32 *ptr_out = (v8int32 *)flux_inter1;
+
+  v8int32 *restrict row1_ptr = (v8int32 *)row1;
+  v8int32 *restrict row2_ptr = (v8int32 *)row2;
+  v8int32 *restrict row3_ptr = (v8int32 *)row3;
+
+  // v8int32 * restrict r1=(v8int32 *)row1_ptr;
+  // v8int32 * restrict r2=(v8int32 *)row2_ptr;
+
+  // v8int32 * restrict row0_ptr=(v8int32 *)row0;
+  // v8int32 * restrict row1_ptr=(v8int32 *)row1;
+  // v8int32 * restrict row2_ptr=(v8int32 *)row2;
+
+  v16int32 data_buf1 = null_v16int32();
+  v16int32 data_buf2 = null_v16int32();
+
+  v8acc80 acc_0 = null_v8acc80();
+  v8acc80 acc_1 = null_v8acc80();
+  //  8 x int32 = 256b W vector
+
+  // r1 = ptr_in + 1*COL/8 + aor*COL/8;
+  // r2 = ptr_in + 2*COL/8 + aor*COL/8;
+  data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
+
+  data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+
+  // buf_2=R2 , and buf_1=R3
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v8int32 flux_sub;
+      // printf("inside flux");
+      // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
+      ptr_forward = (v8int32 *)flux_forward1 + i;
+      flux_sub = *ptr_forward;
+      // flux_sub=window_readincr_v8(flux_cascade);
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g
+      acc_1 = lmsc8(acc_1, data_buf2, 1, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
+
+      ptr_out = (v8int32 *)flux_inter1 + i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = srs(acc_1, 0);
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_forward2 + i;
+      flux_sub = *ptr_forward++;
+
+      acc_0 = lmul8(data_buf2, 3, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ijp - lap_ij) * h
+      acc_0 = lmsc8(
+          acc_0, data_buf2, 2, 0x76543210, flux_sub, 0,
+          0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g
+
+      ptr_out = (v8int32 *)flux_inter2 + i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = srs(acc_0, 0);
+
+      /////////////////////////////////////////////////////////////////////////////////////
+
+      /// retrieving flx_imj = lap_ij - lap_imj
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_forward3 + i;
+      flux_sub = *ptr_forward;
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); //   (lap_ij - lap_imj) * g
+      acc_1 = lmsc8(
+          acc_1, data_buf1, 2, 0x76543210, flux_sub, 0,
+          0x00000000); //    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c
+
+      ptr_out = (v8int32 *)flux_inter3 + i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = srs(acc_1, 0);
+
+      row3_ptr = ((v8int32 *)(row3)) + i;
+      data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // re†rieving flx_ij = lap_ipj - lap_ij
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_forward4 + i;
+      flux_sub = *ptr_forward;
+
+      // below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
+      acc_1 = lmul8(data_buf1, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); //  (lap_ipj - lap_ij) * k
+      acc_1 =
+          lmsc8(acc_1, data_buf2, 2, 0x76543210, flux_sub, 0,
+                0x00000000); //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g
+
+      ptr_out = (v8int32 *)flux_inter4 + i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = srs(acc_1, 0);
+
+      // r1 = ptr_in + 1*COL/8 + i+1+ aor*COL/8;
+      // LOAD DATA FOR NEXT ITERATION
+      row1_ptr = ((v8int32 *)(row1)) + i + 1;
+      data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));
+
+      ptr_out = (v8int32 *)flux_inter5 + i;
+      *ptr_out++ = ext_w(data_buf2, 1);
+      *ptr_out = ext_w(data_buf2, 0);
+
+      // LOAD DATA FOR NEXT ITERATION
+      row2_ptr = ((v8int32 *)(row2)) + i + 1;
+      // data_buf1=*r1++;
+      data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+    }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux1_fp32.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux1_fp32.cc
index b2c2cb1..a142ee2 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux1_fp32.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux1_fp32.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,144 +9,144 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,  int32_t * restrict out)
+// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,
+// int32_t * restrict out)
 // {
-void hdiff_flux1_fp32(float* restrict row1, float* restrict row2,float* restrict row3,\
- float* restrict flux_forward1,float* restrict flux_forward2,float* restrict flux_forward3,float* restrict flux_forward4, \
-  float * restrict flux_inter1,float * restrict flux_inter2,float * restrict flux_inter3,float * restrict flux_inter4,float * restrict flux_inter5)
-{
-    
-    alignas(32) float weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) float flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8float coeffs1        = *(v8float*) weights1;  //  8 x int32 = 256b W vector
-    v8float flux_out_coeff = *(v8float*) flux_out;
-
-    // v8int32 * restrict  ptr_in = (v8int32 *) in;
-    v8float * restrict  ptr_forward = (v8float *) flux_forward1;
-    v8float * ptr_out = (v8float *) flux_inter1;
-    
-    v8float * restrict row1_ptr=(v8float *)row1;
-    v8float * restrict row2_ptr=(v8float *)row2;
-    v8float * restrict row3_ptr=(v8float *)row3;
-
-    // v8float * restrict r1=(v8float *)row1_ptr;
-    // v8float * restrict r2=(v8float *)row2_ptr;
-
-    // v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    // v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    // v8int32 * restrict row2_ptr=(v8int32 *)row2;
-
-    v16float   data_buf1=null_v16float();
-    v16float  data_buf2=null_v16float();
-
-    v8float acc_0=null_v8float();
-    v8float acc_1=null_v8float();
-          //  8 x int32 = 256b W vector
-
-  
-        // r1 = ptr_in + 1*COL/8 + aor*COL/8;
-        // r2 = ptr_in + 2*COL/8 + aor*COL/8;
-        data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
-
-        data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-
-        
-    // buf_2=R2 , and buf_1=R3
-        
-    for (unsigned i = 0; i < COL/8; i++)
-        chess_prepare_for_pipelining
-        chess_loop_range(1,)
-        {
-            v8float flux_sub;
-            // printf("inside flux");
-            // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
-            ptr_forward = (v8float *) flux_forward1+i;
-            flux_sub=*ptr_forward;
-            // flux_sub=window_readincr_v8(flux_cascade);
-            acc_1=fpmul   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);///  (lap_ij - lap_ijm)*g
-            acc_1=fpmsc   (acc_1,data_buf2,1,0x76543210,flux_sub,    0,0x00000000);// (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
-
-            ptr_out = (v8float *) flux_inter1+i;
-            *ptr_out++=  flux_sub;
-            *ptr_out= acc_1;
-
-           
-    /////////////////////////////////////////////////////////////////////////////////////
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8float *) flux_forward2+i;
-            flux_sub=*ptr_forward;
-            
-            acc_0=fpmul   (data_buf2,3,0x76543210,flux_sub,    0,0x00000000); // (lap_ijp - lap_ij) * h    
-            acc_0=fpmsc   (acc_1,data_buf2,2,0x76543210,flux_sub,    0,0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g                     
-
-            ptr_out = (v8float *) flux_inter2+i;
-            *ptr_out++= flux_sub;
-            *ptr_out= acc_0;
-                         
-/////////////////////////////////////////////////////////////////////////////////////
-
-            /// retrieving flx_imj = lap_ij - lap_imj
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8float *) flux_forward3+i;
-            flux_sub=*ptr_forward;
-            acc_1=fpmul   (data_buf2,2,0x76543210,flux_sub,    0,0x00000000);///   (lap_ij - lap_imj) * g
-            acc_1=fpmsc   (acc_1,data_buf1,2,0x76543210,flux_sub,    0,0x00000000);///    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c          
-                
-          
-            ptr_out = (v8float *) flux_inter3+i;
-            *ptr_out++= flux_sub;
-            *ptr_out= acc_1;
-            
-            row3_ptr=((v8float *) (row3))+i;
-
-            data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-            data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-
-            
-         
-/////////////////////////////////////////////////////////////////////////////////////
-             // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-             //re†rieving flx_ij = lap_ipj - lap_ij
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8float *) flux_forward4+i;
-            flux_sub=*ptr_forward;
-
-            //below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
-            acc_1=fpmul   (data_buf1,2,0x76543210,flux_sub,    0,0x00000000);//  (lap_ipj - lap_ij) * k       
-
-            acc_1=fpmsc   (acc_1,data_buf2,2,0x76543210,flux_sub,    0,0x00000000);    //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g   
-
-            ptr_out = (v8float *) flux_inter4+i;
-            *ptr_out++= flux_sub;
-            *ptr_out= acc_1;
-
-            // r1 = ptr_in + 1*COL/8 + i+1+ aor*COL/8;
-            row1_ptr=((v8float *) (row1))+i+1;
-            data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
-            data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
-
-            
-
-            ptr_out = (v8float *) flux_inter5+i;
-            *ptr_out++= ext_w(data_buf2,1);
-            *ptr_out= ext_w(data_buf2,0);
-
-          //LOAD DATA FOR NEXT ITERATION         
-            row2_ptr=((v8float *) (row2))+i+1;
-            // data_buf1=*r1++;
-            data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
-            data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
-
-
-                      
-        }
-    
-
+void hdiff_flux1_fp32(float *restrict row1, float *restrict row2,
+                      float *restrict row3, float *restrict flux_forward1,
+                      float *restrict flux_forward2,
+                      float *restrict flux_forward3,
+                      float *restrict flux_forward4,
+                      float *restrict flux_inter1, float *restrict flux_inter2,
+                      float *restrict flux_inter3, float *restrict flux_inter4,
+                      float *restrict flux_inter5) {
+
+  alignas(32) float weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) float flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8float coeffs1 = *(v8float *)weights1; //  8 x int32 = 256b W vector
+  v8float flux_out_coeff = *(v8float *)flux_out;
+
+  // v8int32 * restrict  ptr_in = (v8int32 *) in;
+  v8float *restrict ptr_forward = (v8float *)flux_forward1;
+  v8float *ptr_out = (v8float *)flux_inter1;
+
+  v8float *restrict row1_ptr = (v8float *)row1;
+  v8float *restrict row2_ptr = (v8float *)row2;
+  v8float *restrict row3_ptr = (v8float *)row3;
+
+  // v8float * restrict r1=(v8float *)row1_ptr;
+  // v8float * restrict r2=(v8float *)row2_ptr;
+
+  // v8int32 * restrict row0_ptr=(v8int32 *)row0;
+  // v8int32 * restrict row1_ptr=(v8int32 *)row1;
+  // v8int32 * restrict row2_ptr=(v8int32 *)row2;
+
+  v16float data_buf1 = null_v16float();
+  v16float data_buf2 = null_v16float();
+
+  v8float acc_0 = null_v8float();
+  v8float acc_1 = null_v8float();
+  //  8 x int32 = 256b W vector
+
+  // r1 = ptr_in + 1*COL/8 + aor*COL/8;
+  // r2 = ptr_in + 2*COL/8 + aor*COL/8;
+  data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
+
+  data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+
+  // buf_2=R2 , and buf_1=R3
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v8float flux_sub;
+      // printf("inside flux");
+      // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
+      ptr_forward = (v8float *)flux_forward1 + i;
+      flux_sub = *ptr_forward;
+      // flux_sub=window_readincr_v8(flux_cascade);
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); ///  (lap_ij - lap_ijm)*g
+      acc_1 = fpmsc(acc_1, data_buf2, 1, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ij - lap_ijm)*g - (lap_ij - lap_ijm)*f
+
+      ptr_out = (v8float *)flux_inter1 + i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = acc_1;
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_forward2 + i;
+      flux_sub = *ptr_forward;
+
+      acc_0 = fpmul(data_buf2, 3, 0x76543210, flux_sub, 0,
+                    0x00000000); // (lap_ijp - lap_ij) * h
+      acc_0 = fpmsc(
+          acc_1, data_buf2, 2, 0x76543210, flux_sub, 0,
+          0x00000000); //  (lap_ijp - lap_ij) * h  - (lap_ijp - lap_ij) * g
+
+      ptr_out = (v8float *)flux_inter2 + i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = acc_0;
+
+      /////////////////////////////////////////////////////////////////////////////////////
+
+      /// retrieving flx_imj = lap_ij - lap_imj
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_forward3 + i;
+      flux_sub = *ptr_forward;
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); ///   (lap_ij - lap_imj) * g
+      acc_1 = fpmsc(
+          acc_1, data_buf1, 2, 0x76543210, flux_sub, 0,
+          0x00000000); ///    (lap_ij - lap_imj) * g  *  (lap_ij - lap_imj) * c
+
+      ptr_out = (v8float *)flux_inter3 + i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = acc_1;
+
+      row3_ptr = ((v8float *)(row3)) + i;
+
+      data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // re†rieving flx_ij = lap_ipj - lap_ij
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_forward4 + i;
+      flux_sub = *ptr_forward;
+
+      // below reuisng acc_1 for flux calculation //CHANGED FROM 3 TO 2
+      acc_1 = fpmul(data_buf1, 2, 0x76543210, flux_sub, 0,
+                    0x00000000); //  (lap_ipj - lap_ij) * k
+
+      acc_1 =
+          fpmsc(acc_1, data_buf2, 2, 0x76543210, flux_sub, 0,
+                0x00000000); //  (lap_ipj - lap_ij) * k - (lap_ipj - lap_ij) * g
+
+      ptr_out = (v8float *)flux_inter4 + i;
+      *ptr_out++ = flux_sub;
+      *ptr_out = acc_1;
+
+      // r1 = ptr_in + 1*COL/8 + i+1+ aor*COL/8;
+      row1_ptr = ((v8float *)(row1)) + i + 1;
+      data_buf1 = upd_w(data_buf1, 0, *row1_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row1_ptr);
+
+      ptr_out = (v8float *)flux_inter5 + i;
+      *ptr_out++ = ext_w(data_buf2, 1);
+      *ptr_out = ext_w(data_buf2, 0);
+
+      // LOAD DATA FOR NEXT ITERATION
+      row2_ptr = ((v8float *)(row2)) + i + 1;
+      // data_buf1=*r1++;
+      data_buf2 = upd_w(data_buf2, 0, *row2_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row2_ptr);
+    }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux2.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux2.cc
index ffd717d..2974b42 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux2.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux2.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,121 +9,130 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,  int32_t * restrict out)
+// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,
+// int32_t * restrict out)
 // {
-void hdiff_flux2(int32_t* restrict flux_inter1,int32_t* restrict flux_inter2, int32_t* restrict flux_inter3,int32_t* restrict flux_inter4,int32_t* restrict flux_inter5, int32_t * restrict out)
-{
-    
-    alignas(32) int32_t weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) int32_t flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8int32 coeffs1         = *(v8int32*) weights1;  //  8 x int32 = 256b W vector
-    v8int32 flux_out_coeff=*(v8int32*)flux_out;
-
-    // v8int32 * restrict  ptr_in = (v8int32 *) in;
-    v8int32 * restrict  ptr_forward = (v8int32 *) flux_inter1;
-    v8int32 * ptr_out = (v8int32 *) out;
-    
-
-
-    // v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    // v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    // v8int32 * restrict row2_ptr=(v8int32 *)row2;
-
-    // v16int32   data_buf1=null_v16int32();
-    v16int32  data_buf2=null_v16int32();
-
-    v8acc80 acc_0=null_v8acc80();
-    v8acc80 acc_1=null_v8acc80();
-          //  8 x int32 = 256b W vector
-
-  
-        // // r1 = ptr_in + 1*COL/8 + aor*COL/8;
-        // // r2 = ptr_in + 2*COL/8 + aor*COL/8;
-        // data_buf1 = upd_w(data_buf1, 0, *r1++);
-        // data_buf1 = upd_w(data_buf1, 1, *r1);
-
-        // data_buf2 = upd_w(data_buf2, 0, *r2++);
-        // data_buf2 = upd_w(data_buf2, 1, *r2);
-
-        
-    // buf_2=R2 , and buf_1=R3
-        
-    for (unsigned i = 0; i < COL/8; i++)
-        chess_prepare_for_pipelining
-        chess_loop_range(1,)
-        {
-            v8int32  flux_sub;
-            v8int32  flux_interm_sub;
-            // printf("inside flux");
-            // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
-            ptr_forward = (v8int32 *) flux_inter1+i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-       
-            // compare > 0
-            unsigned int flx_compare_imj=gt16(concat(flux_interm_sub,undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-                        
-            // //Calculate final fly_ijm
-            v16int32 out_flx_inter1=select16(flx_compare_imj,concat(flux_sub,undef_v8int32()),null_v16int32()); 
-
-            //v16int32 flx_out1=add16(null_v16int32(),out_flx_inter1);     //still fly_ijm
-                
-    /////////////////////////////////////////////////////////////////////////////////////
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_inter2+i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-    
-            //Calculates final fly_ij (comparison > 0)
-            unsigned int flx_compare_ij=gt16(concat(flux_interm_sub,undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter2=select16(flx_compare_ij,concat(flux_sub,undef_v8int32()),null_v16int32());    
-
-            //add fly_ij - fly_ijm
-            v16int32 flx_out2=sub16(out_flx_inter2,out_flx_inter1);                             
-/////////////////////////////////////////////////////////////////////////////////////
-
-            /// retrieving flx_imj = lap_ij - lap_imj
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_inter3+i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-
-            //Calculates final flx_imj (comparison > 0)
-            unsigned int fly_compare_ijm=gt16(concat(flux_interm_sub,undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter3=select16(fly_compare_ijm,concat(flux_sub,undef_v8int32()),null_v16int32());
-
-            v16int32 flx_out3=sub16(flx_out2,out_flx_inter3);                     //adds fly_ij - fly_ijm - flx_imj
-/////////////////////////////////////////////////////////////////////////////////////
-             // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-             //re†rieving flx_ij = lap_ipj - lap_ij
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8int32 *) flux_inter4+i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-
-            // final flx_ij (comparison > 0 )
-            unsigned int fly_compare_ij=gt16(concat(flux_interm_sub,undef_v8int32()),0,0x76543210,0xFEDCBA98, null_v16int32(),0,0x76543210,0xFEDCBA98); 
-            v16int32 out_flx_inter4=select16(fly_compare_ij,concat(flux_sub,undef_v8int32()),null_v16int32()); 
-
-            v16int32 flx_out4=add16(flx_out3,out_flx_inter4); //adds fly_ij - fly_ijm - flx_imj + flx_ij
-            
-            ptr_forward = (v8int32 *) flux_inter5+i;
-            v8int32 tmp1 =*ptr_forward++;
-            v8int32 tmp2 = *ptr_forward;
-            data_buf2 = concat(tmp2,tmp1);
-
-            v8acc80 final_output = lmul8  (flx_out4, 0, 0x76543210, flux_out_coeff,    0,0x00000000);  // Multiply by -7s
-            final_output=lmac8(final_output, data_buf2,  2, 0x76543210,concat(coeffs1, undef_v8int32()), 0 , 0x76543210); 
-
-            // window_writeincr(out, srs(final_output,0));
-            *ptr_out++ =  srs(final_output,0);  
-                      
-        }
-    
-
+void hdiff_flux2(int32_t *restrict flux_inter1, int32_t *restrict flux_inter2,
+                 int32_t *restrict flux_inter3, int32_t *restrict flux_inter4,
+                 int32_t *restrict flux_inter5, int32_t *restrict out) {
+
+  alignas(32) int32_t weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) int32_t flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8int32 coeffs1 = *(v8int32 *)weights1; //  8 x int32 = 256b W vector
+  v8int32 flux_out_coeff = *(v8int32 *)flux_out;
+
+  // v8int32 * restrict  ptr_in = (v8int32 *) in;
+  v8int32 *restrict ptr_forward = (v8int32 *)flux_inter1;
+  v8int32 *ptr_out = (v8int32 *)out;
+
+  // v8int32 * restrict row0_ptr=(v8int32 *)row0;
+  // v8int32 * restrict row1_ptr=(v8int32 *)row1;
+  // v8int32 * restrict row2_ptr=(v8int32 *)row2;
+
+  // v16int32   data_buf1=null_v16int32();
+  v16int32 data_buf2 = null_v16int32();
+
+  v8acc80 acc_0 = null_v8acc80();
+  v8acc80 acc_1 = null_v8acc80();
+  //  8 x int32 = 256b W vector
+
+  // // r1 = ptr_in + 1*COL/8 + aor*COL/8;
+  // // r2 = ptr_in + 2*COL/8 + aor*COL/8;
+  // data_buf1 = upd_w(data_buf1, 0, *r1++);
+  // data_buf1 = upd_w(data_buf1, 1, *r1);
+
+  // data_buf2 = upd_w(data_buf2, 0, *r2++);
+  // data_buf2 = upd_w(data_buf2, 1, *r2);
+
+  // buf_2=R2 , and buf_1=R3
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v8int32 flux_sub;
+      v8int32 flux_interm_sub;
+      // printf("inside flux");
+      // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
+      ptr_forward = (v8int32 *)flux_inter1 + i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // compare > 0
+      unsigned int flx_compare_imj =
+          gt16(concat(flux_interm_sub, undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+
+      // //Calculate final fly_ijm
+      v16int32 out_flx_inter1 = select16(
+          flx_compare_imj, concat(flux_sub, undef_v8int32()), null_v16int32());
+
+      // v16int32 flx_out1=add16(null_v16int32(),out_flx_inter1);     //still
+      // fly_ijm
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_inter2 + i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // Calculates final fly_ij (comparison > 0)
+      unsigned int flx_compare_ij =
+          gt16(concat(flux_interm_sub, undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter2 = select16(
+          flx_compare_ij, concat(flux_sub, undef_v8int32()), null_v16int32());
+
+      // add fly_ij - fly_ijm
+      v16int32 flx_out2 = sub16(out_flx_inter2, out_flx_inter1);
+      /////////////////////////////////////////////////////////////////////////////////////
+
+      /// retrieving flx_imj = lap_ij - lap_imj
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_inter3 + i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // Calculates final flx_imj (comparison > 0)
+      unsigned int fly_compare_ijm =
+          gt16(concat(flux_interm_sub, undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter3 = select16(
+          fly_compare_ijm, concat(flux_sub, undef_v8int32()), null_v16int32());
+
+      v16int32 flx_out3 =
+          sub16(flx_out2, out_flx_inter3); // adds fly_ij - fly_ijm - flx_imj
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // re†rieving flx_ij = lap_ipj - lap_ij
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8int32 *)flux_inter4 + i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // final flx_ij (comparison > 0 )
+      unsigned int fly_compare_ij =
+          gt16(concat(flux_interm_sub, undef_v8int32()), 0, 0x76543210,
+               0xFEDCBA98, null_v16int32(), 0, 0x76543210, 0xFEDCBA98);
+      v16int32 out_flx_inter4 = select16(
+          fly_compare_ij, concat(flux_sub, undef_v8int32()), null_v16int32());
+
+      v16int32 flx_out4 = add16(
+          flx_out3, out_flx_inter4); // adds fly_ij - fly_ijm - flx_imj + flx_ij
+
+      ptr_forward = (v8int32 *)flux_inter5 + i;
+      v8int32 tmp1 = *ptr_forward++;
+      v8int32 tmp2 = *ptr_forward;
+      data_buf2 = concat(tmp2, tmp1);
+
+      v8acc80 final_output = lmul8(flx_out4, 0, 0x76543210, flux_out_coeff, 0,
+                                   0x00000000); // Multiply by -7s
+      final_output = lmac8(final_output, data_buf2, 2, 0x76543210,
+                           concat(coeffs1, undef_v8int32()), 0, 0x76543210);
+
+      // window_writeincr(out, srs(final_output,0));
+      *ptr_out++ = srs(final_output, 0);
+    }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux2_fp32.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux2_fp32.cc
index b9181d2..e71dd6f 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux2_fp32.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_flux2_fp32.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,121 +9,132 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,  int32_t * restrict out)
+// void hdiff_flux(int32_t * restrict in, int32_t * restrict  flux_forward,
+// int32_t * restrict out)
 // {
-void hdiff_flux2_fp32(float* restrict flux_inter1,float* restrict flux_inter2, float* restrict flux_inter3,float* restrict flux_inter4,float* restrict flux_inter5, float * restrict out)
-{
-    
-    alignas(32) float weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) float flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8float coeffs1        = *(v8float*) weights1;  //  8 x int32 = 256b W vector
-    v8float flux_out_coeff = *(v8float*) flux_out;
-
-    // v8int32 * restrict  ptr_in = (v8int32 *) in;
-    v8float * restrict  ptr_forward = (v8float *) flux_inter1;
-    v8float * ptr_out = (v8float *) out;
-    
-
-
-    // v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    // v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    // v8int32 * restrict row2_ptr=(v8int32 *)row2;
-
-    // v16int32   data_buf1=null_v16int32();
-    v16float  data_buf2=null_v16float();
-
-    v8float acc_0 = null_v8float();
-    v8float acc_1 = null_v8float();
-          //  8 x int32 = 256b W vector
-
-  
-        // // r1 = ptr_in + 1*COL/8 + aor*COL/8;
-        // // r2 = ptr_in + 2*COL/8 + aor*COL/8;
-        // data_buf1 = upd_w(data_buf1, 0, *r1++);
-        // data_buf1 = upd_w(data_buf1, 1, *r1);
-
-        // data_buf2 = upd_w(data_buf2, 0, *r2++);
-        // data_buf2 = upd_w(data_buf2, 1, *r2);
-
-        
-    // buf_2=R2 , and buf_1=R3
-        
-    for (unsigned i = 0; i < COL/8; i++)
-        chess_prepare_for_pipelining
-        chess_loop_range(1,)
-        {
-            v8float  flux_sub;
-            v8float  flux_interm_sub;
-            // printf("inside flux");
-            // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
-            ptr_forward = (v8float *) flux_inter1+i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-       
-            // compare > 0
-            unsigned int flx_compare_imj=fpge (acc_1, null_v16float(), 0,0x76543210); /// flx_ijm * (test_in[d][c][r] - test_in[d][c][r-1]) > 0 ? 0 :
-                         
-            // //Calculate final fly_ijm
-            v16float out_flx_inter1=fpselect16(flx_compare_imj,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-                  
-            v8float flx_out1=fpadd(null_v8float(),out_flx_inter1,0,0x76543210);   //still fly_ijm
-
-    /////////////////////////////////////////////////////////////////////////////////////
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8float *) flux_inter2+i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-    
-            //Calculates final fly_ij (comparison > 0)
-            unsigned int flx_compare_ij=fpge (acc_1, null_v16float(), 0,0x76543210); 
-            v16float out_flx_inter2=fpselect16(flx_compare_ij,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-                        
-                //fly_ijm -fly_ij
-            v8float flx_out2=fpsub(flx_out1,out_flx_inter2,0,0x76543210);                          
-/////////////////////////////////////////////////////////////////////////////////////
-
-            /// retrieving flx_imj = lap_ij - lap_imj
-            // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8float *) flux_inter3+i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-
-            //Calculates final flx_imj (comparison > 0)
-            unsigned int fly_compare_ijm=fpge (acc_1, null_v16float(), 0,0x76543210);
-            v16float out_flx_inter3=fpselect16(fly_compare_ijm,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-        
-            v8float flx_out3=fpadd(flx_out2,out_flx_inter3,0,0x76543210);     //adds fly_ijm -fly_ij + flx_imj 
-
-/////////////////////////////////////////////////////////////////////////////////////
-             // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
-             //re†rieving flx_ij = lap_ipj - lap_ij
-            // flux_sub=window_readincr_v8(flux_cascade);
-            ptr_forward = (v8float *) flux_inter4+i;
-            flux_sub=*ptr_forward++;
-            flux_interm_sub=*ptr_forward;
-
-            // final flx_ij (comparison > 0 )
-            unsigned int fly_compare_ij=fpge (acc_1, null_v16float(), 0,0x76543210);
-            v16float out_flx_inter4=fpselect16(fly_compare_ij,concat(flux_sub,null_v8float()),0, 0x76543210, 0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
-            
-            v8float flx_out4=fpsub(flx_out3,out_flx_inter4,0,0x76543210); //adds  fly_ijm -fly_ij + flx_imj -flx_ij
-            
-            ptr_forward = (v8float *) flux_inter5+i;
-            v8float tmp1 =*ptr_forward++;
-            v8float tmp2 = *ptr_forward;
-            data_buf2 = concat(tmp1,tmp2);
-
-            v8float   final_output=fpmul  (concat(flx_out4,null_v8float()),0,0x76543210,flux_out_coeff,    0,0x00000000);  // Multiply by +7s
-            final_output=fpmac(final_output,data_buf2,  2, 0x76543210,coeffs1, 0 , 0x76543210); 
-            // window_writeincr(out, srs(final_output,0));
-            *ptr_out++ =  final_output;  
-                      
-        }
-    
-
+void hdiff_flux2_fp32(float *restrict flux_inter1, float *restrict flux_inter2,
+                      float *restrict flux_inter3, float *restrict flux_inter4,
+                      float *restrict flux_inter5, float *restrict out) {
+
+  alignas(32) float weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) float flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8float coeffs1 = *(v8float *)weights1; //  8 x int32 = 256b W vector
+  v8float flux_out_coeff = *(v8float *)flux_out;
+
+  // v8int32 * restrict  ptr_in = (v8int32 *) in;
+  v8float *restrict ptr_forward = (v8float *)flux_inter1;
+  v8float *ptr_out = (v8float *)out;
+
+  // v8int32 * restrict row0_ptr=(v8int32 *)row0;
+  // v8int32 * restrict row1_ptr=(v8int32 *)row1;
+  // v8int32 * restrict row2_ptr=(v8int32 *)row2;
+
+  // v16int32   data_buf1=null_v16int32();
+  v16float data_buf2 = null_v16float();
+
+  v8float acc_0 = null_v8float();
+  v8float acc_1 = null_v8float();
+  //  8 x int32 = 256b W vector
+
+  // // r1 = ptr_in + 1*COL/8 + aor*COL/8;
+  // // r2 = ptr_in + 2*COL/8 + aor*COL/8;
+  // data_buf1 = upd_w(data_buf1, 0, *r1++);
+  // data_buf1 = upd_w(data_buf1, 1, *r1);
+
+  // data_buf2 = upd_w(data_buf2, 0, *r2++);
+  // data_buf2 = upd_w(data_buf2, 1, *r2);
+
+  // buf_2=R2 , and buf_1=R3
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v8float flux_sub;
+      v8float flux_interm_sub;
+      // printf("inside flux");
+      // v8acc80 acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flx_imj=window_readincr_v8(flux_cascade); //flx_imj
+      ptr_forward = (v8float *)flux_inter1 + i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // compare > 0
+      unsigned int flx_compare_imj =
+          fpge(acc_1, null_v16float(), 0,
+               0x76543210); /// flx_ijm * (test_in[d][c][r] -
+                            /// test_in[d][c][r-1]) > 0 ? 0 :
+
+      // //Calculate final fly_ijm
+      v16float out_flx_inter1 = fpselect16(
+          flx_compare_imj, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      v8float flx_out1 =
+          fpadd(null_v8float(), out_flx_inter1, 0, 0x76543210); // still fly_ijm
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_inter2 + i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // Calculates final fly_ij (comparison > 0)
+      unsigned int flx_compare_ij = fpge(acc_1, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter2 = fpselect16(
+          flx_compare_ij, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      // fly_ijm -fly_ij
+      v8float flx_out2 = fpsub(flx_out1, out_flx_inter2, 0, 0x76543210);
+      /////////////////////////////////////////////////////////////////////////////////////
+
+      /// retrieving flx_imj = lap_ij - lap_imj
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_inter3 + i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // Calculates final flx_imj (comparison > 0)
+      unsigned int fly_compare_ijm =
+          fpge(acc_1, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter3 = fpselect16(
+          fly_compare_ijm, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      v8float flx_out3 = fpadd(flx_out2, out_flx_inter3, 0,
+                               0x76543210); // adds fly_ijm -fly_ij + flx_imj
+
+      /////////////////////////////////////////////////////////////////////////////////////
+      // acc_flux = concat(get_scd_v4acc80(),get_scd_v4acc80());
+      // re†rieving flx_ij = lap_ipj - lap_ij
+      // flux_sub=window_readincr_v8(flux_cascade);
+      ptr_forward = (v8float *)flux_inter4 + i;
+      flux_sub = *ptr_forward++;
+      flux_interm_sub = *ptr_forward;
+
+      // final flx_ij (comparison > 0 )
+      unsigned int fly_compare_ij = fpge(acc_1, null_v16float(), 0, 0x76543210);
+      v16float out_flx_inter4 = fpselect16(
+          fly_compare_ij, concat(flux_sub, null_v8float()), 0, 0x76543210,
+          0xFEDCBA98, null_v16float(), 0, 0x76543210, 0xFEDCBA98);
+
+      v8float flx_out4 =
+          fpsub(flx_out3, out_flx_inter4, 0,
+                0x76543210); // adds  fly_ijm -fly_ij + flx_imj -flx_ij
+
+      ptr_forward = (v8float *)flux_inter5 + i;
+      v8float tmp1 = *ptr_forward++;
+      v8float tmp2 = *ptr_forward;
+      data_buf2 = concat(tmp1, tmp2);
+
+      v8float final_output =
+          fpmul(concat(flx_out4, null_v8float()), 0, 0x76543210, flux_out_coeff,
+                0, 0x00000000); // Multiply by +7s
+      final_output =
+          fpmac(final_output, data_buf2, 2, 0x76543210, coeffs1, 0, 0x76543210);
+      // window_writeincr(out, srs(final_output,0));
+      *ptr_out++ = final_output;
+    }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_lap.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_lap.cc
index 63a0ee7..6bcae3f 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_lap.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_lap.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,171 +9,194 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-//align to 16 bytes boundary, equivalent to "alignas(v4int32)"
-void hdiff_lap(int32_t* restrict row0, int32_t* restrict row1,int32_t* restrict row2,int32_t* restrict row3,int32_t* restrict row4, int32_t* restrict out_flux1, int32_t* restrict out_flux2, int32_t* restrict out_flux3, int32_t* restrict out_flux4 )
-{
-
- // const int32_t *restrict w = weights;
-    alignas(32) int32_t weights[8] = {-4,-4,-4,-4,-4,-4,-4,-4};
-    alignas(32) int32_t weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) int32_t weights_rest[8] = {-1,-1,-1,-1,-1,-1,-1,-1};
-    alignas(32) int32_t flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8int32 coeffs         = *(v8int32*) weights;  //  8 x int32 = 256b W vector
-    v8int32 coeffs1        = *(v8int32*) weights1;  //  8 x int32 = 256b W vector
-    v8int32 coeffs_rest    = *(v8int32*) weights_rest;  //  8 x int32 = 256b W vector
-    v8int32 flux_out_coeff = *(v8int32*) flux_out;
-
-    // v8int32 * restrict ptr_in = (v8int32 *) in;
-    v8int32 * ptr_out = (v8int32 *) out_flux1;
-    v8int32 * restrict row0_ptr=(v8int32 *)row0;
-    v8int32 * restrict row1_ptr=(v8int32 *)row1;
-    v8int32 * restrict row2_ptr=(v8int32 *)row2;
-    v8int32 * restrict row3_ptr=(v8int32 *)row3;
-    v8int32 * restrict row4_ptr=(v8int32 *)row4;
-    v8int32 * restrict r1;
-    // v8int32 * restrict r2;
-    // v8int32 * restrict r2=ptr_in+1*COL/8;
-
-    v16int32 data_buf1 = null_v16int32();
-    v16int32 data_buf2 = null_v16int32();;
-    
-    v8acc80 acc_0 = null_v8acc80();
-    v8acc80 acc_1 = null_v8acc80();
-
-    //  v8acc80 acc_1=null_v8acc80();        
-    v8int32 lap_ij = null_v8int32();      //  8 x int32 = 256b W vector
-    v8int32 lap_0  = null_v8int32();      //  8 x int32 = 256b W vector
-
-
-
-        data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-        data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
-    
-        for (unsigned i = 0; i < COL/8; i++)
-            chess_prepare_for_pipelining
-                    chess_loop_range(1,)
-        {   
-            v16int32 flux_sub;
-
-            acc_0=lmul8   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);          //c           
-            acc_1=lmul8   (data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);          //b
-          
-            acc_0=lmac8   (acc_0,data_buf1,2,0x76543210,coeffs_rest,    0,0x00000000);    //c,k
-            acc_1=lmac8   (acc_1,data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);    //b,j
-          
-            // r2 = ptr_in+2 * COL/8+i ;
-            row2_ptr=((v8int32 *) (row2))+i;
-            data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
-
-            acc_0=lmac8   (acc_0,data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000); //c,k,f
-            acc_0=lmsc8   (acc_0,data_buf2,2,0x76543210,coeffs,    0,0x00000000);      //c,k,f,4*g
-            acc_0=lmac8   (acc_0,data_buf2,3,0x76543210,coeffs_rest,    0,0x00000000);  //c,k,f,4*g,h
-            
-            lap_ij=srs(acc_0,0); //store lap_ij
-
-            acc_1=lmac8   (acc_1,data_buf2,0,0x76543210,coeffs_rest,    0,0x00000000); //b,j,e
-            acc_1=lmsc8   (acc_1,data_buf2,1,0x76543210,coeffs,    0,0x00000000);      //b,j,e,4*f
-            acc_1=lmac8   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);  //b,j,e,4*f,g  
-           
-            //lap_ijm
-            lap_0=srs(acc_1,0);
-            
-            //Calculate  lap_ij - lap_ijm
-            flux_sub = sub16(concat(lap_ij,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_0,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 ); 
-            ptr_out = (v8int32 *) out_flux1+i;
-            *ptr_out =  ext_w(flux_sub,0);
-            //
-          
-            acc_0=lmul8   (data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);   // l
-            acc_0=lmsc8   (acc_0,data_buf2,3,0x76543210,coeffs,    0,0x00000000);  // l, 4*h
-        
-
-            // r1 = ptr_in+1 * COL/8+i ;
-            row1_ptr=((v8int32 *) (row1))+i;
-            data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));     
-
-            acc_0=lmac8  (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);  // l, 4*h, g
-            acc_0=lmac8   (acc_0,data_buf2,4,0x76543210,coeffs_rest,    0,0x00000000); // l, 4*h, g, i 
-
-                      
-            acc_0=lmac8   (acc_0,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);// l, 4*h, g, i, d 
-            
-            //Calculates lap_ijp
-            lap_0=srs(acc_0,0); 
-
-            //Calculates lap_ijp - lap_ij
-            flux_sub = sub16(concat(lap_0,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_ij,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 );
-            ptr_out= (v8int32 *) out_flux2+i;
-            *ptr_out=  ext_w(flux_sub,0);
-                 
-
-            //***********************************************************************STARTING X FLUX*****************************************************************************************************************************************************
-            
-            acc_1=lmul8    ( data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000); // g                     
-            acc_0=lmul8   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);   // g
-
-            // r2 = ptr_in + 0*COL/8 + i ; 
-            row0_ptr=((v8int32 *) (row0))+i;
-            data_buf2 = upd_w(data_buf2, 0, *(row0_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row0_ptr));
-                  
-            acc_1=lmsc8    (acc_1, data_buf1,2,0x76543210,coeffs,    0,0x00000000);             // g, 4*c
-            acc_1=lmac8    (acc_1, data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);        // g, 4*c, b
-            acc_1=lmac8   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);          // g, 4*c, b, a
-          
-            // r2 = ptr_in + 4*COL/8 + i ; 
-            row4_ptr=((v8int32 *) (row4))+i;
-            data_buf2 = upd_w(data_buf2, 0, *(row4_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row4_ptr));
-
-            acc_1=lmac8    ( acc_1,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b, a, d               
-            acc_0=lmac8   (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);         // g, m
-   
-            
-            //Calculates lap_imj
-            lap_0=srs(acc_1,0); 
-
-            flux_sub = sub16(concat(lap_ij,undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,  concat(lap_0,undef_v8int32()), 0,  0x76543210, 0xFEDCBA98 ); 
-            ptr_out= (v8int32 *) out_flux3+i;
-            *ptr_out =  ext_w(flux_sub,0);
-
-            
-            // r1 = ptr_in + 3*COL/8 + i ;
-            row3_ptr=((v8int32 *) (row3))+i;
-            data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
-
-            acc_0=lmsc8   (acc_0,data_buf1,2,0x76543210,coeffs,    0,0x00000000); //g, m , k * 4
-
-            // v16int32 flx_out3=sub16(flx_out2,out_flx_inter3);                     //adds fly_ij - fly_ijm - flx_imj
-
-            acc_0=lmac8   (acc_0,data_buf1, 1,0x76543210,coeffs_rest,    0,0x00000000);     //g, m , k * 4, j 
-            
-            //LOAD DATA FOR NEXT ITERATION
-            row1_ptr=((v8int32 *) (row1))+i+1;
-            data_buf2 = upd_w(data_buf2, 0, *(row1_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row1_ptr));
-
-            acc_0=lmac8   (acc_0,data_buf1, 3,0x76543210,coeffs_rest,    0,0x00000000);     //g, m , k * 4, j, l  
-
-            //  flx_ij = lap_ipj - lap_ij
-            flux_sub = sub16(concat(srs(acc_0,0),undef_v8int32()), 0, 0x76543210, 0xFEDCBA98, concat(lap_ij,undef_v8int32()),   0,  0x76543210, 0xFEDCBA98 ); 
-            ptr_out= (v8int32 *) out_flux4+i;
-            *ptr_out =  ext_w(flux_sub,0);
-
-             
-            //LOAD DATA FOR NEXT ITERATION
-            row3_ptr=((v8int32 *) (row3))+i+1;
-            data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
-
-        // }
-
+// align to 16 bytes boundary, equivalent to "alignas(v4int32)"
+void hdiff_lap(int32_t *restrict row0, int32_t *restrict row1,
+               int32_t *restrict row2, int32_t *restrict row3,
+               int32_t *restrict row4, int32_t *restrict out_flux1,
+               int32_t *restrict out_flux2, int32_t *restrict out_flux3,
+               int32_t *restrict out_flux4) {
+
+  // const int32_t *restrict w = weights;
+  alignas(32) int32_t weights[8] = {-4, -4, -4, -4, -4, -4, -4, -4};
+  alignas(32) int32_t weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) int32_t weights_rest[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
+  alignas(32) int32_t flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8int32 coeffs = *(v8int32 *)weights;           //  8 x int32 = 256b W vector
+  v8int32 coeffs1 = *(v8int32 *)weights1;         //  8 x int32 = 256b W vector
+  v8int32 coeffs_rest = *(v8int32 *)weights_rest; //  8 x int32 = 256b W vector
+  v8int32 flux_out_coeff = *(v8int32 *)flux_out;
+
+  // v8int32 * restrict ptr_in = (v8int32 *) in;
+  v8int32 *ptr_out = (v8int32 *)out_flux1;
+  v8int32 *restrict row0_ptr = (v8int32 *)row0;
+  v8int32 *restrict row1_ptr = (v8int32 *)row1;
+  v8int32 *restrict row2_ptr = (v8int32 *)row2;
+  v8int32 *restrict row3_ptr = (v8int32 *)row3;
+  v8int32 *restrict row4_ptr = (v8int32 *)row4;
+  v8int32 *restrict r1;
+  // v8int32 * restrict r2;
+  // v8int32 * restrict r2=ptr_in+1*COL/8;
+
+  v16int32 data_buf1 = null_v16int32();
+  v16int32 data_buf2 = null_v16int32();
+  ;
+
+  v8acc80 acc_0 = null_v8acc80();
+  v8acc80 acc_1 = null_v8acc80();
+
+  //  v8acc80 acc_1=null_v8acc80();
+  v8int32 lap_ij = null_v8int32(); //  8 x int32 = 256b W vector
+  v8int32 lap_0 = null_v8int32();  //  8 x int32 = 256b W vector
+
+  data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+  data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v16int32 flux_sub;
+
+      acc_0 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // c
+      acc_1 = lmul8(data_buf2, 1, 0x76543210, coeffs_rest, 0, 0x00000000); // b
+
+      acc_0 = lmac8(acc_0, data_buf1, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k
+      acc_1 = lmac8(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j
+
+      // r2 = ptr_in+2 * COL/8+i ;
+      row2_ptr = ((v8int32 *)(row2)) + i;
+      data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
+
+      acc_0 = lmac8(acc_0, data_buf2, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k,f
+      acc_0 = lmsc8(acc_0, data_buf2, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // c,k,f,4*g
+      acc_0 = lmac8(acc_0, data_buf2, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // c,k,f,4*g,h
+
+      lap_ij = srs(acc_0, 0); // store lap_ij
+
+      acc_1 = lmac8(acc_1, data_buf2, 0, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j,e
+      acc_1 = lmsc8(acc_1, data_buf2, 1, 0x76543210, coeffs, 0,
+                    0x00000000); // b,j,e,4*f
+      acc_1 = lmac8(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // b,j,e,4*f,g
+
+      // lap_ijm
+      lap_0 = srs(acc_1, 0);
+
+      // Calculate  lap_ij - lap_ijm
+      flux_sub =
+          sub16(concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+      ptr_out = (v8int32 *)out_flux1 + i;
+      *ptr_out = ext_w(flux_sub, 0);
+      //
+
+      acc_0 = lmul8(data_buf1, 3, 0x76543210, coeffs_rest, 0, 0x00000000); // l
+      acc_0 = lmsc8(acc_0, data_buf2, 3, 0x76543210, coeffs, 0,
+                    0x00000000); // l, 4*h
+
+      // r1 = ptr_in+1 * COL/8+i ;
+      row1_ptr = ((v8int32 *)(row1)) + i;
+      data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));
+
+      acc_0 = lmac8(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g
+      acc_0 = lmac8(acc_0, data_buf2, 4, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g, i
+
+      acc_0 = lmac8(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // l, 4*h, g, i, d
+
+      // Calculates lap_ijp
+      lap_0 = srs(acc_0, 0);
+
+      // Calculates lap_ijp - lap_ij
+      flux_sub =
+          sub16(concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+      ptr_out = (v8int32 *)out_flux2 + i;
+      *ptr_out = ext_w(flux_sub, 0);
+
+      //***********************************************************************STARTING
+      //X
+      //FLUX*****************************************************************************************************************************************************
+
+      acc_1 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+      acc_0 = lmul8(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+
+      // r2 = ptr_in + 0*COL/8 + i ;
+      row0_ptr = ((v8int32 *)(row0)) + i;
+      data_buf2 = upd_w(data_buf2, 0, *(row0_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row0_ptr));
+
+      acc_1 = lmsc8(acc_1, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, 4*c
+      acc_1 = lmac8(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b
+      acc_1 = lmac8(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a
+
+      // r2 = ptr_in + 4*COL/8 + i ;
+      row4_ptr = ((v8int32 *)(row4)) + i;
+      data_buf2 = upd_w(data_buf2, 0, *(row4_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row4_ptr));
+
+      acc_1 = lmac8(acc_1, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a, d
+      acc_0 = lmac8(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m
+
+      // Calculates lap_imj
+      lap_0 = srs(acc_1, 0);
+
+      flux_sub =
+          sub16(concat(lap_ij, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98,
+                concat(lap_0, undef_v8int32()), 0, 0x76543210, 0xFEDCBA98);
+      ptr_out = (v8int32 *)out_flux3 + i;
+      *ptr_out = ext_w(flux_sub, 0);
+
+      // r1 = ptr_in + 3*COL/8 + i ;
+      row3_ptr = ((v8int32 *)(row3)) + i;
+      data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
+
+      acc_0 = lmsc8(acc_0, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, m , k * 4
+
+      // v16int32 flx_out3=sub16(flx_out2,out_flx_inter3); //adds fly_ij -
+      // fly_ijm - flx_imj
+
+      acc_0 = lmac8(acc_0, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m , k * 4, j
+
+      // LOAD DATA FOR NEXT ITERATION
+      row1_ptr = ((v8int32 *)(row1)) + i + 1;
+      data_buf2 = upd_w(data_buf2, 0, *(row1_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row1_ptr));
+
+      acc_0 = lmac8(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, m , k * 4, j, l
+
+      //  flx_ij = lap_ipj - lap_ij
+      flux_sub = sub16(concat(srs(acc_0, 0), undef_v8int32()), 0, 0x76543210,
+                       0xFEDCBA98, concat(lap_ij, undef_v8int32()), 0,
+                       0x76543210, 0xFEDCBA98);
+      ptr_out = (v8int32 *)out_flux4 + i;
+      *ptr_out = ext_w(flux_sub, 0);
+
+      // LOAD DATA FOR NEXT ITERATION
+      row3_ptr = ((v8int32 *)(row3)) + i + 1;
+      data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
+
+      // }
     }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_lap_fp32.cc b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_lap_fp32.cc
index c134825..dbc760e 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_lap_fp32.cc
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/hdiff_lap_fp32.cc
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -9,168 +9,182 @@
 #define kernel_load 14
 // typedef int int32;
 
-
-//align to 16 bytes boundary, equivalent to "alignas(v4int32)"
-void hdiff_lap_fp32(float* restrict row0, float* restrict row1,float* restrict row2,float* restrict row3,float* restrict row4, float* restrict out_flux1, float* restrict out_flux2, float* restrict out_flux3, float* restrict out_flux4 )
-{
-
- // const float *restrict w = weights;
-    alignas(32) float weights[8] = {-4,-4,-4,-4,-4,-4,-4,-4};
-    alignas(32) float weights1[8] = {1,1,1,1,1,1,1,1};
-    alignas(32) float weights_rest[8] = {-1,-1,-1,-1,-1,-1,-1,-1};
-    alignas(32) float flux_out[8]={-7,-7,-7,-7,-7,-7,-7,-7};
-
-    v8float coeffs         = *(v8float*) weights;  //  8 x int32 = 256b W vector
-    v8float coeffs1        = *(v8float*) weights1;  //  8 x int32 = 256b W vector
-    v8float coeffs_rest    = *(v8float*) weights_rest;  //  8 x int32 = 256b W vector
-    v8float flux_out_coeff = *(v8float*) flux_out;
-
-    // v8float * restrict ptr_in = (v8float *) in;
-    v8float * ptr_out = (v8float *) out_flux1;
-    v8float * restrict row0_ptr=(v8float *)row0;
-    v8float * restrict row1_ptr=(v8float *)row1;
-    v8float * restrict row2_ptr=(v8float *)row2;
-    v8float * restrict row3_ptr=(v8float *)row3;
-    v8float * restrict row4_ptr=(v8float *)row4;
-    v8float * restrict r1;
-    // v8float * restrict r2=ptr_in+1*COL/8;
-
-    v16float   data_buf1=null_v16float();
-    v16float  data_buf2=null_v16float();
-    
-    v8float acc_0 = null_v8float();
-    v8float acc_1 = null_v8float();
-
-    //  v8acc80 acc_1=null_v8acc80();        
-    v8float lap_ij = null_v8float();      //  8 x int32 = 256b W vector
-    v8float lap_0  = null_v8float();      //  8 x int32 = 256b W vector
-
-
-
-        data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-        data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-        data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
-        data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
-    
-        for (unsigned i = 0; i < COL/8; i++)
-            chess_prepare_for_pipelining
-                    chess_loop_range(1,)
-        {   
-            v8float flux_sub;
-
-            lap_ij=fpmul (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///  //c            
-            acc_1=fpmul(data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);        //b
-          
-            lap_ij=fpmac   (lap_ij,data_buf1,2,0x76543210,coeffs_rest,    0,0x00000000);///  //c,k 
-            acc_1=fpmac   (acc_1,data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);///  //b,j
-          
-            // r2 = ptr_in+2 * COL/8+i ;
-            row2_ptr=((v8float *) (row2))+i;
-            data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
-
-            ///////// **************************LAP_ij**************************************
-            lap_ij=fpmac   (lap_ij,data_buf2,1,0x76543210,coeffs_rest,    0,0x00000000);///  //c,k,f
-            lap_ij=fpmsc   (lap_ij,data_buf2,2,0x76543210,coeffs,    0,0x00000000);///  //c,k,f,4*g
-            lap_ij=fpmac   (lap_ij,data_buf2,3,0x76543210,coeffs_rest,    0,0x00000000);///  c,k,f,4*g,h
-        
-                ///////// **************************LAP_ijm**************************************               
-            acc_1=fpmac   (acc_1,data_buf2,0,0x76543210,coeffs_rest,    0,0x00000000);///  //b,j,e         
-            acc_1=fpmsc   (acc_1,data_buf2,1,0x76543210,coeffs,    0,0x00000000);///         //b,j,e,4*f   
-            acc_1=fpmac   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///     //b,j,e,4*f,g   
-        
-            //Calculate  lap_ij - lap_ijm
-            flux_sub = fpsub(lap_ij, concat(acc_1,undef_v8float()), 0, 0x76543210); // flx_imj = lap_ij - lap_ijm;
-            ptr_out = (v8float *) out_flux1+i;
-            *ptr_out =  flux_sub;
-            //
-          
-            acc_0=fpmul   (data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);/// // l ; R1 is already loaded
-            acc_0=fpmsc   (acc_0,data_buf2,3,0x76543210,coeffs,    0,0x00000000);///   // l, 4*h
-        
-
-            // r1 = ptr_in+1 * COL/8+i ;
-            row1_ptr=((v8float *) (row1))+i;
-            data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));    
-
-            acc_0=fpmac  (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///  lap_ijp // l, 4*h, g
-            acc_0=fpmac   (acc_0,data_buf2,4,0x76543210,coeffs_rest,    0,0x00000000);///  l, 4*h, g, i   
-
-                      
-            acc_0=fpmac   (acc_0,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);///  // l, 4*h, g, i, d  
-
-            flux_sub = fpsub(acc_0, concat(lap_ij,undef_v8float()), 0, 0x76543210); 
-            ptr_out= (v8float *) out_flux2+i;
-            *ptr_out=  flux_sub;
-                 
-
-          
-            acc_1=fpmul    ( data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);        // g                
-            acc_0=fpmul   (data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);// g   
-
-            // r2 = ptr_in + 0*COL/8 + i ; 
-            row0_ptr=((v8float *) (row0))+i;
-            // r2 = ptr_in + 0*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm 
-            data_buf2 = upd_w(data_buf2, 0, *row0_ptr++);
-            data_buf2 = upd_w(data_buf2, 1, *row0_ptr);
-                
-            acc_1=fpmsc    (acc_1, data_buf1,2,0x76543210,coeffs,    0,0x00000000);      // g, 4*c
-            acc_1=fpmac    (acc_1, data_buf1,1,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b
-            acc_1=fpmac   (acc_1,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);/// // g, 4*c, b, a
-          
-            // r2 = ptr_in + 4*COL/8 + i ; 
-            row4_ptr=((v8float *) (row4))+i;
-            // r2 = ptr_in + 4*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm 
-            data_buf2 = upd_w(data_buf2, 0, *row4_ptr++);
-            data_buf2 = upd_w(data_buf2, 1, *row4_ptr);
-                //////// **************************LAP_ipj for fly_ij since r2=R4********
-            acc_1=fpmac    ( acc_1,data_buf1,3,0x76543210,coeffs_rest,    0,0x00000000);       // g, 4*c, b, a, d  
-            acc_0=fpmac   (acc_0,data_buf2,2,0x76543210,coeffs_rest,    0,0x00000000);///   // g, m
-
-            
-            // //Calculates lap_imj
-            // lap_0=srs(acc_1,0); 
-
-            flux_sub = fpsub(lap_ij, concat(acc_1,undef_v8float()), 0, 0x76543210); 
-            ptr_out= (v8float *) out_flux3+i;
-            *ptr_out =  flux_sub;
-
-            
-            // r1 = ptr_in + 3*COL/8 + i ;
-            row3_ptr=((v8float *) (row3))+i;
-            // r1 = ptr_in + 3*COL/8 + i + aor*COL/8; // load for LAP_ijp for fly_ij
-            // data_buf1=*r1++;
-            data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
-            data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
-
-            acc_0=fpmsc   (acc_0,data_buf1,2,0x76543210,coeffs,    0,0x00000000);///  //g, m , k * 4
-
-            // v16int32 flx_out3=sub16(flx_out2,out_flx_inter3);                     //adds fly_ij - fly_ijm - flx_imj
-
-            acc_0=fpmac   (acc_0,data_buf1, 1,0x76543210,coeffs_rest,    0,0x00000000);///  //g, m , k * 4, j   
-           
-           //LOAD DATA FOR NEXT ITERATION
-            // r2 = ptr_in + 1*COL/8 + i + 1 ;
-            row1_ptr=((v8float *) (row1))+i+1;
-            data_buf2 = upd_w(data_buf2, 0, *(row1_ptr)++);
-            data_buf2 = upd_w(data_buf2, 1, *(row1_ptr));
-            acc_0=fpmac   (acc_0,data_buf1, 3,0x76543210,coeffs_rest,    0,0x00000000);///   //g, m , k * 4, j, l 
-           
-
-            //  flx_ij = lap_ipj - lap_ij
-            flux_sub = fpsub(acc_0, concat(lap_ij,undef_v8float()), 0, 0x76543210);
-            ptr_out= (v8float *) out_flux4+i;
-            *ptr_out =  flux_sub;
-
-             //LOAD DATA FOR NEXT ITERATION
-            row3_ptr=((v8float *) (row3))+i+1;
-            data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
-            data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
-             
-            
-
-        // }
-
+// align to 16 bytes boundary, equivalent to "alignas(v4int32)"
+void hdiff_lap_fp32(float *restrict row0, float *restrict row1,
+                    float *restrict row2, float *restrict row3,
+                    float *restrict row4, float *restrict out_flux1,
+                    float *restrict out_flux2, float *restrict out_flux3,
+                    float *restrict out_flux4) {
+
+  // const float *restrict w = weights;
+  alignas(32) float weights[8] = {-4, -4, -4, -4, -4, -4, -4, -4};
+  alignas(32) float weights1[8] = {1, 1, 1, 1, 1, 1, 1, 1};
+  alignas(32) float weights_rest[8] = {-1, -1, -1, -1, -1, -1, -1, -1};
+  alignas(32) float flux_out[8] = {-7, -7, -7, -7, -7, -7, -7, -7};
+
+  v8float coeffs = *(v8float *)weights;           //  8 x int32 = 256b W vector
+  v8float coeffs1 = *(v8float *)weights1;         //  8 x int32 = 256b W vector
+  v8float coeffs_rest = *(v8float *)weights_rest; //  8 x int32 = 256b W vector
+  v8float flux_out_coeff = *(v8float *)flux_out;
+
+  // v8float * restrict ptr_in = (v8float *) in;
+  v8float *ptr_out = (v8float *)out_flux1;
+  v8float *restrict row0_ptr = (v8float *)row0;
+  v8float *restrict row1_ptr = (v8float *)row1;
+  v8float *restrict row2_ptr = (v8float *)row2;
+  v8float *restrict row3_ptr = (v8float *)row3;
+  v8float *restrict row4_ptr = (v8float *)row4;
+  v8float *restrict r1;
+  // v8float * restrict r2=ptr_in+1*COL/8;
+
+  v16float data_buf1 = null_v16float();
+  v16float data_buf2 = null_v16float();
+
+  v8float acc_0 = null_v8float();
+  v8float acc_1 = null_v8float();
+
+  //  v8acc80 acc_1=null_v8acc80();
+  v8float lap_ij = null_v8float(); //  8 x int32 = 256b W vector
+  v8float lap_0 = null_v8float();  //  8 x int32 = 256b W vector
+
+  data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+  data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+  data_buf2 = upd_w(data_buf2, 0, *row1_ptr++);
+  data_buf2 = upd_w(data_buf2, 1, *row1_ptr);
+
+  for (unsigned i = 0; i < COL / 8; i++)
+    chess_prepare_for_pipelining chess_loop_range(1, ) {
+      v8float flux_sub;
+
+      lap_ij =
+          fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); ///  //c
+      acc_1 = fpmul(data_buf2, 1, 0x76543210, coeffs_rest, 0, 0x00000000); // b
+
+      lap_ij = fpmac(lap_ij, data_buf1, 2, 0x76543210, coeffs_rest, 0,
+                     0x00000000); ///  //c,k
+      acc_1 = fpmac(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //b,j
+
+      // r2 = ptr_in+2 * COL/8+i ;
+      row2_ptr = ((v8float *)(row2)) + i;
+      data_buf2 = upd_w(data_buf2, 0, *(row2_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row2_ptr));
+
+      /////////
+      ///**************************LAP_ij**************************************
+      lap_ij = fpmac(lap_ij, data_buf2, 1, 0x76543210, coeffs_rest, 0,
+                     0x00000000); ///  //c,k,f
+      lap_ij = fpmsc(lap_ij, data_buf2, 2, 0x76543210, coeffs, 0,
+                     0x00000000); ///  //c,k,f,4*g
+      lap_ij = fpmac(lap_ij, data_buf2, 3, 0x76543210, coeffs_rest, 0,
+                     0x00000000); ///  c,k,f,4*g,h
+
+      /////////
+      ///**************************LAP_ijm**************************************
+      acc_1 = fpmac(acc_1, data_buf2, 0, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //b,j,e
+      acc_1 = fpmsc(acc_1, data_buf2, 1, 0x76543210, coeffs, 0,
+                    0x00000000); ///         //b,j,e,4*f
+      acc_1 = fpmac(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///     //b,j,e,4*f,g
+
+      // Calculate  lap_ij - lap_ijm
+      flux_sub = fpsub(lap_ij, concat(acc_1, undef_v8float()), 0,
+                       0x76543210); // flx_imj = lap_ij - lap_ijm;
+      ptr_out = (v8float *)out_flux1 + i;
+      *ptr_out = flux_sub;
+      //
+
+      acc_0 = fpmul(data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); /// // l ; R1 is already loaded
+      acc_0 = fpmsc(acc_0, data_buf2, 3, 0x76543210, coeffs, 0,
+                    0x00000000); ///   // l, 4*h
+
+      // r1 = ptr_in+1 * COL/8+i ;
+      row1_ptr = ((v8float *)(row1)) + i;
+      data_buf1 = upd_w(data_buf1, 0, *(row1_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row1_ptr));
+
+      acc_0 = fpmac(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  lap_ijp // l, 4*h, g
+      acc_0 = fpmac(acc_0, data_buf2, 4, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  l, 4*h, g, i
+
+      acc_0 = fpmac(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  // l, 4*h, g, i, d
+
+      flux_sub = fpsub(acc_0, concat(lap_ij, undef_v8float()), 0, 0x76543210);
+      ptr_out = (v8float *)out_flux2 + i;
+      *ptr_out = flux_sub;
+
+      acc_1 = fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+      acc_0 = fpmul(data_buf2, 2, 0x76543210, coeffs_rest, 0, 0x00000000); // g
+
+      // r2 = ptr_in + 0*COL/8 + i ;
+      row0_ptr = ((v8float *)(row0)) + i;
+      // r2 = ptr_in + 0*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm
+      data_buf2 = upd_w(data_buf2, 0, *row0_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row0_ptr);
+
+      acc_1 = fpmsc(acc_1, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); // g, 4*c
+      acc_1 = fpmac(acc_1, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b
+      acc_1 = fpmac(acc_1, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); /// // g, 4*c, b, a
+
+      // r2 = ptr_in + 4*COL/8 + i ;
+      row4_ptr = ((v8float *)(row4)) + i;
+      // r2 = ptr_in + 4*COL/8 + i + aor*COL/8;  // load for LAP_ijm for fly_ijm
+      data_buf2 = upd_w(data_buf2, 0, *row4_ptr++);
+      data_buf2 = upd_w(data_buf2, 1, *row4_ptr);
+      //////// **************************LAP_ipj for fly_ij since r2=R4********
+      acc_1 = fpmac(acc_1, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); // g, 4*c, b, a, d
+      acc_0 = fpmac(acc_0, data_buf2, 2, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///   // g, m
+
+      // //Calculates lap_imj
+      // lap_0=srs(acc_1,0);
+
+      flux_sub = fpsub(lap_ij, concat(acc_1, undef_v8float()), 0, 0x76543210);
+      ptr_out = (v8float *)out_flux3 + i;
+      *ptr_out = flux_sub;
+
+      // r1 = ptr_in + 3*COL/8 + i ;
+      row3_ptr = ((v8float *)(row3)) + i;
+      // r1 = ptr_in + 3*COL/8 + i + aor*COL/8; // load for LAP_ijp for fly_ij
+      // data_buf1=*r1++;
+      data_buf1 = upd_w(data_buf1, 0, *row3_ptr++);
+      data_buf1 = upd_w(data_buf1, 1, *row3_ptr);
+
+      acc_0 = fpmsc(acc_0, data_buf1, 2, 0x76543210, coeffs, 0,
+                    0x00000000); ///  //g, m , k * 4
+
+      // v16int32 flx_out3=sub16(flx_out2,out_flx_inter3); //adds fly_ij -
+      // fly_ijm - flx_imj
+
+      acc_0 = fpmac(acc_0, data_buf1, 1, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///  //g, m , k * 4, j
+
+      // LOAD DATA FOR NEXT ITERATION
+      //  r2 = ptr_in + 1*COL/8 + i + 1 ;
+      row1_ptr = ((v8float *)(row1)) + i + 1;
+      data_buf2 = upd_w(data_buf2, 0, *(row1_ptr)++);
+      data_buf2 = upd_w(data_buf2, 1, *(row1_ptr));
+      acc_0 = fpmac(acc_0, data_buf1, 3, 0x76543210, coeffs_rest, 0,
+                    0x00000000); ///   //g, m , k * 4, j, l
+
+      //  flx_ij = lap_ipj - lap_ij
+      flux_sub = fpsub(acc_0, concat(lap_ij, undef_v8float()), 0, 0x76543210);
+      ptr_out = (v8float *)out_flux4 + i;
+      *ptr_out = flux_sub;
+
+      // LOAD DATA FOR NEXT ITERATION
+      row3_ptr = ((v8float *)(row3)) + i + 1;
+      data_buf1 = upd_w(data_buf1, 0, *(row3_ptr)++);
+      data_buf1 = upd_w(data_buf1, 1, *(row3_ptr));
+
+      // }
     }
 }
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/include.h b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/include.h
index 6ab94ff..e74fe84 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/include.h
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/include.h
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -11,43 +11,43 @@
 // #define  MULTI_4x4
 // #include <adf.h>
 #include <stdint.h>
-#define GRIDROW     256
-#define GRIDCOL     256
-#define GRIDDEPTH   1
-#define TOTAL_INPUT GRIDROW*GRIDCOL*GRIDDEPTH
-
-#define ROW			256
-#define COL			256
-#define TILE_SIZE  COL
+#define GRIDROW 256
+#define GRIDCOL 256
+#define GRIDDEPTH 1
+#define TOTAL_INPUT GRIDROW *GRIDCOL *GRIDDEPTH
 
-#define WMARGIN     256       // Margin before the frame
+#define ROW 256
+#define COL 256
+#define TILE_SIZE COL
 
+#define WMARGIN 256 // Margin before the frame
 
-#define NBYTES		4		// datatype byte-width
+#define NBYTES 4 // datatype byte-width
 
-#define AVAIL_CORES 25*25
+#define AVAIL_CORES 25 * 25
 
-#define CORE_REQUIRED TOTAL_INPUT/TILE_SIZE
+#define CORE_REQUIRED TOTAL_INPUT / TILE_SIZE
 
 #ifdef MULTI_CORE
-    #ifdef  MULTI_2x2
-        #define HW_ROW 2
-        #define HW_COL 2
-    #else 
-        #define HW_ROW 4
-        #define HW_COL 4
-    #endif
-
-    #define USED_CORE HW_ROW*HW_COL
-    #define NITER    TOTAL_INPUT/(USED_CORE*TILE_SIZE)   // Number of iteration
+#ifdef MULTI_2x2
+#define HW_ROW 2
+#define HW_COL 2
+#else
+#define HW_ROW 4
+#define HW_COL 4
+#endif
+
+#define USED_CORE HW_ROW *HW_COL
+#define NITER TOTAL_INPUT / (USED_CORE * TILE_SIZE) // Number of iteration
 #else
 
-#define NITER    TOTAL_INPUT/(TILE_SIZE)    // Number of iteration
+#define NITER TOTAL_INPUT / (TILE_SIZE) // Number of iteration
 #endif
 
 #ifdef WITH_MARGIN
-#define INPUT_FILE "./data/TestInputS.txt"    // Input file name and location
+#define INPUT_FILE "./data/TestInputS.txt" // Input file name and location
 #else
-#define INPUT_FILE "./data/dataset_256x256x64.txt"    // Input file name and location
+#define INPUT_FILE                                                             \
+  "./data/dataset_256x256x64.txt" // Input file name and location
 #endif
-#define OUTPUT_FILE "./data/TestOutputS.txt"    // Output file name and location
\ No newline at end of file
+#define OUTPUT_FILE "./data/TestOutputS.txt" // Output file name and location
\ No newline at end of file
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_1.cpp b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_1.cpp
index 558311b..b6bcd3d 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_1.cpp
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_1.cpp
@@ -1,5 +1,5 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-  
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
@@ -13,16 +13,16 @@
 #include <stdlib.h>
 #include <sys/mman.h>
 #include <thread>
+#include <time.h>
 #include <unistd.h>
 #include <xaiengine.h>
-#include <time.h>  
 #define HIGH_ADDR(addr) ((addr & 0xffffffff00000000) >> 32)
 #define LOW_ADDR(addr) (addr & 0x00000000ffffffff)
 #define MLIR_STACK_OFFSET 4096
 
 #define TOTAL_B_BLOCK 1 // only 1
-#define B_BLOCK_DEPTH 4 //set how many rows
-#define HDIFF_COL 3 //columns
+#define B_BLOCK_DEPTH 4 // set how many rows
+#define HDIFF_COL 3     // columns
 #define START_ROW 1
 #define INPUT_ROWS 9
 
@@ -30,7 +30,7 @@
 
 int main(int argc, char *argv[]) {
   printf("test start.\n");
-  clock_t t; 
+  clock_t t;
 
   aie_libxaie_ctx_t *_xaie = mlir_aie_init_libxaie();
   mlir_aie_init_device(_xaie);
@@ -38,15 +38,14 @@ int main(int argc, char *argv[]) {
   u32 sleep_u = 100000;
   usleep(sleep_u);
   printf("before configure cores.\n");
-   for (int b=0; b<TOTAL_B_BLOCK;b++)
-  {
-    for (int i=0; i<HDIFF_COL;i++){
-      for (int j=START_ROW; j<START_ROW+B_BLOCK_DEPTH;j++)
+  for (int b = 0; b < TOTAL_B_BLOCK; b++) {
+    for (int i = 0; i < HDIFF_COL; i++) {
+      for (int j = START_ROW; j < START_ROW + B_BLOCK_DEPTH; j++)
         mlir_aie_clear_tile_memory(_xaie, i, j);
     }
   }
 
-//   mlir_aie_clear_tile_memory(_xaie, 6, 4);
+  //   mlir_aie_clear_tile_memory(_xaie, 6, 4);
   mlir_aie_configure_cores(_xaie);
 
   usleep(sleep_u);
@@ -56,13 +55,13 @@ int main(int argc, char *argv[]) {
 
   mlir_aie_acquire_lock(_xaie, 0, 1, 14, 0, 0); // for timing
   // When lock 14 is acquired, we broadcast event 2 from tile t73
-  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0,1), 
-                        XAIE_MEM_MOD, 2,
-                        XAIE_EVENT_LOCK_14_ACQ_MEM); 
-  // we use broadcast event 2 at tile t75 to start the timer, and the local event lock 14 acquire to stop the timer
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0, 1), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  // we use broadcast event 2 at tile t75 to start the timer, and the local
+  // event lock 14 acquire to stop the timer
   EventMonitor pc0(_xaie, 2, 1, 0, XAIE_EVENT_BROADCAST_2_MEM,
-                 XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
-                 XAIE_MEM_MOD);
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
   pc0.set();
 
   usleep(sleep_u);
@@ -72,45 +71,46 @@ int main(int argc, char *argv[]) {
   int errors = 0;
 
   printf("Finish configure\n");
-  #define DMA_COUNT_IN 256*INPUT_ROWS
-  #define DMA_COUNT_OUT 256*2*B_BLOCK_DEPTH
+#define DMA_COUNT_IN 256 * INPUT_ROWS
+#define DMA_COUNT_OUT 256 * 2 * B_BLOCK_DEPTH
   int *ddr_ptr_in_0 = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT_IN);
   int *ddr_ptr_out_0 = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT_OUT);
-//   int *mem_ptr2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT);
-//   int *mem_ptr3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT);
-//   int *mem_ptr4 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT);
-//   int *mem_ptr5 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT);
-//   int *mem_ptr6 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT);
-//   int *mem_ptr7 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT);
+  //   int *mem_ptr2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT);
+  //   int *mem_ptr3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT);
+  //   int *mem_ptr4 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT);
+  //   int *mem_ptr5 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT);
+  //   int *mem_ptr6 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT);
+  //   int *mem_ptr7 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT);
 
   // initialize the external buffers
   for (int i = 0; i < DMA_COUNT_IN; i++) {
-    *(ddr_ptr_in_0 + i) = i;  // input
+    *(ddr_ptr_in_0 + i) = i; // input
   }
 
   for (int i = 0; i < DMA_COUNT_OUT; i++) {
-    *(ddr_ptr_out_0 + i) = 0;  // input
+    *(ddr_ptr_out_0 + i) = 0; // input
   }
 
   mlir_aie_sync_mem_dev(_xaie, 0); // only used in libaiev2
   mlir_aie_sync_mem_dev(_xaie, 1); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 2); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 3); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 4); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 5); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 6); // only used in libaiev2
-//   mlir_aie_sync_mem_dev(_xaie, 7); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 2); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 3); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 4); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 5); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 6); // only used in libaiev2
+  //   mlir_aie_sync_mem_dev(_xaie, 7); // only used in libaiev2
 
 #ifdef LIBXAIENGINEV2
-  mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0); // external set address
+  mlir_aie_external_set_addr_ddr_buffer_in_0(
+      (u64)ddr_ptr_in_0); // external set address
   mlir_aie_external_set_addr_ddr_buffer_out_0((u64)ddr_ptr_out_0);
-//   mlir_aie_external_set_addr_RHS_tile0((u64)mem_ptr2);
-//   mlir_aie_external_set_addr_RHS_tile1((u64)mem_ptr3);
-//   mlir_aie_external_set_addr_RHS_tile2((u64)mem_ptr4);
-//   mlir_aie_external_set_addr_RHS_tile3((u64)mem_ptr5);
-//   mlir_aie_external_set_addr_Out_tile0((u64)mem_ptr6);
-//   mlir_aie_external_set_addr_Out_tile1((u64)mem_ptr7);
-//   mlir_aie_configure_shimdma_60(_xaie);
+  //   mlir_aie_external_set_addr_RHS_tile0((u64)mem_ptr2);
+  //   mlir_aie_external_set_addr_RHS_tile1((u64)mem_ptr3);
+  //   mlir_aie_external_set_addr_RHS_tile2((u64)mem_ptr4);
+  //   mlir_aie_external_set_addr_RHS_tile3((u64)mem_ptr5);
+  //   mlir_aie_external_set_addr_Out_tile0((u64)mem_ptr6);
+  //   mlir_aie_external_set_addr_Out_tile1((u64)mem_ptr7);
+  //   mlir_aie_configure_shimdma_60(_xaie);
   mlir_aie_configure_shimdma_20(_xaie);
 //   mlir_aie_configure_shimdma_100(_xaie);
 #endif
@@ -118,22 +118,18 @@ int main(int argc, char *argv[]) {
   printf("before core start\n");
   // mlir_aie_print_tile_status(_xaie, 7, 3);
 
-  
-  
-
-
   printf("Release lock for accessing DDR.\n");
   mlir_aie_release_of_0_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_15_lock_0(_xaie, 0, 0);
 
   printf("Start cores\n");
   ///// --- start counter-----
-  t = clock(); 
+  t = clock();
   mlir_aie_start_cores(_xaie);
   mlir_aie_release_lock(_xaie, 0, 1, 14, 0, 0); // for timing
-  t = clock() - t; 
+  t = clock() - t;
 
-  printf ("It took %ld clicks (%f seconds).\n",t,((float)t)/CLOCKS_PER_SEC);
+  printf("It took %ld clicks (%f seconds).\n", t, ((float)t) / CLOCKS_PER_SEC);
 
   usleep(sleep_u);
   printf("after core start\n");
@@ -141,13 +137,13 @@ int main(int argc, char *argv[]) {
 
   usleep(sleep_u);
 
+  //   mlir_aie_acquire_of_17_lock_0(_xaie, 1, 0);
+  //   mlir_aie_acquire_of_15_lock_0(_xaie, 1, 0);
 
-//   mlir_aie_acquire_of_17_lock_0(_xaie, 1, 0);
-//   mlir_aie_acquire_of_15_lock_0(_xaie, 1, 0);
- 
-  mlir_aie_sync_mem_cpu(_xaie, 1); // only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        1); // only used in libaiev2 //sync up with output
   ///// --- end counter-----
-  for (int i =0; i < 512; i ++ ){
+  for (int i = 0; i < 512; i++) {
     printf("Location %d:  %d\n", i, ddr_ptr_out_0[i]);
   }
 
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_16.cpp b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_16.cpp
index f123301..f42b75c 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_16.cpp
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_16.cpp
@@ -1,10 +1,9 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-    
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-
 #include "test_library.h"
 #include <cassert>
 #include <cmath>
@@ -14,23 +13,23 @@
 #include <stdlib.h>
 #include <sys/mman.h>
 #include <thread>
+#include <time.h>
 #include <unistd.h>
 #include <xaiengine.h>
-#include <time.h>  
 #define HIGH_ADDR(addr) ((addr & 0xffffffff00000000) >> 32)
 #define LOW_ADDR(addr) (addr & 0x00000000ffffffff)
 #define MLIR_STACK_OFFSET 4096
-#define B_BLOCK_DEPTH 4 //set how many rows
-#define HDIFF_COL 3 //columns
+#define B_BLOCK_DEPTH 4 // set how many rows
+#define HDIFF_COL 3     // columns
 #define START_ROW 1
-#define INPUT_ROWS 9   
-    
-    #define TOTAL_B_BLOCK 16
- #include "aie_inc.cpp"
+#define INPUT_ROWS 9
+
+#define TOTAL_B_BLOCK 16
+#include "aie_inc.cpp"
 
 int main(int argc, char *argv[]) {
   printf("test start.");
-  clock_t t; 
+  clock_t t;
 
   aie_libxaie_ctx_t *_xaie = mlir_aie_init_libxaie();
   mlir_aie_init_device(_xaie);
@@ -38,15 +37,14 @@ int main(int argc, char *argv[]) {
   u32 sleep_u = 100000;
   usleep(sleep_u);
   printf("before configure cores.");
-   for (int b=0; b<TOTAL_B_BLOCK;b++)
-  {
-    for (int i=0; i<HDIFF_COL;i++){
-      for (int j=START_ROW; j<START_ROW+B_BLOCK_DEPTH;j++)
+  for (int b = 0; b < TOTAL_B_BLOCK; b++) {
+    for (int i = 0; i < HDIFF_COL; i++) {
+      for (int j = START_ROW; j < START_ROW + B_BLOCK_DEPTH; j++)
         mlir_aie_clear_tile_memory(_xaie, i, j);
     }
   }
 
-//   mlir_aie_clear_tile_memory(_xaie, 6, 4);
+  //   mlir_aie_clear_tile_memory(_xaie, 6, 4);
   mlir_aie_configure_cores(_xaie);
 
   usleep(sleep_u);
@@ -54,241 +52,288 @@ int main(int argc, char *argv[]) {
   mlir_aie_configure_switchboxes(_xaie);
   mlir_aie_initialize_locks(_xaie);
 
-      mlir_aie_acquire_lock(_xaie, 0, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc0(_xaie, 2, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc0.set();
- 
+  mlir_aie_acquire_lock(_xaie, 0, 2, 14, 0, 0); // for timing
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc0(_xaie, 2, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc0.set();
+
   mlir_aie_acquire_lock(_xaie, 0, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc1(_xaie, 2, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc1.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc1(_xaie, 2, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc1.set();
+
   mlir_aie_acquire_lock(_xaie, 3, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc2(_xaie, 5, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc2.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc2(_xaie, 5, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc2.set();
+
   mlir_aie_acquire_lock(_xaie, 3, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc3(_xaie, 5, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc3.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc3(_xaie, 5, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc3.set();
+
   mlir_aie_acquire_lock(_xaie, 6, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(6,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc4(_xaie, 8, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc4.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(6, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc4(_xaie, 8, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc4.set();
+
   mlir_aie_acquire_lock(_xaie, 6, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(6,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc5(_xaie, 8, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc5.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(6, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc5(_xaie, 8, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc5.set();
+
   mlir_aie_acquire_lock(_xaie, 9, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(9,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc6(_xaie, 11, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc6.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(9, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc6(_xaie, 11, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc6.set();
+
   mlir_aie_acquire_lock(_xaie, 9, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(9,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc7(_xaie, 11, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc7.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(9, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc7(_xaie, 11, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc7.set();
+
   mlir_aie_acquire_lock(_xaie, 12, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(12,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc8(_xaie, 14, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc8.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(12, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc8(_xaie, 14, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc8.set();
+
   mlir_aie_acquire_lock(_xaie, 12, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(12,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc9(_xaie, 14, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc9.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(12, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc9(_xaie, 14, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc9.set();
+
   mlir_aie_acquire_lock(_xaie, 15, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(15,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc10(_xaie, 17, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc10.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(15, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc10(_xaie, 17, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc10.set();
+
   mlir_aie_acquire_lock(_xaie, 15, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(15,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc11(_xaie, 17, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc11.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(15, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc11(_xaie, 17, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc11.set();
+
   mlir_aie_acquire_lock(_xaie, 18, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(18,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc12(_xaie, 20, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc12.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(18, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc12(_xaie, 20, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc12.set();
+
   mlir_aie_acquire_lock(_xaie, 18, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(18,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc13(_xaie, 20, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc13.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(18, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc13(_xaie, 20, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc13.set();
+
   mlir_aie_acquire_lock(_xaie, 21, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(21,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc14(_xaie, 23, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc14.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(21, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc14(_xaie, 23, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc14.set();
+
   mlir_aie_acquire_lock(_xaie, 21, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(21,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc15(_xaie, 23, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc15.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(21, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc15(_xaie, 23, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc15.set();
 
-    usleep(sleep_u);
+  usleep(sleep_u);
   printf("before configure DMA");
   mlir_aie_configure_dmas(_xaie);
   int errors = 0;
-      mlir_aie_init_mems(_xaie, 32);
- 
-    printf("Finish configure");
-  #define DMA_COUNT_IN 256*INPUT_ROWS
-  #define DMA_COUNT_OUT 256*2*B_BLOCK_DEPTH
-
-      int *ddr_ptr_in_0 = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT_IN);
-   int *ddr_ptr_in_1 = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT_IN);
-   int *ddr_ptr_in_2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT_IN);
-   int *ddr_ptr_in_3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT_IN);
-   int *ddr_ptr_in_4 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT_IN);
-   int *ddr_ptr_in_5 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT_IN);
-   int *ddr_ptr_in_6 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT_IN);
-   int *ddr_ptr_in_7 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT_IN);
-   int *ddr_ptr_in_8 = mlir_aie_mem_alloc(_xaie, 8, DMA_COUNT_IN);
-   int *ddr_ptr_in_9 = mlir_aie_mem_alloc(_xaie, 9, DMA_COUNT_IN);
-   int *ddr_ptr_in_10 = mlir_aie_mem_alloc(_xaie, 10, DMA_COUNT_IN);
-   int *ddr_ptr_in_11 = mlir_aie_mem_alloc(_xaie, 11, DMA_COUNT_IN);
-   int *ddr_ptr_in_12 = mlir_aie_mem_alloc(_xaie, 12, DMA_COUNT_IN);
-   int *ddr_ptr_in_13 = mlir_aie_mem_alloc(_xaie, 13, DMA_COUNT_IN);
-   int *ddr_ptr_in_14 = mlir_aie_mem_alloc(_xaie, 14, DMA_COUNT_IN);
-   int *ddr_ptr_in_15 = mlir_aie_mem_alloc(_xaie, 15, DMA_COUNT_IN);
-   int *ddr_ptr_out_0 = mlir_aie_mem_alloc(_xaie, 16, DMA_COUNT_OUT);
-   int *ddr_ptr_out_1 = mlir_aie_mem_alloc(_xaie, 17, DMA_COUNT_OUT);
-   int *ddr_ptr_out_2 = mlir_aie_mem_alloc(_xaie, 18, DMA_COUNT_OUT);
-   int *ddr_ptr_out_3 = mlir_aie_mem_alloc(_xaie, 19, DMA_COUNT_OUT);
-   int *ddr_ptr_out_4 = mlir_aie_mem_alloc(_xaie, 20, DMA_COUNT_OUT);
-   int *ddr_ptr_out_5 = mlir_aie_mem_alloc(_xaie, 21, DMA_COUNT_OUT);
-   int *ddr_ptr_out_6 = mlir_aie_mem_alloc(_xaie, 22, DMA_COUNT_OUT);
-   int *ddr_ptr_out_7 = mlir_aie_mem_alloc(_xaie, 23, DMA_COUNT_OUT);
-   int *ddr_ptr_out_8 = mlir_aie_mem_alloc(_xaie, 24, DMA_COUNT_OUT);
-   int *ddr_ptr_out_9 = mlir_aie_mem_alloc(_xaie, 25, DMA_COUNT_OUT);
-   int *ddr_ptr_out_10 = mlir_aie_mem_alloc(_xaie, 26, DMA_COUNT_OUT);
-   int *ddr_ptr_out_11 = mlir_aie_mem_alloc(_xaie, 27, DMA_COUNT_OUT);
-   int *ddr_ptr_out_12 = mlir_aie_mem_alloc(_xaie, 28, DMA_COUNT_OUT);
-   int *ddr_ptr_out_13 = mlir_aie_mem_alloc(_xaie, 29, DMA_COUNT_OUT);
-   int *ddr_ptr_out_14 = mlir_aie_mem_alloc(_xaie, 30, DMA_COUNT_OUT);
-   int *ddr_ptr_out_15 = mlir_aie_mem_alloc(_xaie, 31, DMA_COUNT_OUT);
-   for (int i = 0; i < DMA_COUNT_IN; i++) {
-     *(ddr_ptr_in_0+ i) = i;
-     *(ddr_ptr_in_1+ i) = i;
-     *(ddr_ptr_in_2+ i) = i;
-     *(ddr_ptr_in_3+ i) = i;
-     *(ddr_ptr_in_4+ i) = i;
-     *(ddr_ptr_in_5+ i) = i;
-     *(ddr_ptr_in_6+ i) = i;
-     *(ddr_ptr_in_7+ i) = i;
-     *(ddr_ptr_in_8+ i) = i;
-     *(ddr_ptr_in_9+ i) = i;
-     *(ddr_ptr_in_10+ i) = i;
-     *(ddr_ptr_in_11+ i) = i;
-     *(ddr_ptr_in_12+ i) = i;
-     *(ddr_ptr_in_13+ i) = i;
-     *(ddr_ptr_in_14+ i) = i;
-     *(ddr_ptr_in_15+ i) = i;
-   }
-   for (int i = 0; i < DMA_COUNT_OUT; i++) {
-     *(ddr_ptr_out_0+ i) = i;
-     *(ddr_ptr_out_1+ i) = i;
-     *(ddr_ptr_out_2+ i) = i;
-     *(ddr_ptr_out_3+ i) = i;
-     *(ddr_ptr_out_4+ i) = i;
-     *(ddr_ptr_out_5+ i) = i;
-     *(ddr_ptr_out_6+ i) = i;
-     *(ddr_ptr_out_7+ i) = i;
-     *(ddr_ptr_out_8+ i) = i;
-     *(ddr_ptr_out_9+ i) = i;
-     *(ddr_ptr_out_10+ i) = i;
-     *(ddr_ptr_out_11+ i) = i;
-     *(ddr_ptr_out_12+ i) = i;
-     *(ddr_ptr_out_13+ i) = i;
-     *(ddr_ptr_out_14+ i) = i;
-     *(ddr_ptr_out_15+ i) = i;
-   }
-   mlir_aie_sync_mem_dev(_xaie, 0);
-   mlir_aie_sync_mem_dev(_xaie, 1);
-   mlir_aie_sync_mem_dev(_xaie, 2);
-   mlir_aie_sync_mem_dev(_xaie, 3);
-   mlir_aie_sync_mem_dev(_xaie, 4);
-   mlir_aie_sync_mem_dev(_xaie, 5);
-   mlir_aie_sync_mem_dev(_xaie, 6);
-   mlir_aie_sync_mem_dev(_xaie, 7);
-   mlir_aie_sync_mem_dev(_xaie, 8);
-   mlir_aie_sync_mem_dev(_xaie, 9);
-   mlir_aie_sync_mem_dev(_xaie, 10);
-   mlir_aie_sync_mem_dev(_xaie, 11);
-   mlir_aie_sync_mem_dev(_xaie, 12);
-   mlir_aie_sync_mem_dev(_xaie, 13);
-   mlir_aie_sync_mem_dev(_xaie, 14);
-   mlir_aie_sync_mem_dev(_xaie, 15);
-   mlir_aie_sync_mem_dev(_xaie, 16);
-   mlir_aie_sync_mem_dev(_xaie, 17);
-   mlir_aie_sync_mem_dev(_xaie, 18);
-   mlir_aie_sync_mem_dev(_xaie, 19);
-   mlir_aie_sync_mem_dev(_xaie, 20);
-   mlir_aie_sync_mem_dev(_xaie, 21);
-   mlir_aie_sync_mem_dev(_xaie, 22);
-   mlir_aie_sync_mem_dev(_xaie, 23);
-   mlir_aie_sync_mem_dev(_xaie, 24);
-   mlir_aie_sync_mem_dev(_xaie, 25);
-   mlir_aie_sync_mem_dev(_xaie, 26);
-   mlir_aie_sync_mem_dev(_xaie, 27);
-   mlir_aie_sync_mem_dev(_xaie, 28);
-   mlir_aie_sync_mem_dev(_xaie, 29);
-   mlir_aie_sync_mem_dev(_xaie, 30);
-   mlir_aie_sync_mem_dev(_xaie, 31);
- #ifdef LIBXAIENGINEV2
-    mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0); 
-     mlir_aie_external_set_addr_ddr_buffer_in_1((u64)ddr_ptr_in_1); 
-     mlir_aie_external_set_addr_ddr_buffer_in_2((u64)ddr_ptr_in_2); 
-     mlir_aie_external_set_addr_ddr_buffer_in_3((u64)ddr_ptr_in_3); 
-     mlir_aie_external_set_addr_ddr_buffer_in_4((u64)ddr_ptr_in_4); 
-     mlir_aie_external_set_addr_ddr_buffer_in_5((u64)ddr_ptr_in_5); 
-     mlir_aie_external_set_addr_ddr_buffer_in_6((u64)ddr_ptr_in_6); 
-     mlir_aie_external_set_addr_ddr_buffer_in_7((u64)ddr_ptr_in_7); 
-     mlir_aie_external_set_addr_ddr_buffer_in_8((u64)ddr_ptr_in_8); 
-     mlir_aie_external_set_addr_ddr_buffer_in_9((u64)ddr_ptr_in_9); 
-     mlir_aie_external_set_addr_ddr_buffer_in_10((u64)ddr_ptr_in_10); 
-     mlir_aie_external_set_addr_ddr_buffer_in_11((u64)ddr_ptr_in_11); 
-     mlir_aie_external_set_addr_ddr_buffer_in_12((u64)ddr_ptr_in_12); 
-     mlir_aie_external_set_addr_ddr_buffer_in_13((u64)ddr_ptr_in_13); 
-     mlir_aie_external_set_addr_ddr_buffer_in_14((u64)ddr_ptr_in_14); 
-     mlir_aie_external_set_addr_ddr_buffer_in_15((u64)ddr_ptr_in_15); 
-     mlir_aie_external_set_addr_ddr_buffer_out_0((u64)ddr_ptr_out_0); 
-     mlir_aie_external_set_addr_ddr_buffer_out_1((u64)ddr_ptr_out_1); 
-     mlir_aie_external_set_addr_ddr_buffer_out_2((u64)ddr_ptr_out_2); 
-     mlir_aie_external_set_addr_ddr_buffer_out_3((u64)ddr_ptr_out_3); 
-     mlir_aie_external_set_addr_ddr_buffer_out_4((u64)ddr_ptr_out_4); 
-     mlir_aie_external_set_addr_ddr_buffer_out_5((u64)ddr_ptr_out_5); 
-     mlir_aie_external_set_addr_ddr_buffer_out_6((u64)ddr_ptr_out_6); 
-     mlir_aie_external_set_addr_ddr_buffer_out_7((u64)ddr_ptr_out_7); 
-     mlir_aie_external_set_addr_ddr_buffer_out_8((u64)ddr_ptr_out_8); 
-     mlir_aie_external_set_addr_ddr_buffer_out_9((u64)ddr_ptr_out_9); 
-     mlir_aie_external_set_addr_ddr_buffer_out_10((u64)ddr_ptr_out_10); 
-     mlir_aie_external_set_addr_ddr_buffer_out_11((u64)ddr_ptr_out_11); 
-     mlir_aie_external_set_addr_ddr_buffer_out_12((u64)ddr_ptr_out_12); 
-     mlir_aie_external_set_addr_ddr_buffer_out_13((u64)ddr_ptr_out_13); 
-     mlir_aie_external_set_addr_ddr_buffer_out_14((u64)ddr_ptr_out_14); 
-     mlir_aie_external_set_addr_ddr_buffer_out_15((u64)ddr_ptr_out_15); 
-     mlir_aie_configure_shimdma_20(_xaie);
-     mlir_aie_configure_shimdma_30(_xaie);
-     mlir_aie_configure_shimdma_60(_xaie);
-     mlir_aie_configure_shimdma_70(_xaie);
-     mlir_aie_configure_shimdma_100(_xaie);
-     mlir_aie_configure_shimdma_110(_xaie);
-     mlir_aie_configure_shimdma_180(_xaie);
-     mlir_aie_configure_shimdma_190(_xaie);
- #endif
-
-    printf("before core start");
+  mlir_aie_init_mems(_xaie, 32);
+
+  printf("Finish configure");
+#define DMA_COUNT_IN 256 * INPUT_ROWS
+#define DMA_COUNT_OUT 256 * 2 * B_BLOCK_DEPTH
+
+  int *ddr_ptr_in_0 = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT_IN);
+  int *ddr_ptr_in_1 = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT_IN);
+  int *ddr_ptr_in_2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT_IN);
+  int *ddr_ptr_in_3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT_IN);
+  int *ddr_ptr_in_4 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT_IN);
+  int *ddr_ptr_in_5 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT_IN);
+  int *ddr_ptr_in_6 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT_IN);
+  int *ddr_ptr_in_7 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT_IN);
+  int *ddr_ptr_in_8 = mlir_aie_mem_alloc(_xaie, 8, DMA_COUNT_IN);
+  int *ddr_ptr_in_9 = mlir_aie_mem_alloc(_xaie, 9, DMA_COUNT_IN);
+  int *ddr_ptr_in_10 = mlir_aie_mem_alloc(_xaie, 10, DMA_COUNT_IN);
+  int *ddr_ptr_in_11 = mlir_aie_mem_alloc(_xaie, 11, DMA_COUNT_IN);
+  int *ddr_ptr_in_12 = mlir_aie_mem_alloc(_xaie, 12, DMA_COUNT_IN);
+  int *ddr_ptr_in_13 = mlir_aie_mem_alloc(_xaie, 13, DMA_COUNT_IN);
+  int *ddr_ptr_in_14 = mlir_aie_mem_alloc(_xaie, 14, DMA_COUNT_IN);
+  int *ddr_ptr_in_15 = mlir_aie_mem_alloc(_xaie, 15, DMA_COUNT_IN);
+  int *ddr_ptr_out_0 = mlir_aie_mem_alloc(_xaie, 16, DMA_COUNT_OUT);
+  int *ddr_ptr_out_1 = mlir_aie_mem_alloc(_xaie, 17, DMA_COUNT_OUT);
+  int *ddr_ptr_out_2 = mlir_aie_mem_alloc(_xaie, 18, DMA_COUNT_OUT);
+  int *ddr_ptr_out_3 = mlir_aie_mem_alloc(_xaie, 19, DMA_COUNT_OUT);
+  int *ddr_ptr_out_4 = mlir_aie_mem_alloc(_xaie, 20, DMA_COUNT_OUT);
+  int *ddr_ptr_out_5 = mlir_aie_mem_alloc(_xaie, 21, DMA_COUNT_OUT);
+  int *ddr_ptr_out_6 = mlir_aie_mem_alloc(_xaie, 22, DMA_COUNT_OUT);
+  int *ddr_ptr_out_7 = mlir_aie_mem_alloc(_xaie, 23, DMA_COUNT_OUT);
+  int *ddr_ptr_out_8 = mlir_aie_mem_alloc(_xaie, 24, DMA_COUNT_OUT);
+  int *ddr_ptr_out_9 = mlir_aie_mem_alloc(_xaie, 25, DMA_COUNT_OUT);
+  int *ddr_ptr_out_10 = mlir_aie_mem_alloc(_xaie, 26, DMA_COUNT_OUT);
+  int *ddr_ptr_out_11 = mlir_aie_mem_alloc(_xaie, 27, DMA_COUNT_OUT);
+  int *ddr_ptr_out_12 = mlir_aie_mem_alloc(_xaie, 28, DMA_COUNT_OUT);
+  int *ddr_ptr_out_13 = mlir_aie_mem_alloc(_xaie, 29, DMA_COUNT_OUT);
+  int *ddr_ptr_out_14 = mlir_aie_mem_alloc(_xaie, 30, DMA_COUNT_OUT);
+  int *ddr_ptr_out_15 = mlir_aie_mem_alloc(_xaie, 31, DMA_COUNT_OUT);
+  for (int i = 0; i < DMA_COUNT_IN; i++) {
+    *(ddr_ptr_in_0 + i) = i;
+    *(ddr_ptr_in_1 + i) = i;
+    *(ddr_ptr_in_2 + i) = i;
+    *(ddr_ptr_in_3 + i) = i;
+    *(ddr_ptr_in_4 + i) = i;
+    *(ddr_ptr_in_5 + i) = i;
+    *(ddr_ptr_in_6 + i) = i;
+    *(ddr_ptr_in_7 + i) = i;
+    *(ddr_ptr_in_8 + i) = i;
+    *(ddr_ptr_in_9 + i) = i;
+    *(ddr_ptr_in_10 + i) = i;
+    *(ddr_ptr_in_11 + i) = i;
+    *(ddr_ptr_in_12 + i) = i;
+    *(ddr_ptr_in_13 + i) = i;
+    *(ddr_ptr_in_14 + i) = i;
+    *(ddr_ptr_in_15 + i) = i;
+  }
+  for (int i = 0; i < DMA_COUNT_OUT; i++) {
+    *(ddr_ptr_out_0 + i) = i;
+    *(ddr_ptr_out_1 + i) = i;
+    *(ddr_ptr_out_2 + i) = i;
+    *(ddr_ptr_out_3 + i) = i;
+    *(ddr_ptr_out_4 + i) = i;
+    *(ddr_ptr_out_5 + i) = i;
+    *(ddr_ptr_out_6 + i) = i;
+    *(ddr_ptr_out_7 + i) = i;
+    *(ddr_ptr_out_8 + i) = i;
+    *(ddr_ptr_out_9 + i) = i;
+    *(ddr_ptr_out_10 + i) = i;
+    *(ddr_ptr_out_11 + i) = i;
+    *(ddr_ptr_out_12 + i) = i;
+    *(ddr_ptr_out_13 + i) = i;
+    *(ddr_ptr_out_14 + i) = i;
+    *(ddr_ptr_out_15 + i) = i;
+  }
+  mlir_aie_sync_mem_dev(_xaie, 0);
+  mlir_aie_sync_mem_dev(_xaie, 1);
+  mlir_aie_sync_mem_dev(_xaie, 2);
+  mlir_aie_sync_mem_dev(_xaie, 3);
+  mlir_aie_sync_mem_dev(_xaie, 4);
+  mlir_aie_sync_mem_dev(_xaie, 5);
+  mlir_aie_sync_mem_dev(_xaie, 6);
+  mlir_aie_sync_mem_dev(_xaie, 7);
+  mlir_aie_sync_mem_dev(_xaie, 8);
+  mlir_aie_sync_mem_dev(_xaie, 9);
+  mlir_aie_sync_mem_dev(_xaie, 10);
+  mlir_aie_sync_mem_dev(_xaie, 11);
+  mlir_aie_sync_mem_dev(_xaie, 12);
+  mlir_aie_sync_mem_dev(_xaie, 13);
+  mlir_aie_sync_mem_dev(_xaie, 14);
+  mlir_aie_sync_mem_dev(_xaie, 15);
+  mlir_aie_sync_mem_dev(_xaie, 16);
+  mlir_aie_sync_mem_dev(_xaie, 17);
+  mlir_aie_sync_mem_dev(_xaie, 18);
+  mlir_aie_sync_mem_dev(_xaie, 19);
+  mlir_aie_sync_mem_dev(_xaie, 20);
+  mlir_aie_sync_mem_dev(_xaie, 21);
+  mlir_aie_sync_mem_dev(_xaie, 22);
+  mlir_aie_sync_mem_dev(_xaie, 23);
+  mlir_aie_sync_mem_dev(_xaie, 24);
+  mlir_aie_sync_mem_dev(_xaie, 25);
+  mlir_aie_sync_mem_dev(_xaie, 26);
+  mlir_aie_sync_mem_dev(_xaie, 27);
+  mlir_aie_sync_mem_dev(_xaie, 28);
+  mlir_aie_sync_mem_dev(_xaie, 29);
+  mlir_aie_sync_mem_dev(_xaie, 30);
+  mlir_aie_sync_mem_dev(_xaie, 31);
+#ifdef LIBXAIENGINEV2
+  mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0);
+  mlir_aie_external_set_addr_ddr_buffer_in_1((u64)ddr_ptr_in_1);
+  mlir_aie_external_set_addr_ddr_buffer_in_2((u64)ddr_ptr_in_2);
+  mlir_aie_external_set_addr_ddr_buffer_in_3((u64)ddr_ptr_in_3);
+  mlir_aie_external_set_addr_ddr_buffer_in_4((u64)ddr_ptr_in_4);
+  mlir_aie_external_set_addr_ddr_buffer_in_5((u64)ddr_ptr_in_5);
+  mlir_aie_external_set_addr_ddr_buffer_in_6((u64)ddr_ptr_in_6);
+  mlir_aie_external_set_addr_ddr_buffer_in_7((u64)ddr_ptr_in_7);
+  mlir_aie_external_set_addr_ddr_buffer_in_8((u64)ddr_ptr_in_8);
+  mlir_aie_external_set_addr_ddr_buffer_in_9((u64)ddr_ptr_in_9);
+  mlir_aie_external_set_addr_ddr_buffer_in_10((u64)ddr_ptr_in_10);
+  mlir_aie_external_set_addr_ddr_buffer_in_11((u64)ddr_ptr_in_11);
+  mlir_aie_external_set_addr_ddr_buffer_in_12((u64)ddr_ptr_in_12);
+  mlir_aie_external_set_addr_ddr_buffer_in_13((u64)ddr_ptr_in_13);
+  mlir_aie_external_set_addr_ddr_buffer_in_14((u64)ddr_ptr_in_14);
+  mlir_aie_external_set_addr_ddr_buffer_in_15((u64)ddr_ptr_in_15);
+  mlir_aie_external_set_addr_ddr_buffer_out_0((u64)ddr_ptr_out_0);
+  mlir_aie_external_set_addr_ddr_buffer_out_1((u64)ddr_ptr_out_1);
+  mlir_aie_external_set_addr_ddr_buffer_out_2((u64)ddr_ptr_out_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_3((u64)ddr_ptr_out_3);
+  mlir_aie_external_set_addr_ddr_buffer_out_4((u64)ddr_ptr_out_4);
+  mlir_aie_external_set_addr_ddr_buffer_out_5((u64)ddr_ptr_out_5);
+  mlir_aie_external_set_addr_ddr_buffer_out_6((u64)ddr_ptr_out_6);
+  mlir_aie_external_set_addr_ddr_buffer_out_7((u64)ddr_ptr_out_7);
+  mlir_aie_external_set_addr_ddr_buffer_out_8((u64)ddr_ptr_out_8);
+  mlir_aie_external_set_addr_ddr_buffer_out_9((u64)ddr_ptr_out_9);
+  mlir_aie_external_set_addr_ddr_buffer_out_10((u64)ddr_ptr_out_10);
+  mlir_aie_external_set_addr_ddr_buffer_out_11((u64)ddr_ptr_out_11);
+  mlir_aie_external_set_addr_ddr_buffer_out_12((u64)ddr_ptr_out_12);
+  mlir_aie_external_set_addr_ddr_buffer_out_13((u64)ddr_ptr_out_13);
+  mlir_aie_external_set_addr_ddr_buffer_out_14((u64)ddr_ptr_out_14);
+  mlir_aie_external_set_addr_ddr_buffer_out_15((u64)ddr_ptr_out_15);
+  mlir_aie_configure_shimdma_20(_xaie);
+  mlir_aie_configure_shimdma_30(_xaie);
+  mlir_aie_configure_shimdma_60(_xaie);
+  mlir_aie_configure_shimdma_70(_xaie);
+  mlir_aie_configure_shimdma_100(_xaie);
+  mlir_aie_configure_shimdma_110(_xaie);
+  mlir_aie_configure_shimdma_180(_xaie);
+  mlir_aie_configure_shimdma_190(_xaie);
+#endif
+
+  printf("before core start");
   // mlir_aie_print_tile_status(_xaie, 7, 3);
   printf("Release lock for accessing DDR.");
   mlir_aie_release_of_0_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
@@ -315,7 +360,7 @@ int main(int argc, char *argv[]) {
   mlir_aie_release_of_199_lock_0(_xaie, 0, 0);
   mlir_aie_release_of_207_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_222_lock_0(_xaie, 0, 0);
-/*ADDD ALL THE LOCKS*/
+  /*ADDD ALL THE LOCKS*/
   mlir_aie_release_of_230_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_245_lock_0(_xaie, 0, 0);
   mlir_aie_release_of_253_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
@@ -331,62 +376,72 @@ int main(int argc, char *argv[]) {
   mlir_aie_release_of_345_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_360_lock_0(_xaie, 0, 0);
 
-
-/*ADDD ALL THE LOCKS*/
-
-
-
+  /*ADDD ALL THE LOCKS*/
 
   printf("Start cores");
   ///// --- start counter-----
-  t = clock(); 
+  t = clock();
   mlir_aie_start_cores(_xaie);
-      mlir_aie_release_lock(_xaie, 0, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 0, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 3, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 3, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 6, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 6, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 9, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 9, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 12, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 12, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 15, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 15, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 18, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 18, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 21, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 21, 6, 14, 0, 0); // for timing
- 
-
-         t = clock() - t; 
-
-  printf ("It took %ld clicks (%f seconds).",t,((float)t)/CLOCKS_PER_SEC);
+  mlir_aie_release_lock(_xaie, 0, 2, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 0, 6, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 3, 2, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 3, 6, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 6, 2, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 6, 6, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 9, 2, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 9, 6, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 12, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 12, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 15, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 15, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 18, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 18, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 21, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 21, 6, 14, 0, 0); // for timing
+
+  t = clock() - t;
+
+  printf("It took %ld clicks (%f seconds).", t, ((float)t) / CLOCKS_PER_SEC);
 
   usleep(sleep_u);
   printf("after core start");
   // mlir_aie_print_tile_status(_xaie, 7, 3);
 
   usleep(sleep_u);
-  mlir_aie_sync_mem_cpu(_xaie, 16); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 17); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 18); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 19); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 20); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 21); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 22); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 23); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 24); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 25); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 26); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 27); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 28); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 29); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 30); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 31); //// only used in libaiev2 //sync up with output
- 
-
-      for (int i =0; i < 512; i ++ ){
+  mlir_aie_sync_mem_cpu(_xaie,
+                        16); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        17); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        18); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        19); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        20); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        21); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        22); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        23); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        24); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        25); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        26); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        27); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        28); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        29); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        30); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        31); //// only used in libaiev2 //sync up with output
+
+  for (int i = 0; i < 512; i++) {
     printf("Location %d:  %d", i, ddr_ptr_out_0[i]);
   }
 
@@ -397,24 +452,23 @@ int main(int argc, char *argv[]) {
   } else {
     printf("Fail!");
     res = -1;
-  } 
+  }
   printf("PC0 cycles: %d", pc0.diff());
-   printf("PC1 cycles: %d", pc1.diff());
-   printf("PC2 cycles: %d", pc2.diff());
-   printf("PC3 cycles: %d", pc3.diff());
-   printf("PC4 cycles: %d", pc4.diff());
-   printf("PC5 cycles: %d", pc5.diff());
-   printf("PC6 cycles: %d", pc6.diff());
-   printf("PC7 cycles: %d", pc7.diff());
-   printf("PC8 cycles: %d", pc8.diff());
-   printf("PC9 cycles: %d", pc9.diff());
-   printf("PC10 cycles: %d", pc10.diff());
-   printf("PC11 cycles: %d", pc11.diff());
-   printf("PC12 cycles: %d", pc12.diff());
-   printf("PC13 cycles: %d", pc13.diff());
-   printf("PC14 cycles: %d", pc14.diff());
-   printf("PC15 cycles: %d", pc15.diff());
- 
+  printf("PC1 cycles: %d", pc1.diff());
+  printf("PC2 cycles: %d", pc2.diff());
+  printf("PC3 cycles: %d", pc3.diff());
+  printf("PC4 cycles: %d", pc4.diff());
+  printf("PC5 cycles: %d", pc5.diff());
+  printf("PC6 cycles: %d", pc6.diff());
+  printf("PC7 cycles: %d", pc7.diff());
+  printf("PC8 cycles: %d", pc8.diff());
+  printf("PC9 cycles: %d", pc9.diff());
+  printf("PC10 cycles: %d", pc10.diff());
+  printf("PC11 cycles: %d", pc11.diff());
+  printf("PC12 cycles: %d", pc12.diff());
+  printf("PC13 cycles: %d", pc13.diff());
+  printf("PC14 cycles: %d", pc14.diff());
+  printf("PC15 cycles: %d", pc15.diff());
 
   mlir_aie_deinit_libxaie(_xaie);
 
@@ -422,7 +476,3 @@ int main(int argc, char *argv[]) {
 
   return res;
 }
-
-    
-    
-    
\ No newline at end of file
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_2.cpp b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_2.cpp
index a3770fb..501a187 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_2.cpp
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_2.cpp
@@ -1,10 +1,9 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-    
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-
 #include "test_library.h"
 #include <cassert>
 #include <cmath>
@@ -14,23 +13,23 @@
 #include <stdlib.h>
 #include <sys/mman.h>
 #include <thread>
+#include <time.h>
 #include <unistd.h>
 #include <xaiengine.h>
-#include <time.h>  
 #define HIGH_ADDR(addr) ((addr & 0xffffffff00000000) >> 32)
 #define LOW_ADDR(addr) (addr & 0x00000000ffffffff)
 #define MLIR_STACK_OFFSET 4096
-#define B_BLOCK_DEPTH 4 //set how many rows
-#define HDIFF_COL 3 //columns
+#define B_BLOCK_DEPTH 4 // set how many rows
+#define HDIFF_COL 3     // columns
 #define START_ROW 1
-#define INPUT_ROWS 9   
-    
-    #define TOTAL_B_BLOCK 2
- #include "aie_inc.cpp"
+#define INPUT_ROWS 9
+
+#define TOTAL_B_BLOCK 2
+#include "aie_inc.cpp"
 
 int main(int argc, char *argv[]) {
   printf("test start.");
-  clock_t t; 
+  clock_t t;
 
   aie_libxaie_ctx_t *_xaie = mlir_aie_init_libxaie();
   mlir_aie_init_device(_xaie);
@@ -38,15 +37,14 @@ int main(int argc, char *argv[]) {
   u32 sleep_u = 100000;
   usleep(sleep_u);
   printf("before configure cores.");
-   for (int b=0; b<TOTAL_B_BLOCK;b++)
-  {
-    for (int i=0; i<HDIFF_COL;i++){
-      for (int j=START_ROW; j<START_ROW+B_BLOCK_DEPTH;j++)
+  for (int b = 0; b < TOTAL_B_BLOCK; b++) {
+    for (int i = 0; i < HDIFF_COL; i++) {
+      for (int j = START_ROW; j < START_ROW + B_BLOCK_DEPTH; j++)
         mlir_aie_clear_tile_memory(_xaie, i, j);
     }
   }
 
-//   mlir_aie_clear_tile_memory(_xaie, 6, 4);
+  //   mlir_aie_clear_tile_memory(_xaie, 6, 4);
   mlir_aie_configure_cores(_xaie);
 
   usleep(sleep_u);
@@ -54,89 +52,89 @@ int main(int argc, char *argv[]) {
   mlir_aie_configure_switchboxes(_xaie);
   mlir_aie_initialize_locks(_xaie);
 
-      mlir_aie_acquire_lock(_xaie, 0, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc0(_xaie, 2, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc0.set();
- 
+  mlir_aie_acquire_lock(_xaie, 0, 2, 14, 0, 0); // for timing
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc0(_xaie, 2, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc0.set();
+
   mlir_aie_acquire_lock(_xaie, 0, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc1(_xaie, 2, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc1.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc1(_xaie, 2, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc1.set();
 
-    usleep(sleep_u);
+  usleep(sleep_u);
   printf("before configure DMA");
   mlir_aie_configure_dmas(_xaie);
   int errors = 0;
-      mlir_aie_init_mems(_xaie, 4);
- 
-    printf("Finish configure");
-  #define DMA_COUNT_IN 256*INPUT_ROWS
-  #define DMA_COUNT_OUT 256*2*B_BLOCK_DEPTH
-
-      int *ddr_ptr_in_0 = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT_IN);
-   int *ddr_ptr_in_1 = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT_IN);
-   int *ddr_ptr_out_0 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT_OUT);
-   int *ddr_ptr_out_1 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT_OUT);
-   for (int i = 0; i < DMA_COUNT_IN; i++) {
-     *(ddr_ptr_in_0+ i) = i;
-     *(ddr_ptr_in_1+ i) = i;
-   }
-   for (int i = 0; i < DMA_COUNT_OUT; i++) {
-     *(ddr_ptr_out_0+ i) = i;
-     *(ddr_ptr_out_1+ i) = i;
-   }
-   mlir_aie_sync_mem_dev(_xaie, 0);
-   mlir_aie_sync_mem_dev(_xaie, 1);
-   mlir_aie_sync_mem_dev(_xaie, 2);
-   mlir_aie_sync_mem_dev(_xaie, 3);
- #ifdef LIBXAIENGINEV2
-    mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0); 
-     mlir_aie_external_set_addr_ddr_buffer_in_1((u64)ddr_ptr_in_1); 
-     mlir_aie_external_set_addr_ddr_buffer_out_0((u64)ddr_ptr_out_0); 
-     mlir_aie_external_set_addr_ddr_buffer_out_1((u64)ddr_ptr_out_1); 
-     mlir_aie_configure_shimdma_20(_xaie);
- #endif
-
-    printf("before core start");
+  mlir_aie_init_mems(_xaie, 4);
+
+  printf("Finish configure");
+#define DMA_COUNT_IN 256 * INPUT_ROWS
+#define DMA_COUNT_OUT 256 * 2 * B_BLOCK_DEPTH
+
+  int *ddr_ptr_in_0 = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT_IN);
+  int *ddr_ptr_in_1 = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT_IN);
+  int *ddr_ptr_out_0 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT_OUT);
+  int *ddr_ptr_out_1 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT_OUT);
+  for (int i = 0; i < DMA_COUNT_IN; i++) {
+    *(ddr_ptr_in_0 + i) = i;
+    *(ddr_ptr_in_1 + i) = i;
+  }
+  for (int i = 0; i < DMA_COUNT_OUT; i++) {
+    *(ddr_ptr_out_0 + i) = i;
+    *(ddr_ptr_out_1 + i) = i;
+  }
+  mlir_aie_sync_mem_dev(_xaie, 0);
+  mlir_aie_sync_mem_dev(_xaie, 1);
+  mlir_aie_sync_mem_dev(_xaie, 2);
+  mlir_aie_sync_mem_dev(_xaie, 3);
+#ifdef LIBXAIENGINEV2
+  mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0);
+  mlir_aie_external_set_addr_ddr_buffer_in_1((u64)ddr_ptr_in_1);
+  mlir_aie_external_set_addr_ddr_buffer_out_0((u64)ddr_ptr_out_0);
+  mlir_aie_external_set_addr_ddr_buffer_out_1((u64)ddr_ptr_out_1);
+  mlir_aie_configure_shimdma_20(_xaie);
+#endif
+
+  printf("before core start");
   // mlir_aie_print_tile_status(_xaie, 7, 3);
 
   printf("Release lock for accessing DDR.");
-  mlir_aie_release_of_0_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
+  mlir_aie_release_of_0_lock_0(_xaie, 1, 0);  // (_xaie,release_value,time_out)
   mlir_aie_release_of_23_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_15_lock_0(_xaie, 0, 0);
   mlir_aie_release_of_38_lock_0(_xaie, 0, 0);
 
-
-
-/*ADDD ALL THE LOCKS*/
-
-
-
+  /*ADDD ALL THE LOCKS*/
 
   printf("Start cores");
   ///// --- start counter-----
-  t = clock(); 
+  t = clock();
   mlir_aie_start_cores(_xaie);
-      mlir_aie_release_lock(_xaie, 0, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 0, 6, 14, 0, 0); // for timing
- 
+  mlir_aie_release_lock(_xaie, 0, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 0, 6, 14, 0, 0); // for timing
 
-         t = clock() - t; 
+  t = clock() - t;
 
-  printf ("It took %ld clicks (%f seconds).",t,((float)t)/CLOCKS_PER_SEC);
+  printf("It took %ld clicks (%f seconds).", t, ((float)t) / CLOCKS_PER_SEC);
 
   usleep(sleep_u);
   printf("after core start");
   // mlir_aie_print_tile_status(_xaie, 7, 3);
 
   usleep(sleep_u);
-  mlir_aie_sync_mem_cpu(_xaie, 2); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 3); //// only used in libaiev2 //sync up with output
- 
+  mlir_aie_sync_mem_cpu(_xaie,
+                        2); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        3); //// only used in libaiev2 //sync up with output
 
-      for (int i =0; i < 512; i ++ ){
+  for (int i = 0; i < 512; i++) {
     printf("Location %d:  %d", i, ddr_ptr_out_0[i]);
   }
 
@@ -147,10 +145,9 @@ int main(int argc, char *argv[]) {
   } else {
     printf("Fail!");
     res = -1;
-  } 
+  }
   printf("PC0 cycles: %d", pc0.diff());
-   printf("PC1 cycles: %d", pc1.diff());
- 
+  printf("PC1 cycles: %d", pc1.diff());
 
   mlir_aie_deinit_libxaie(_xaie);
 
@@ -158,7 +155,3 @@ int main(int argc, char *argv[]) {
 
   return res;
 }
-
-    
-    
-    
\ No newline at end of file
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_32.cpp b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_32.cpp
index ede20c4..9f9be24 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_32.cpp
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_32.cpp
@@ -1,10 +1,9 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-    
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-
 #include "test_library.h"
 #include <cassert>
 #include <cmath>
@@ -14,23 +13,23 @@
 #include <stdlib.h>
 #include <sys/mman.h>
 #include <thread>
+#include <time.h>
 #include <unistd.h>
 #include <xaiengine.h>
-#include <time.h>  
 #define HIGH_ADDR(addr) ((addr & 0xffffffff00000000) >> 32)
 #define LOW_ADDR(addr) (addr & 0x00000000ffffffff)
 #define MLIR_STACK_OFFSET 4096
-#define B_BLOCK_DEPTH 4 //set how many rows
-#define HDIFF_COL 3 //columns
+#define B_BLOCK_DEPTH 4 // set how many rows
+#define HDIFF_COL 3     // columns
 #define START_ROW 1
-#define INPUT_ROWS 9   
-    
-    #define TOTAL_B_BLOCK 32
- #include "aie_inc.cpp"
+#define INPUT_ROWS 9
+
+#define TOTAL_B_BLOCK 32
+#include "aie_inc.cpp"
 
 int main(int argc, char *argv[]) {
   printf("test start.");
-  clock_t t; 
+  clock_t t;
 
   aie_libxaie_ctx_t *_xaie = mlir_aie_init_libxaie();
   mlir_aie_init_device(_xaie);
@@ -38,15 +37,14 @@ int main(int argc, char *argv[]) {
   u32 sleep_u = 100000;
   usleep(sleep_u);
   printf("before configure cores.");
-   for (int b=0; b<TOTAL_B_BLOCK;b++)
-  {
-    for (int i=0; i<HDIFF_COL;i++){
-      for (int j=START_ROW; j<START_ROW+B_BLOCK_DEPTH;j++)
+  for (int b = 0; b < TOTAL_B_BLOCK; b++) {
+    for (int i = 0; i < HDIFF_COL; i++) {
+      for (int j = START_ROW; j < START_ROW + B_BLOCK_DEPTH; j++)
         mlir_aie_clear_tile_memory(_xaie, i, j);
     }
   }
 
-//   mlir_aie_clear_tile_memory(_xaie, 6, 4);
+  //   mlir_aie_clear_tile_memory(_xaie, 6, 4);
   mlir_aie_configure_cores(_xaie);
 
   usleep(sleep_u);
@@ -54,461 +52,556 @@ int main(int argc, char *argv[]) {
   mlir_aie_configure_switchboxes(_xaie);
   mlir_aie_initialize_locks(_xaie);
 
-      mlir_aie_acquire_lock(_xaie, 0, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc0(_xaie, 2, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc0.set();
- 
+  mlir_aie_acquire_lock(_xaie, 0, 2, 14, 0, 0); // for timing
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc0(_xaie, 2, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc0.set();
+
   mlir_aie_acquire_lock(_xaie, 0, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc1(_xaie, 2, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc1.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc1(_xaie, 2, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc1.set();
+
   mlir_aie_acquire_lock(_xaie, 3, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc2(_xaie, 5, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc2.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc2(_xaie, 5, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc2.set();
+
   mlir_aie_acquire_lock(_xaie, 3, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc3(_xaie, 5, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc3.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc3(_xaie, 5, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc3.set();
+
   mlir_aie_acquire_lock(_xaie, 6, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(6,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc4(_xaie, 8, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc4.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(6, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc4(_xaie, 8, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc4.set();
+
   mlir_aie_acquire_lock(_xaie, 6, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(6,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc5(_xaie, 8, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc5.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(6, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc5(_xaie, 8, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc5.set();
+
   mlir_aie_acquire_lock(_xaie, 9, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(9,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc6(_xaie, 11, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc6.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(9, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc6(_xaie, 11, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc6.set();
+
   mlir_aie_acquire_lock(_xaie, 9, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(9,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc7(_xaie, 11, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc7.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(9, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc7(_xaie, 11, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc7.set();
+
   mlir_aie_acquire_lock(_xaie, 12, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(12,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc8(_xaie, 14, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc8.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(12, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc8(_xaie, 14, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc8.set();
+
   mlir_aie_acquire_lock(_xaie, 12, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(12,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc9(_xaie, 14, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc9.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(12, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc9(_xaie, 14, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc9.set();
+
   mlir_aie_acquire_lock(_xaie, 15, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(15,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc10(_xaie, 17, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc10.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(15, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc10(_xaie, 17, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc10.set();
+
   mlir_aie_acquire_lock(_xaie, 15, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(15,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc11(_xaie, 17, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc11.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(15, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc11(_xaie, 17, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc11.set();
+
   mlir_aie_acquire_lock(_xaie, 18, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(18,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc12(_xaie, 20, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc12.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(18, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc12(_xaie, 20, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc12.set();
+
   mlir_aie_acquire_lock(_xaie, 18, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(18,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc13(_xaie, 20, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc13.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(18, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc13(_xaie, 20, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc13.set();
+
   mlir_aie_acquire_lock(_xaie, 21, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(21,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc14(_xaie, 23, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc14.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(21, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc14(_xaie, 23, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc14.set();
+
   mlir_aie_acquire_lock(_xaie, 21, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(21,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc15(_xaie, 23, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc15.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(21, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc15(_xaie, 23, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc15.set();
+
   mlir_aie_acquire_lock(_xaie, 24, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(24,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc16(_xaie, 26, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc16.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(24, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc16(_xaie, 26, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc16.set();
+
   mlir_aie_acquire_lock(_xaie, 24, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(24,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc17(_xaie, 26, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc17.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(24, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc17(_xaie, 26, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc17.set();
+
   mlir_aie_acquire_lock(_xaie, 27, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(27,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc18(_xaie, 29, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc18.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(27, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc18(_xaie, 29, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc18.set();
+
   mlir_aie_acquire_lock(_xaie, 27, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(27,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc19(_xaie, 29, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc19.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(27, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc19(_xaie, 29, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc19.set();
+
   mlir_aie_acquire_lock(_xaie, 30, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(30,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc20(_xaie, 32, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc20.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(30, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc20(_xaie, 32, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc20.set();
+
   mlir_aie_acquire_lock(_xaie, 30, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(30,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc21(_xaie, 32, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc21.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(30, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc21(_xaie, 32, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc21.set();
+
   mlir_aie_acquire_lock(_xaie, 33, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(33,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc22(_xaie, 35, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc22.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(33, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc22(_xaie, 35, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc22.set();
+
   mlir_aie_acquire_lock(_xaie, 33, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(33,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc23(_xaie, 35, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc23.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(33, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc23(_xaie, 35, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc23.set();
+
   mlir_aie_acquire_lock(_xaie, 36, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(36,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc24(_xaie, 38, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc24.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(36, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc24(_xaie, 38, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc24.set();
+
   mlir_aie_acquire_lock(_xaie, 36, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(36,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc25(_xaie, 38, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc25.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(36, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc25(_xaie, 38, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc25.set();
+
   mlir_aie_acquire_lock(_xaie, 39, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(39,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc26(_xaie, 41, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc26.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(39, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc26(_xaie, 41, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc26.set();
+
   mlir_aie_acquire_lock(_xaie, 39, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(39,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc27(_xaie, 41, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc27.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(39, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc27(_xaie, 41, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc27.set();
+
   mlir_aie_acquire_lock(_xaie, 42, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(42,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc28(_xaie, 44, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc28.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(42, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc28(_xaie, 44, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc28.set();
+
   mlir_aie_acquire_lock(_xaie, 42, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(42,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc29(_xaie, 44, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc29.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(42, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc29(_xaie, 44, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc29.set();
+
   mlir_aie_acquire_lock(_xaie, 45, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(45,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc30(_xaie, 47, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc30.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(45, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc30(_xaie, 47, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc30.set();
+
   mlir_aie_acquire_lock(_xaie, 45, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(45,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc31(_xaie, 47, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc31.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(45, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc31(_xaie, 47, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                    XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                    XAIE_MEM_MOD);
+  pc31.set();
 
-    usleep(sleep_u);
+  usleep(sleep_u);
   printf("before configure DMA");
   mlir_aie_configure_dmas(_xaie);
   int errors = 0;
-      mlir_aie_init_mems(_xaie, 64);
- 
-    printf("Finish configure");
-  #define DMA_COUNT_IN 256*INPUT_ROWS
-  #define DMA_COUNT_OUT 256*2*B_BLOCK_DEPTH
-
-      int *ddr_ptr_in_0 = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT_IN);
-   int *ddr_ptr_in_1 = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT_IN);
-   int *ddr_ptr_in_2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT_IN);
-   int *ddr_ptr_in_3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT_IN);
-   int *ddr_ptr_in_4 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT_IN);
-   int *ddr_ptr_in_5 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT_IN);
-   int *ddr_ptr_in_6 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT_IN);
-   int *ddr_ptr_in_7 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT_IN);
-   int *ddr_ptr_in_8 = mlir_aie_mem_alloc(_xaie, 8, DMA_COUNT_IN);
-   int *ddr_ptr_in_9 = mlir_aie_mem_alloc(_xaie, 9, DMA_COUNT_IN);
-   int *ddr_ptr_in_10 = mlir_aie_mem_alloc(_xaie, 10, DMA_COUNT_IN);
-   int *ddr_ptr_in_11 = mlir_aie_mem_alloc(_xaie, 11, DMA_COUNT_IN);
-   int *ddr_ptr_in_12 = mlir_aie_mem_alloc(_xaie, 12, DMA_COUNT_IN);
-   int *ddr_ptr_in_13 = mlir_aie_mem_alloc(_xaie, 13, DMA_COUNT_IN);
-   int *ddr_ptr_in_14 = mlir_aie_mem_alloc(_xaie, 14, DMA_COUNT_IN);
-   int *ddr_ptr_in_15 = mlir_aie_mem_alloc(_xaie, 15, DMA_COUNT_IN);
-   int *ddr_ptr_in_16 = mlir_aie_mem_alloc(_xaie, 16, DMA_COUNT_IN);
-   int *ddr_ptr_in_17 = mlir_aie_mem_alloc(_xaie, 17, DMA_COUNT_IN);
-   int *ddr_ptr_in_18 = mlir_aie_mem_alloc(_xaie, 18, DMA_COUNT_IN);
-   int *ddr_ptr_in_19 = mlir_aie_mem_alloc(_xaie, 19, DMA_COUNT_IN);
-   int *ddr_ptr_in_20 = mlir_aie_mem_alloc(_xaie, 20, DMA_COUNT_IN);
-   int *ddr_ptr_in_21 = mlir_aie_mem_alloc(_xaie, 21, DMA_COUNT_IN);
-   int *ddr_ptr_in_22 = mlir_aie_mem_alloc(_xaie, 22, DMA_COUNT_IN);
-   int *ddr_ptr_in_23 = mlir_aie_mem_alloc(_xaie, 23, DMA_COUNT_IN);
-   int *ddr_ptr_in_24 = mlir_aie_mem_alloc(_xaie, 24, DMA_COUNT_IN);
-   int *ddr_ptr_in_25 = mlir_aie_mem_alloc(_xaie, 25, DMA_COUNT_IN);
-   int *ddr_ptr_in_26 = mlir_aie_mem_alloc(_xaie, 26, DMA_COUNT_IN);
-   int *ddr_ptr_in_27 = mlir_aie_mem_alloc(_xaie, 27, DMA_COUNT_IN);
-   int *ddr_ptr_in_28 = mlir_aie_mem_alloc(_xaie, 28, DMA_COUNT_IN);
-   int *ddr_ptr_in_29 = mlir_aie_mem_alloc(_xaie, 29, DMA_COUNT_IN);
-   int *ddr_ptr_in_30 = mlir_aie_mem_alloc(_xaie, 30, DMA_COUNT_IN);
-   int *ddr_ptr_in_31 = mlir_aie_mem_alloc(_xaie, 31, DMA_COUNT_IN);
-   int *ddr_ptr_out_0 = mlir_aie_mem_alloc(_xaie, 32, DMA_COUNT_OUT);
-   int *ddr_ptr_out_1 = mlir_aie_mem_alloc(_xaie, 33, DMA_COUNT_OUT);
-   int *ddr_ptr_out_2 = mlir_aie_mem_alloc(_xaie, 34, DMA_COUNT_OUT);
-   int *ddr_ptr_out_3 = mlir_aie_mem_alloc(_xaie, 35, DMA_COUNT_OUT);
-   int *ddr_ptr_out_4 = mlir_aie_mem_alloc(_xaie, 36, DMA_COUNT_OUT);
-   int *ddr_ptr_out_5 = mlir_aie_mem_alloc(_xaie, 37, DMA_COUNT_OUT);
-   int *ddr_ptr_out_6 = mlir_aie_mem_alloc(_xaie, 38, DMA_COUNT_OUT);
-   int *ddr_ptr_out_7 = mlir_aie_mem_alloc(_xaie, 39, DMA_COUNT_OUT);
-   int *ddr_ptr_out_8 = mlir_aie_mem_alloc(_xaie, 40, DMA_COUNT_OUT);
-   int *ddr_ptr_out_9 = mlir_aie_mem_alloc(_xaie, 41, DMA_COUNT_OUT);
-   int *ddr_ptr_out_10 = mlir_aie_mem_alloc(_xaie, 42, DMA_COUNT_OUT);
-   int *ddr_ptr_out_11 = mlir_aie_mem_alloc(_xaie, 43, DMA_COUNT_OUT);
-   int *ddr_ptr_out_12 = mlir_aie_mem_alloc(_xaie, 44, DMA_COUNT_OUT);
-   int *ddr_ptr_out_13 = mlir_aie_mem_alloc(_xaie, 45, DMA_COUNT_OUT);
-   int *ddr_ptr_out_14 = mlir_aie_mem_alloc(_xaie, 46, DMA_COUNT_OUT);
-   int *ddr_ptr_out_15 = mlir_aie_mem_alloc(_xaie, 47, DMA_COUNT_OUT);
-   int *ddr_ptr_out_16 = mlir_aie_mem_alloc(_xaie, 48, DMA_COUNT_OUT);
-   int *ddr_ptr_out_17 = mlir_aie_mem_alloc(_xaie, 49, DMA_COUNT_OUT);
-   int *ddr_ptr_out_18 = mlir_aie_mem_alloc(_xaie, 50, DMA_COUNT_OUT);
-   int *ddr_ptr_out_19 = mlir_aie_mem_alloc(_xaie, 51, DMA_COUNT_OUT);
-   int *ddr_ptr_out_20 = mlir_aie_mem_alloc(_xaie, 52, DMA_COUNT_OUT);
-   int *ddr_ptr_out_21 = mlir_aie_mem_alloc(_xaie, 53, DMA_COUNT_OUT);
-   int *ddr_ptr_out_22 = mlir_aie_mem_alloc(_xaie, 54, DMA_COUNT_OUT);
-   int *ddr_ptr_out_23 = mlir_aie_mem_alloc(_xaie, 55, DMA_COUNT_OUT);
-   int *ddr_ptr_out_24 = mlir_aie_mem_alloc(_xaie, 56, DMA_COUNT_OUT);
-   int *ddr_ptr_out_25 = mlir_aie_mem_alloc(_xaie, 57, DMA_COUNT_OUT);
-   int *ddr_ptr_out_26 = mlir_aie_mem_alloc(_xaie, 58, DMA_COUNT_OUT);
-   int *ddr_ptr_out_27 = mlir_aie_mem_alloc(_xaie, 59, DMA_COUNT_OUT);
-   int *ddr_ptr_out_28 = mlir_aie_mem_alloc(_xaie, 60, DMA_COUNT_OUT);
-   int *ddr_ptr_out_29 = mlir_aie_mem_alloc(_xaie, 61, DMA_COUNT_OUT);
-   int *ddr_ptr_out_30 = mlir_aie_mem_alloc(_xaie, 62, DMA_COUNT_OUT);
-   int *ddr_ptr_out_31 = mlir_aie_mem_alloc(_xaie, 63, DMA_COUNT_OUT);
-   for (int i = 0; i < DMA_COUNT_IN; i++) {
-     *(ddr_ptr_in_0+ i) = i;
-     *(ddr_ptr_in_1+ i) = i;
-     *(ddr_ptr_in_2+ i) = i;
-     *(ddr_ptr_in_3+ i) = i;
-     *(ddr_ptr_in_4+ i) = i;
-     *(ddr_ptr_in_5+ i) = i;
-     *(ddr_ptr_in_6+ i) = i;
-     *(ddr_ptr_in_7+ i) = i;
-     *(ddr_ptr_in_8+ i) = i;
-     *(ddr_ptr_in_9+ i) = i;
-     *(ddr_ptr_in_10+ i) = i;
-     *(ddr_ptr_in_11+ i) = i;
-     *(ddr_ptr_in_12+ i) = i;
-     *(ddr_ptr_in_13+ i) = i;
-     *(ddr_ptr_in_14+ i) = i;
-     *(ddr_ptr_in_15+ i) = i;
-     *(ddr_ptr_in_16+ i) = i;
-     *(ddr_ptr_in_17+ i) = i;
-     *(ddr_ptr_in_18+ i) = i;
-     *(ddr_ptr_in_19+ i) = i;
-     *(ddr_ptr_in_20+ i) = i;
-     *(ddr_ptr_in_21+ i) = i;
-     *(ddr_ptr_in_22+ i) = i;
-     *(ddr_ptr_in_23+ i) = i;
-     *(ddr_ptr_in_24+ i) = i;
-     *(ddr_ptr_in_25+ i) = i;
-     *(ddr_ptr_in_26+ i) = i;
-     *(ddr_ptr_in_27+ i) = i;
-     *(ddr_ptr_in_28+ i) = i;
-     *(ddr_ptr_in_29+ i) = i;
-     *(ddr_ptr_in_30+ i) = i;
-     *(ddr_ptr_in_31+ i) = i;
-   }
-   for (int i = 0; i < DMA_COUNT_OUT; i++) {
-     *(ddr_ptr_out_0+ i) = i;
-     *(ddr_ptr_out_1+ i) = i;
-     *(ddr_ptr_out_2+ i) = i;
-     *(ddr_ptr_out_3+ i) = i;
-     *(ddr_ptr_out_4+ i) = i;
-     *(ddr_ptr_out_5+ i) = i;
-     *(ddr_ptr_out_6+ i) = i;
-     *(ddr_ptr_out_7+ i) = i;
-     *(ddr_ptr_out_8+ i) = i;
-     *(ddr_ptr_out_9+ i) = i;
-     *(ddr_ptr_out_10+ i) = i;
-     *(ddr_ptr_out_11+ i) = i;
-     *(ddr_ptr_out_12+ i) = i;
-     *(ddr_ptr_out_13+ i) = i;
-     *(ddr_ptr_out_14+ i) = i;
-     *(ddr_ptr_out_15+ i) = i;
-     *(ddr_ptr_out_16+ i) = i;
-     *(ddr_ptr_out_17+ i) = i;
-     *(ddr_ptr_out_18+ i) = i;
-     *(ddr_ptr_out_19+ i) = i;
-     *(ddr_ptr_out_20+ i) = i;
-     *(ddr_ptr_out_21+ i) = i;
-     *(ddr_ptr_out_22+ i) = i;
-     *(ddr_ptr_out_23+ i) = i;
-     *(ddr_ptr_out_24+ i) = i;
-     *(ddr_ptr_out_25+ i) = i;
-     *(ddr_ptr_out_26+ i) = i;
-     *(ddr_ptr_out_27+ i) = i;
-     *(ddr_ptr_out_28+ i) = i;
-     *(ddr_ptr_out_29+ i) = i;
-     *(ddr_ptr_out_30+ i) = i;
-     *(ddr_ptr_out_31+ i) = i;
-   }
-   mlir_aie_sync_mem_dev(_xaie, 0);
-   mlir_aie_sync_mem_dev(_xaie, 1);
-   mlir_aie_sync_mem_dev(_xaie, 2);
-   mlir_aie_sync_mem_dev(_xaie, 3);
-   mlir_aie_sync_mem_dev(_xaie, 4);
-   mlir_aie_sync_mem_dev(_xaie, 5);
-   mlir_aie_sync_mem_dev(_xaie, 6);
-   mlir_aie_sync_mem_dev(_xaie, 7);
-   mlir_aie_sync_mem_dev(_xaie, 8);
-   mlir_aie_sync_mem_dev(_xaie, 9);
-   mlir_aie_sync_mem_dev(_xaie, 10);
-   mlir_aie_sync_mem_dev(_xaie, 11);
-   mlir_aie_sync_mem_dev(_xaie, 12);
-   mlir_aie_sync_mem_dev(_xaie, 13);
-   mlir_aie_sync_mem_dev(_xaie, 14);
-   mlir_aie_sync_mem_dev(_xaie, 15);
-   mlir_aie_sync_mem_dev(_xaie, 16);
-   mlir_aie_sync_mem_dev(_xaie, 17);
-   mlir_aie_sync_mem_dev(_xaie, 18);
-   mlir_aie_sync_mem_dev(_xaie, 19);
-   mlir_aie_sync_mem_dev(_xaie, 20);
-   mlir_aie_sync_mem_dev(_xaie, 21);
-   mlir_aie_sync_mem_dev(_xaie, 22);
-   mlir_aie_sync_mem_dev(_xaie, 23);
-   mlir_aie_sync_mem_dev(_xaie, 24);
-   mlir_aie_sync_mem_dev(_xaie, 25);
-   mlir_aie_sync_mem_dev(_xaie, 26);
-   mlir_aie_sync_mem_dev(_xaie, 27);
-   mlir_aie_sync_mem_dev(_xaie, 28);
-   mlir_aie_sync_mem_dev(_xaie, 29);
-   mlir_aie_sync_mem_dev(_xaie, 30);
-   mlir_aie_sync_mem_dev(_xaie, 31);
-   mlir_aie_sync_mem_dev(_xaie, 32);
-   mlir_aie_sync_mem_dev(_xaie, 33);
-   mlir_aie_sync_mem_dev(_xaie, 34);
-   mlir_aie_sync_mem_dev(_xaie, 35);
-   mlir_aie_sync_mem_dev(_xaie, 36);
-   mlir_aie_sync_mem_dev(_xaie, 37);
-   mlir_aie_sync_mem_dev(_xaie, 38);
-   mlir_aie_sync_mem_dev(_xaie, 39);
-   mlir_aie_sync_mem_dev(_xaie, 40);
-   mlir_aie_sync_mem_dev(_xaie, 41);
-   mlir_aie_sync_mem_dev(_xaie, 42);
-   mlir_aie_sync_mem_dev(_xaie, 43);
-   mlir_aie_sync_mem_dev(_xaie, 44);
-   mlir_aie_sync_mem_dev(_xaie, 45);
-   mlir_aie_sync_mem_dev(_xaie, 46);
-   mlir_aie_sync_mem_dev(_xaie, 47);
-   mlir_aie_sync_mem_dev(_xaie, 48);
-   mlir_aie_sync_mem_dev(_xaie, 49);
-   mlir_aie_sync_mem_dev(_xaie, 50);
-   mlir_aie_sync_mem_dev(_xaie, 51);
-   mlir_aie_sync_mem_dev(_xaie, 52);
-   mlir_aie_sync_mem_dev(_xaie, 53);
-   mlir_aie_sync_mem_dev(_xaie, 54);
-   mlir_aie_sync_mem_dev(_xaie, 55);
-   mlir_aie_sync_mem_dev(_xaie, 56);
-   mlir_aie_sync_mem_dev(_xaie, 57);
-   mlir_aie_sync_mem_dev(_xaie, 58);
-   mlir_aie_sync_mem_dev(_xaie, 59);
-   mlir_aie_sync_mem_dev(_xaie, 60);
-   mlir_aie_sync_mem_dev(_xaie, 61);
-   mlir_aie_sync_mem_dev(_xaie, 62);
-   mlir_aie_sync_mem_dev(_xaie, 63);
- #ifdef LIBXAIENGINEV2
-    mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0); 
-     mlir_aie_external_set_addr_ddr_buffer_in_1((u64)ddr_ptr_in_1); 
-     mlir_aie_external_set_addr_ddr_buffer_in_2((u64)ddr_ptr_in_2); 
-     mlir_aie_external_set_addr_ddr_buffer_in_3((u64)ddr_ptr_in_3); 
-     mlir_aie_external_set_addr_ddr_buffer_in_4((u64)ddr_ptr_in_4); 
-     mlir_aie_external_set_addr_ddr_buffer_in_5((u64)ddr_ptr_in_5); 
-     mlir_aie_external_set_addr_ddr_buffer_in_6((u64)ddr_ptr_in_6); 
-     mlir_aie_external_set_addr_ddr_buffer_in_7((u64)ddr_ptr_in_7); 
-     mlir_aie_external_set_addr_ddr_buffer_in_8((u64)ddr_ptr_in_8); 
-     mlir_aie_external_set_addr_ddr_buffer_in_9((u64)ddr_ptr_in_9); 
-     mlir_aie_external_set_addr_ddr_buffer_in_10((u64)ddr_ptr_in_10); 
-     mlir_aie_external_set_addr_ddr_buffer_in_11((u64)ddr_ptr_in_11); 
-     mlir_aie_external_set_addr_ddr_buffer_in_12((u64)ddr_ptr_in_12); 
-     mlir_aie_external_set_addr_ddr_buffer_in_13((u64)ddr_ptr_in_13); 
-     mlir_aie_external_set_addr_ddr_buffer_in_14((u64)ddr_ptr_in_14); 
-     mlir_aie_external_set_addr_ddr_buffer_in_15((u64)ddr_ptr_in_15); 
-     mlir_aie_external_set_addr_ddr_buffer_in_16((u64)ddr_ptr_in_16); 
-     mlir_aie_external_set_addr_ddr_buffer_in_17((u64)ddr_ptr_in_17); 
-     mlir_aie_external_set_addr_ddr_buffer_in_18((u64)ddr_ptr_in_18); 
-     mlir_aie_external_set_addr_ddr_buffer_in_19((u64)ddr_ptr_in_19); 
-     mlir_aie_external_set_addr_ddr_buffer_in_20((u64)ddr_ptr_in_20); 
-     mlir_aie_external_set_addr_ddr_buffer_in_21((u64)ddr_ptr_in_21); 
-     mlir_aie_external_set_addr_ddr_buffer_in_22((u64)ddr_ptr_in_22); 
-     mlir_aie_external_set_addr_ddr_buffer_in_23((u64)ddr_ptr_in_23); 
-     mlir_aie_external_set_addr_ddr_buffer_in_24((u64)ddr_ptr_in_24); 
-     mlir_aie_external_set_addr_ddr_buffer_in_25((u64)ddr_ptr_in_25); 
-     mlir_aie_external_set_addr_ddr_buffer_in_26((u64)ddr_ptr_in_26); 
-     mlir_aie_external_set_addr_ddr_buffer_in_27((u64)ddr_ptr_in_27); 
-     mlir_aie_external_set_addr_ddr_buffer_in_28((u64)ddr_ptr_in_28); 
-     mlir_aie_external_set_addr_ddr_buffer_in_29((u64)ddr_ptr_in_29); 
-     mlir_aie_external_set_addr_ddr_buffer_in_30((u64)ddr_ptr_in_30); 
-     mlir_aie_external_set_addr_ddr_buffer_in_31((u64)ddr_ptr_in_31); 
-     mlir_aie_external_set_addr_ddr_buffer_out_0((u64)ddr_ptr_out_0); 
-     mlir_aie_external_set_addr_ddr_buffer_out_1((u64)ddr_ptr_out_1); 
-     mlir_aie_external_set_addr_ddr_buffer_out_2((u64)ddr_ptr_out_2); 
-     mlir_aie_external_set_addr_ddr_buffer_out_3((u64)ddr_ptr_out_3); 
-     mlir_aie_external_set_addr_ddr_buffer_out_4((u64)ddr_ptr_out_4); 
-     mlir_aie_external_set_addr_ddr_buffer_out_5((u64)ddr_ptr_out_5); 
-     mlir_aie_external_set_addr_ddr_buffer_out_6((u64)ddr_ptr_out_6); 
-     mlir_aie_external_set_addr_ddr_buffer_out_7((u64)ddr_ptr_out_7); 
-     mlir_aie_external_set_addr_ddr_buffer_out_8((u64)ddr_ptr_out_8); 
-     mlir_aie_external_set_addr_ddr_buffer_out_9((u64)ddr_ptr_out_9); 
-     mlir_aie_external_set_addr_ddr_buffer_out_10((u64)ddr_ptr_out_10); 
-     mlir_aie_external_set_addr_ddr_buffer_out_11((u64)ddr_ptr_out_11); 
-     mlir_aie_external_set_addr_ddr_buffer_out_12((u64)ddr_ptr_out_12); 
-     mlir_aie_external_set_addr_ddr_buffer_out_13((u64)ddr_ptr_out_13); 
-     mlir_aie_external_set_addr_ddr_buffer_out_14((u64)ddr_ptr_out_14); 
-     mlir_aie_external_set_addr_ddr_buffer_out_15((u64)ddr_ptr_out_15); 
-     mlir_aie_external_set_addr_ddr_buffer_out_16((u64)ddr_ptr_out_16); 
-     mlir_aie_external_set_addr_ddr_buffer_out_17((u64)ddr_ptr_out_17); 
-     mlir_aie_external_set_addr_ddr_buffer_out_18((u64)ddr_ptr_out_18); 
-     mlir_aie_external_set_addr_ddr_buffer_out_19((u64)ddr_ptr_out_19); 
-     mlir_aie_external_set_addr_ddr_buffer_out_20((u64)ddr_ptr_out_20); 
-     mlir_aie_external_set_addr_ddr_buffer_out_21((u64)ddr_ptr_out_21); 
-     mlir_aie_external_set_addr_ddr_buffer_out_22((u64)ddr_ptr_out_22); 
-     mlir_aie_external_set_addr_ddr_buffer_out_23((u64)ddr_ptr_out_23); 
-     mlir_aie_external_set_addr_ddr_buffer_out_24((u64)ddr_ptr_out_24); 
-     mlir_aie_external_set_addr_ddr_buffer_out_25((u64)ddr_ptr_out_25); 
-     mlir_aie_external_set_addr_ddr_buffer_out_26((u64)ddr_ptr_out_26); 
-     mlir_aie_external_set_addr_ddr_buffer_out_27((u64)ddr_ptr_out_27); 
-     mlir_aie_external_set_addr_ddr_buffer_out_28((u64)ddr_ptr_out_28); 
-     mlir_aie_external_set_addr_ddr_buffer_out_29((u64)ddr_ptr_out_29); 
-     mlir_aie_external_set_addr_ddr_buffer_out_30((u64)ddr_ptr_out_30); 
-     mlir_aie_external_set_addr_ddr_buffer_out_31((u64)ddr_ptr_out_31); 
-     mlir_aie_configure_shimdma_20(_xaie);
-     mlir_aie_configure_shimdma_30(_xaie);
-     mlir_aie_configure_shimdma_60(_xaie);
-     mlir_aie_configure_shimdma_70(_xaie);
-     mlir_aie_configure_shimdma_100(_xaie);
-     mlir_aie_configure_shimdma_110(_xaie);
-     mlir_aie_configure_shimdma_180(_xaie);
-     mlir_aie_configure_shimdma_190(_xaie);
-     mlir_aie_configure_shimdma_260(_xaie);
-     mlir_aie_configure_shimdma_270(_xaie);
-     mlir_aie_configure_shimdma_340(_xaie);
-     mlir_aie_configure_shimdma_350(_xaie);
-     mlir_aie_configure_shimdma_420(_xaie);
-     mlir_aie_configure_shimdma_430(_xaie);
-     mlir_aie_configure_shimdma_460(_xaie);
-     mlir_aie_configure_shimdma_470(_xaie);
- #endif
-
-    printf("before core start");
+  mlir_aie_init_mems(_xaie, 64);
+
+  printf("Finish configure");
+#define DMA_COUNT_IN 256 * INPUT_ROWS
+#define DMA_COUNT_OUT 256 * 2 * B_BLOCK_DEPTH
+
+  int *ddr_ptr_in_0 = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT_IN);
+  int *ddr_ptr_in_1 = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT_IN);
+  int *ddr_ptr_in_2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT_IN);
+  int *ddr_ptr_in_3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT_IN);
+  int *ddr_ptr_in_4 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT_IN);
+  int *ddr_ptr_in_5 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT_IN);
+  int *ddr_ptr_in_6 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT_IN);
+  int *ddr_ptr_in_7 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT_IN);
+  int *ddr_ptr_in_8 = mlir_aie_mem_alloc(_xaie, 8, DMA_COUNT_IN);
+  int *ddr_ptr_in_9 = mlir_aie_mem_alloc(_xaie, 9, DMA_COUNT_IN);
+  int *ddr_ptr_in_10 = mlir_aie_mem_alloc(_xaie, 10, DMA_COUNT_IN);
+  int *ddr_ptr_in_11 = mlir_aie_mem_alloc(_xaie, 11, DMA_COUNT_IN);
+  int *ddr_ptr_in_12 = mlir_aie_mem_alloc(_xaie, 12, DMA_COUNT_IN);
+  int *ddr_ptr_in_13 = mlir_aie_mem_alloc(_xaie, 13, DMA_COUNT_IN);
+  int *ddr_ptr_in_14 = mlir_aie_mem_alloc(_xaie, 14, DMA_COUNT_IN);
+  int *ddr_ptr_in_15 = mlir_aie_mem_alloc(_xaie, 15, DMA_COUNT_IN);
+  int *ddr_ptr_in_16 = mlir_aie_mem_alloc(_xaie, 16, DMA_COUNT_IN);
+  int *ddr_ptr_in_17 = mlir_aie_mem_alloc(_xaie, 17, DMA_COUNT_IN);
+  int *ddr_ptr_in_18 = mlir_aie_mem_alloc(_xaie, 18, DMA_COUNT_IN);
+  int *ddr_ptr_in_19 = mlir_aie_mem_alloc(_xaie, 19, DMA_COUNT_IN);
+  int *ddr_ptr_in_20 = mlir_aie_mem_alloc(_xaie, 20, DMA_COUNT_IN);
+  int *ddr_ptr_in_21 = mlir_aie_mem_alloc(_xaie, 21, DMA_COUNT_IN);
+  int *ddr_ptr_in_22 = mlir_aie_mem_alloc(_xaie, 22, DMA_COUNT_IN);
+  int *ddr_ptr_in_23 = mlir_aie_mem_alloc(_xaie, 23, DMA_COUNT_IN);
+  int *ddr_ptr_in_24 = mlir_aie_mem_alloc(_xaie, 24, DMA_COUNT_IN);
+  int *ddr_ptr_in_25 = mlir_aie_mem_alloc(_xaie, 25, DMA_COUNT_IN);
+  int *ddr_ptr_in_26 = mlir_aie_mem_alloc(_xaie, 26, DMA_COUNT_IN);
+  int *ddr_ptr_in_27 = mlir_aie_mem_alloc(_xaie, 27, DMA_COUNT_IN);
+  int *ddr_ptr_in_28 = mlir_aie_mem_alloc(_xaie, 28, DMA_COUNT_IN);
+  int *ddr_ptr_in_29 = mlir_aie_mem_alloc(_xaie, 29, DMA_COUNT_IN);
+  int *ddr_ptr_in_30 = mlir_aie_mem_alloc(_xaie, 30, DMA_COUNT_IN);
+  int *ddr_ptr_in_31 = mlir_aie_mem_alloc(_xaie, 31, DMA_COUNT_IN);
+  int *ddr_ptr_out_0 = mlir_aie_mem_alloc(_xaie, 32, DMA_COUNT_OUT);
+  int *ddr_ptr_out_1 = mlir_aie_mem_alloc(_xaie, 33, DMA_COUNT_OUT);
+  int *ddr_ptr_out_2 = mlir_aie_mem_alloc(_xaie, 34, DMA_COUNT_OUT);
+  int *ddr_ptr_out_3 = mlir_aie_mem_alloc(_xaie, 35, DMA_COUNT_OUT);
+  int *ddr_ptr_out_4 = mlir_aie_mem_alloc(_xaie, 36, DMA_COUNT_OUT);
+  int *ddr_ptr_out_5 = mlir_aie_mem_alloc(_xaie, 37, DMA_COUNT_OUT);
+  int *ddr_ptr_out_6 = mlir_aie_mem_alloc(_xaie, 38, DMA_COUNT_OUT);
+  int *ddr_ptr_out_7 = mlir_aie_mem_alloc(_xaie, 39, DMA_COUNT_OUT);
+  int *ddr_ptr_out_8 = mlir_aie_mem_alloc(_xaie, 40, DMA_COUNT_OUT);
+  int *ddr_ptr_out_9 = mlir_aie_mem_alloc(_xaie, 41, DMA_COUNT_OUT);
+  int *ddr_ptr_out_10 = mlir_aie_mem_alloc(_xaie, 42, DMA_COUNT_OUT);
+  int *ddr_ptr_out_11 = mlir_aie_mem_alloc(_xaie, 43, DMA_COUNT_OUT);
+  int *ddr_ptr_out_12 = mlir_aie_mem_alloc(_xaie, 44, DMA_COUNT_OUT);
+  int *ddr_ptr_out_13 = mlir_aie_mem_alloc(_xaie, 45, DMA_COUNT_OUT);
+  int *ddr_ptr_out_14 = mlir_aie_mem_alloc(_xaie, 46, DMA_COUNT_OUT);
+  int *ddr_ptr_out_15 = mlir_aie_mem_alloc(_xaie, 47, DMA_COUNT_OUT);
+  int *ddr_ptr_out_16 = mlir_aie_mem_alloc(_xaie, 48, DMA_COUNT_OUT);
+  int *ddr_ptr_out_17 = mlir_aie_mem_alloc(_xaie, 49, DMA_COUNT_OUT);
+  int *ddr_ptr_out_18 = mlir_aie_mem_alloc(_xaie, 50, DMA_COUNT_OUT);
+  int *ddr_ptr_out_19 = mlir_aie_mem_alloc(_xaie, 51, DMA_COUNT_OUT);
+  int *ddr_ptr_out_20 = mlir_aie_mem_alloc(_xaie, 52, DMA_COUNT_OUT);
+  int *ddr_ptr_out_21 = mlir_aie_mem_alloc(_xaie, 53, DMA_COUNT_OUT);
+  int *ddr_ptr_out_22 = mlir_aie_mem_alloc(_xaie, 54, DMA_COUNT_OUT);
+  int *ddr_ptr_out_23 = mlir_aie_mem_alloc(_xaie, 55, DMA_COUNT_OUT);
+  int *ddr_ptr_out_24 = mlir_aie_mem_alloc(_xaie, 56, DMA_COUNT_OUT);
+  int *ddr_ptr_out_25 = mlir_aie_mem_alloc(_xaie, 57, DMA_COUNT_OUT);
+  int *ddr_ptr_out_26 = mlir_aie_mem_alloc(_xaie, 58, DMA_COUNT_OUT);
+  int *ddr_ptr_out_27 = mlir_aie_mem_alloc(_xaie, 59, DMA_COUNT_OUT);
+  int *ddr_ptr_out_28 = mlir_aie_mem_alloc(_xaie, 60, DMA_COUNT_OUT);
+  int *ddr_ptr_out_29 = mlir_aie_mem_alloc(_xaie, 61, DMA_COUNT_OUT);
+  int *ddr_ptr_out_30 = mlir_aie_mem_alloc(_xaie, 62, DMA_COUNT_OUT);
+  int *ddr_ptr_out_31 = mlir_aie_mem_alloc(_xaie, 63, DMA_COUNT_OUT);
+  for (int i = 0; i < DMA_COUNT_IN; i++) {
+    *(ddr_ptr_in_0 + i) = i;
+    *(ddr_ptr_in_1 + i) = i;
+    *(ddr_ptr_in_2 + i) = i;
+    *(ddr_ptr_in_3 + i) = i;
+    *(ddr_ptr_in_4 + i) = i;
+    *(ddr_ptr_in_5 + i) = i;
+    *(ddr_ptr_in_6 + i) = i;
+    *(ddr_ptr_in_7 + i) = i;
+    *(ddr_ptr_in_8 + i) = i;
+    *(ddr_ptr_in_9 + i) = i;
+    *(ddr_ptr_in_10 + i) = i;
+    *(ddr_ptr_in_11 + i) = i;
+    *(ddr_ptr_in_12 + i) = i;
+    *(ddr_ptr_in_13 + i) = i;
+    *(ddr_ptr_in_14 + i) = i;
+    *(ddr_ptr_in_15 + i) = i;
+    *(ddr_ptr_in_16 + i) = i;
+    *(ddr_ptr_in_17 + i) = i;
+    *(ddr_ptr_in_18 + i) = i;
+    *(ddr_ptr_in_19 + i) = i;
+    *(ddr_ptr_in_20 + i) = i;
+    *(ddr_ptr_in_21 + i) = i;
+    *(ddr_ptr_in_22 + i) = i;
+    *(ddr_ptr_in_23 + i) = i;
+    *(ddr_ptr_in_24 + i) = i;
+    *(ddr_ptr_in_25 + i) = i;
+    *(ddr_ptr_in_26 + i) = i;
+    *(ddr_ptr_in_27 + i) = i;
+    *(ddr_ptr_in_28 + i) = i;
+    *(ddr_ptr_in_29 + i) = i;
+    *(ddr_ptr_in_30 + i) = i;
+    *(ddr_ptr_in_31 + i) = i;
+  }
+  for (int i = 0; i < DMA_COUNT_OUT; i++) {
+    *(ddr_ptr_out_0 + i) = i;
+    *(ddr_ptr_out_1 + i) = i;
+    *(ddr_ptr_out_2 + i) = i;
+    *(ddr_ptr_out_3 + i) = i;
+    *(ddr_ptr_out_4 + i) = i;
+    *(ddr_ptr_out_5 + i) = i;
+    *(ddr_ptr_out_6 + i) = i;
+    *(ddr_ptr_out_7 + i) = i;
+    *(ddr_ptr_out_8 + i) = i;
+    *(ddr_ptr_out_9 + i) = i;
+    *(ddr_ptr_out_10 + i) = i;
+    *(ddr_ptr_out_11 + i) = i;
+    *(ddr_ptr_out_12 + i) = i;
+    *(ddr_ptr_out_13 + i) = i;
+    *(ddr_ptr_out_14 + i) = i;
+    *(ddr_ptr_out_15 + i) = i;
+    *(ddr_ptr_out_16 + i) = i;
+    *(ddr_ptr_out_17 + i) = i;
+    *(ddr_ptr_out_18 + i) = i;
+    *(ddr_ptr_out_19 + i) = i;
+    *(ddr_ptr_out_20 + i) = i;
+    *(ddr_ptr_out_21 + i) = i;
+    *(ddr_ptr_out_22 + i) = i;
+    *(ddr_ptr_out_23 + i) = i;
+    *(ddr_ptr_out_24 + i) = i;
+    *(ddr_ptr_out_25 + i) = i;
+    *(ddr_ptr_out_26 + i) = i;
+    *(ddr_ptr_out_27 + i) = i;
+    *(ddr_ptr_out_28 + i) = i;
+    *(ddr_ptr_out_29 + i) = i;
+    *(ddr_ptr_out_30 + i) = i;
+    *(ddr_ptr_out_31 + i) = i;
+  }
+  mlir_aie_sync_mem_dev(_xaie, 0);
+  mlir_aie_sync_mem_dev(_xaie, 1);
+  mlir_aie_sync_mem_dev(_xaie, 2);
+  mlir_aie_sync_mem_dev(_xaie, 3);
+  mlir_aie_sync_mem_dev(_xaie, 4);
+  mlir_aie_sync_mem_dev(_xaie, 5);
+  mlir_aie_sync_mem_dev(_xaie, 6);
+  mlir_aie_sync_mem_dev(_xaie, 7);
+  mlir_aie_sync_mem_dev(_xaie, 8);
+  mlir_aie_sync_mem_dev(_xaie, 9);
+  mlir_aie_sync_mem_dev(_xaie, 10);
+  mlir_aie_sync_mem_dev(_xaie, 11);
+  mlir_aie_sync_mem_dev(_xaie, 12);
+  mlir_aie_sync_mem_dev(_xaie, 13);
+  mlir_aie_sync_mem_dev(_xaie, 14);
+  mlir_aie_sync_mem_dev(_xaie, 15);
+  mlir_aie_sync_mem_dev(_xaie, 16);
+  mlir_aie_sync_mem_dev(_xaie, 17);
+  mlir_aie_sync_mem_dev(_xaie, 18);
+  mlir_aie_sync_mem_dev(_xaie, 19);
+  mlir_aie_sync_mem_dev(_xaie, 20);
+  mlir_aie_sync_mem_dev(_xaie, 21);
+  mlir_aie_sync_mem_dev(_xaie, 22);
+  mlir_aie_sync_mem_dev(_xaie, 23);
+  mlir_aie_sync_mem_dev(_xaie, 24);
+  mlir_aie_sync_mem_dev(_xaie, 25);
+  mlir_aie_sync_mem_dev(_xaie, 26);
+  mlir_aie_sync_mem_dev(_xaie, 27);
+  mlir_aie_sync_mem_dev(_xaie, 28);
+  mlir_aie_sync_mem_dev(_xaie, 29);
+  mlir_aie_sync_mem_dev(_xaie, 30);
+  mlir_aie_sync_mem_dev(_xaie, 31);
+  mlir_aie_sync_mem_dev(_xaie, 32);
+  mlir_aie_sync_mem_dev(_xaie, 33);
+  mlir_aie_sync_mem_dev(_xaie, 34);
+  mlir_aie_sync_mem_dev(_xaie, 35);
+  mlir_aie_sync_mem_dev(_xaie, 36);
+  mlir_aie_sync_mem_dev(_xaie, 37);
+  mlir_aie_sync_mem_dev(_xaie, 38);
+  mlir_aie_sync_mem_dev(_xaie, 39);
+  mlir_aie_sync_mem_dev(_xaie, 40);
+  mlir_aie_sync_mem_dev(_xaie, 41);
+  mlir_aie_sync_mem_dev(_xaie, 42);
+  mlir_aie_sync_mem_dev(_xaie, 43);
+  mlir_aie_sync_mem_dev(_xaie, 44);
+  mlir_aie_sync_mem_dev(_xaie, 45);
+  mlir_aie_sync_mem_dev(_xaie, 46);
+  mlir_aie_sync_mem_dev(_xaie, 47);
+  mlir_aie_sync_mem_dev(_xaie, 48);
+  mlir_aie_sync_mem_dev(_xaie, 49);
+  mlir_aie_sync_mem_dev(_xaie, 50);
+  mlir_aie_sync_mem_dev(_xaie, 51);
+  mlir_aie_sync_mem_dev(_xaie, 52);
+  mlir_aie_sync_mem_dev(_xaie, 53);
+  mlir_aie_sync_mem_dev(_xaie, 54);
+  mlir_aie_sync_mem_dev(_xaie, 55);
+  mlir_aie_sync_mem_dev(_xaie, 56);
+  mlir_aie_sync_mem_dev(_xaie, 57);
+  mlir_aie_sync_mem_dev(_xaie, 58);
+  mlir_aie_sync_mem_dev(_xaie, 59);
+  mlir_aie_sync_mem_dev(_xaie, 60);
+  mlir_aie_sync_mem_dev(_xaie, 61);
+  mlir_aie_sync_mem_dev(_xaie, 62);
+  mlir_aie_sync_mem_dev(_xaie, 63);
+#ifdef LIBXAIENGINEV2
+  mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0);
+  mlir_aie_external_set_addr_ddr_buffer_in_1((u64)ddr_ptr_in_1);
+  mlir_aie_external_set_addr_ddr_buffer_in_2((u64)ddr_ptr_in_2);
+  mlir_aie_external_set_addr_ddr_buffer_in_3((u64)ddr_ptr_in_3);
+  mlir_aie_external_set_addr_ddr_buffer_in_4((u64)ddr_ptr_in_4);
+  mlir_aie_external_set_addr_ddr_buffer_in_5((u64)ddr_ptr_in_5);
+  mlir_aie_external_set_addr_ddr_buffer_in_6((u64)ddr_ptr_in_6);
+  mlir_aie_external_set_addr_ddr_buffer_in_7((u64)ddr_ptr_in_7);
+  mlir_aie_external_set_addr_ddr_buffer_in_8((u64)ddr_ptr_in_8);
+  mlir_aie_external_set_addr_ddr_buffer_in_9((u64)ddr_ptr_in_9);
+  mlir_aie_external_set_addr_ddr_buffer_in_10((u64)ddr_ptr_in_10);
+  mlir_aie_external_set_addr_ddr_buffer_in_11((u64)ddr_ptr_in_11);
+  mlir_aie_external_set_addr_ddr_buffer_in_12((u64)ddr_ptr_in_12);
+  mlir_aie_external_set_addr_ddr_buffer_in_13((u64)ddr_ptr_in_13);
+  mlir_aie_external_set_addr_ddr_buffer_in_14((u64)ddr_ptr_in_14);
+  mlir_aie_external_set_addr_ddr_buffer_in_15((u64)ddr_ptr_in_15);
+  mlir_aie_external_set_addr_ddr_buffer_in_16((u64)ddr_ptr_in_16);
+  mlir_aie_external_set_addr_ddr_buffer_in_17((u64)ddr_ptr_in_17);
+  mlir_aie_external_set_addr_ddr_buffer_in_18((u64)ddr_ptr_in_18);
+  mlir_aie_external_set_addr_ddr_buffer_in_19((u64)ddr_ptr_in_19);
+  mlir_aie_external_set_addr_ddr_buffer_in_20((u64)ddr_ptr_in_20);
+  mlir_aie_external_set_addr_ddr_buffer_in_21((u64)ddr_ptr_in_21);
+  mlir_aie_external_set_addr_ddr_buffer_in_22((u64)ddr_ptr_in_22);
+  mlir_aie_external_set_addr_ddr_buffer_in_23((u64)ddr_ptr_in_23);
+  mlir_aie_external_set_addr_ddr_buffer_in_24((u64)ddr_ptr_in_24);
+  mlir_aie_external_set_addr_ddr_buffer_in_25((u64)ddr_ptr_in_25);
+  mlir_aie_external_set_addr_ddr_buffer_in_26((u64)ddr_ptr_in_26);
+  mlir_aie_external_set_addr_ddr_buffer_in_27((u64)ddr_ptr_in_27);
+  mlir_aie_external_set_addr_ddr_buffer_in_28((u64)ddr_ptr_in_28);
+  mlir_aie_external_set_addr_ddr_buffer_in_29((u64)ddr_ptr_in_29);
+  mlir_aie_external_set_addr_ddr_buffer_in_30((u64)ddr_ptr_in_30);
+  mlir_aie_external_set_addr_ddr_buffer_in_31((u64)ddr_ptr_in_31);
+  mlir_aie_external_set_addr_ddr_buffer_out_0((u64)ddr_ptr_out_0);
+  mlir_aie_external_set_addr_ddr_buffer_out_1((u64)ddr_ptr_out_1);
+  mlir_aie_external_set_addr_ddr_buffer_out_2((u64)ddr_ptr_out_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_3((u64)ddr_ptr_out_3);
+  mlir_aie_external_set_addr_ddr_buffer_out_4((u64)ddr_ptr_out_4);
+  mlir_aie_external_set_addr_ddr_buffer_out_5((u64)ddr_ptr_out_5);
+  mlir_aie_external_set_addr_ddr_buffer_out_6((u64)ddr_ptr_out_6);
+  mlir_aie_external_set_addr_ddr_buffer_out_7((u64)ddr_ptr_out_7);
+  mlir_aie_external_set_addr_ddr_buffer_out_8((u64)ddr_ptr_out_8);
+  mlir_aie_external_set_addr_ddr_buffer_out_9((u64)ddr_ptr_out_9);
+  mlir_aie_external_set_addr_ddr_buffer_out_10((u64)ddr_ptr_out_10);
+  mlir_aie_external_set_addr_ddr_buffer_out_11((u64)ddr_ptr_out_11);
+  mlir_aie_external_set_addr_ddr_buffer_out_12((u64)ddr_ptr_out_12);
+  mlir_aie_external_set_addr_ddr_buffer_out_13((u64)ddr_ptr_out_13);
+  mlir_aie_external_set_addr_ddr_buffer_out_14((u64)ddr_ptr_out_14);
+  mlir_aie_external_set_addr_ddr_buffer_out_15((u64)ddr_ptr_out_15);
+  mlir_aie_external_set_addr_ddr_buffer_out_16((u64)ddr_ptr_out_16);
+  mlir_aie_external_set_addr_ddr_buffer_out_17((u64)ddr_ptr_out_17);
+  mlir_aie_external_set_addr_ddr_buffer_out_18((u64)ddr_ptr_out_18);
+  mlir_aie_external_set_addr_ddr_buffer_out_19((u64)ddr_ptr_out_19);
+  mlir_aie_external_set_addr_ddr_buffer_out_20((u64)ddr_ptr_out_20);
+  mlir_aie_external_set_addr_ddr_buffer_out_21((u64)ddr_ptr_out_21);
+  mlir_aie_external_set_addr_ddr_buffer_out_22((u64)ddr_ptr_out_22);
+  mlir_aie_external_set_addr_ddr_buffer_out_23((u64)ddr_ptr_out_23);
+  mlir_aie_external_set_addr_ddr_buffer_out_24((u64)ddr_ptr_out_24);
+  mlir_aie_external_set_addr_ddr_buffer_out_25((u64)ddr_ptr_out_25);
+  mlir_aie_external_set_addr_ddr_buffer_out_26((u64)ddr_ptr_out_26);
+  mlir_aie_external_set_addr_ddr_buffer_out_27((u64)ddr_ptr_out_27);
+  mlir_aie_external_set_addr_ddr_buffer_out_28((u64)ddr_ptr_out_28);
+  mlir_aie_external_set_addr_ddr_buffer_out_29((u64)ddr_ptr_out_29);
+  mlir_aie_external_set_addr_ddr_buffer_out_30((u64)ddr_ptr_out_30);
+  mlir_aie_external_set_addr_ddr_buffer_out_31((u64)ddr_ptr_out_31);
+  mlir_aie_configure_shimdma_20(_xaie);
+  mlir_aie_configure_shimdma_30(_xaie);
+  mlir_aie_configure_shimdma_60(_xaie);
+  mlir_aie_configure_shimdma_70(_xaie);
+  mlir_aie_configure_shimdma_100(_xaie);
+  mlir_aie_configure_shimdma_110(_xaie);
+  mlir_aie_configure_shimdma_180(_xaie);
+  mlir_aie_configure_shimdma_190(_xaie);
+  mlir_aie_configure_shimdma_260(_xaie);
+  mlir_aie_configure_shimdma_270(_xaie);
+  mlir_aie_configure_shimdma_340(_xaie);
+  mlir_aie_configure_shimdma_350(_xaie);
+  mlir_aie_configure_shimdma_420(_xaie);
+  mlir_aie_configure_shimdma_430(_xaie);
+  mlir_aie_configure_shimdma_460(_xaie);
+  mlir_aie_configure_shimdma_470(_xaie);
+#endif
+
+  printf("before core start");
   // mlir_aie_print_tile_status(_xaie, 7, 3);
 
   printf("Release lock for accessing DDR.");
-    mlir_aie_release_of_0_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
+  mlir_aie_release_of_0_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_15_lock_0(_xaie, 0, 0);
   mlir_aie_release_of_23_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_38_lock_0(_xaie, 0, 0);
@@ -532,7 +625,7 @@ int main(int argc, char *argv[]) {
   mlir_aie_release_of_199_lock_0(_xaie, 0, 0);
   mlir_aie_release_of_207_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_222_lock_0(_xaie, 0, 0);
-/*ADDD ALL THE LOCKS*/
+  /*ADDD ALL THE LOCKS*/
   mlir_aie_release_of_230_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_245_lock_0(_xaie, 0, 0);
   mlir_aie_release_of_253_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
@@ -587,97 +680,122 @@ int main(int argc, char *argv[]) {
   mlir_aie_release_of_705_lock_0(_xaie, 0, 0);
   mlir_aie_release_of_713_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_728_lock_0(_xaie, 0, 0);
-/*ADDD ALL THE LOCKS*/
-
-
-
-/*ADDD ALL THE LOCKS*/
-
-
+  /*ADDD ALL THE LOCKS*/
 
+  /*ADDD ALL THE LOCKS*/
 
   printf("Start cores");
   ///// --- start counter-----
-  t = clock(); 
+  t = clock();
   mlir_aie_start_cores(_xaie);
-      mlir_aie_release_lock(_xaie, 0, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 0, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 3, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 3, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 6, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 6, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 9, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 9, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 12, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 12, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 15, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 15, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 18, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 18, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 21, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 21, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 24, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 24, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 27, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 27, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 30, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 30, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 33, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 33, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 36, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 36, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 39, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 39, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 42, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 42, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 45, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 45, 6, 14, 0, 0); // for timing
- 
-
-         t = clock() - t; 
-
-  printf ("It took %ld clicks (%f seconds).",t,((float)t)/CLOCKS_PER_SEC);
+  mlir_aie_release_lock(_xaie, 0, 2, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 0, 6, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 3, 2, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 3, 6, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 6, 2, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 6, 6, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 9, 2, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 9, 6, 14, 0, 0);  // for timing
+  mlir_aie_release_lock(_xaie, 12, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 12, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 15, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 15, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 18, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 18, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 21, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 21, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 24, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 24, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 27, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 27, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 30, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 30, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 33, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 33, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 36, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 36, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 39, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 39, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 42, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 42, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 45, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 45, 6, 14, 0, 0); // for timing
+
+  t = clock() - t;
+
+  printf("It took %ld clicks (%f seconds).", t, ((float)t) / CLOCKS_PER_SEC);
 
   usleep(sleep_u);
   printf("after core start");
   // mlir_aie_print_tile_status(_xaie, 7, 3);
 
   usleep(sleep_u);
-  mlir_aie_sync_mem_cpu(_xaie, 32); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 33); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 34); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 35); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 36); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 37); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 38); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 39); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 40); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 41); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 42); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 43); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 44); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 45); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 46); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 47); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 48); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 49); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 50); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 51); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 52); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 53); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 54); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 55); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 56); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 57); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 58); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 59); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 60); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 61); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 62); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 63); //// only used in libaiev2 //sync up with output
- 
-
-      for (int i =0; i < 512; i ++ ){
+  mlir_aie_sync_mem_cpu(_xaie,
+                        32); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        33); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        34); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        35); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        36); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        37); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        38); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        39); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        40); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        41); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        42); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        43); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        44); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        45); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        46); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        47); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        48); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        49); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        50); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        51); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        52); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        53); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        54); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        55); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        56); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        57); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        58); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        59); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        60); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        61); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        62); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        63); //// only used in libaiev2 //sync up with output
+
+  for (int i = 0; i < 512; i++) {
     printf("Location %d:  %d", i, ddr_ptr_out_0[i]);
   }
 
@@ -688,40 +806,39 @@ int main(int argc, char *argv[]) {
   } else {
     printf("Fail!");
     res = -1;
-  } 
+  }
   printf("PC0 cycles: %d", pc0.diff());
-   printf("PC1 cycles: %d", pc1.diff());
-   printf("PC2 cycles: %d", pc2.diff());
-   printf("PC3 cycles: %d", pc3.diff());
-   printf("PC4 cycles: %d", pc4.diff());
-   printf("PC5 cycles: %d", pc5.diff());
-   printf("PC6 cycles: %d", pc6.diff());
-   printf("PC7 cycles: %d", pc7.diff());
-   printf("PC8 cycles: %d", pc8.diff());
-   printf("PC9 cycles: %d", pc9.diff());
-   printf("PC10 cycles: %d", pc10.diff());
-   printf("PC11 cycles: %d", pc11.diff());
-   printf("PC12 cycles: %d", pc12.diff());
-   printf("PC13 cycles: %d", pc13.diff());
-   printf("PC14 cycles: %d", pc14.diff());
-   printf("PC15 cycles: %d", pc15.diff());
-   printf("PC16 cycles: %d", pc16.diff());
-   printf("PC17 cycles: %d", pc17.diff());
-   printf("PC18 cycles: %d", pc18.diff());
-   printf("PC19 cycles: %d", pc19.diff());
-   printf("PC20 cycles: %d", pc20.diff());
-   printf("PC21 cycles: %d", pc21.diff());
-   printf("PC22 cycles: %d", pc22.diff());
-   printf("PC23 cycles: %d", pc23.diff());
-   printf("PC24 cycles: %d", pc24.diff());
-   printf("PC25 cycles: %d", pc25.diff());
-   printf("PC26 cycles: %d", pc26.diff());
-   printf("PC27 cycles: %d", pc27.diff());
-   printf("PC28 cycles: %d", pc28.diff());
-   printf("PC29 cycles: %d", pc29.diff());
-   printf("PC30 cycles: %d", pc30.diff());
-   printf("PC31 cycles: %d", pc31.diff());
- 
+  printf("PC1 cycles: %d", pc1.diff());
+  printf("PC2 cycles: %d", pc2.diff());
+  printf("PC3 cycles: %d", pc3.diff());
+  printf("PC4 cycles: %d", pc4.diff());
+  printf("PC5 cycles: %d", pc5.diff());
+  printf("PC6 cycles: %d", pc6.diff());
+  printf("PC7 cycles: %d", pc7.diff());
+  printf("PC8 cycles: %d", pc8.diff());
+  printf("PC9 cycles: %d", pc9.diff());
+  printf("PC10 cycles: %d", pc10.diff());
+  printf("PC11 cycles: %d", pc11.diff());
+  printf("PC12 cycles: %d", pc12.diff());
+  printf("PC13 cycles: %d", pc13.diff());
+  printf("PC14 cycles: %d", pc14.diff());
+  printf("PC15 cycles: %d", pc15.diff());
+  printf("PC16 cycles: %d", pc16.diff());
+  printf("PC17 cycles: %d", pc17.diff());
+  printf("PC18 cycles: %d", pc18.diff());
+  printf("PC19 cycles: %d", pc19.diff());
+  printf("PC20 cycles: %d", pc20.diff());
+  printf("PC21 cycles: %d", pc21.diff());
+  printf("PC22 cycles: %d", pc22.diff());
+  printf("PC23 cycles: %d", pc23.diff());
+  printf("PC24 cycles: %d", pc24.diff());
+  printf("PC25 cycles: %d", pc25.diff());
+  printf("PC26 cycles: %d", pc26.diff());
+  printf("PC27 cycles: %d", pc27.diff());
+  printf("PC28 cycles: %d", pc28.diff());
+  printf("PC29 cycles: %d", pc29.diff());
+  printf("PC30 cycles: %d", pc30.diff());
+  printf("PC31 cycles: %d", pc31.diff());
 
   mlir_aie_deinit_libxaie(_xaie);
 
@@ -729,7 +846,3 @@ int main(int argc, char *argv[]) {
 
   return res;
 }
-
-    
-    
-    
\ No newline at end of file
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_4.cpp b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_4.cpp
index 79bbe68..62b2f97 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_4.cpp
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_4.cpp
@@ -1,10 +1,9 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-    
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-
 #include "test_library.h"
 #include <cassert>
 #include <cmath>
@@ -14,23 +13,23 @@
 #include <stdlib.h>
 #include <sys/mman.h>
 #include <thread>
+#include <time.h>
 #include <unistd.h>
 #include <xaiengine.h>
-#include <time.h>  
 #define HIGH_ADDR(addr) ((addr & 0xffffffff00000000) >> 32)
 #define LOW_ADDR(addr) (addr & 0x00000000ffffffff)
 #define MLIR_STACK_OFFSET 4096
-#define B_BLOCK_DEPTH 4 //set how many rows
-#define HDIFF_COL 3 //columns
+#define B_BLOCK_DEPTH 4 // set how many rows
+#define HDIFF_COL 3     // columns
 #define START_ROW 1
-#define INPUT_ROWS 9   
-    
-    #define TOTAL_B_BLOCK 4
- #include "aie_inc.cpp"
+#define INPUT_ROWS 9
+
+#define TOTAL_B_BLOCK 4
+#include "aie_inc.cpp"
 
 int main(int argc, char *argv[]) {
   printf("test start.");
-  clock_t t; 
+  clock_t t;
 
   aie_libxaie_ctx_t *_xaie = mlir_aie_init_libxaie();
   mlir_aie_init_device(_xaie);
@@ -38,15 +37,14 @@ int main(int argc, char *argv[]) {
   u32 sleep_u = 100000;
   usleep(sleep_u);
   printf("before configure cores.");
-   for (int b=0; b<TOTAL_B_BLOCK;b++)
-  {
-    for (int i=0; i<HDIFF_COL;i++){
-      for (int j=START_ROW; j<START_ROW+B_BLOCK_DEPTH;j++)
+  for (int b = 0; b < TOTAL_B_BLOCK; b++) {
+    for (int i = 0; i < HDIFF_COL; i++) {
+      for (int j = START_ROW; j < START_ROW + B_BLOCK_DEPTH; j++)
         mlir_aie_clear_tile_memory(_xaie, i, j);
     }
   }
 
-//   mlir_aie_clear_tile_memory(_xaie, 6, 4);
+  //   mlir_aie_clear_tile_memory(_xaie, 6, 4);
   mlir_aie_configure_cores(_xaie);
 
   usleep(sleep_u);
@@ -54,79 +52,90 @@ int main(int argc, char *argv[]) {
   mlir_aie_configure_switchboxes(_xaie);
   mlir_aie_initialize_locks(_xaie);
 
-      mlir_aie_acquire_lock(_xaie, 0, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc0(_xaie, 2, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc0.set();
- 
+  mlir_aie_acquire_lock(_xaie, 0, 2, 14, 0, 0); // for timing
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc0(_xaie, 2, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc0.set();
+
   mlir_aie_acquire_lock(_xaie, 0, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc1(_xaie, 2, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc1.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc1(_xaie, 2, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc1.set();
+
   mlir_aie_acquire_lock(_xaie, 3, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc2(_xaie, 5, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc2.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc2(_xaie, 5, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc2.set();
+
   mlir_aie_acquire_lock(_xaie, 3, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc3(_xaie, 5, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc3.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc3(_xaie, 5, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc3.set();
 
-    usleep(sleep_u);
+  usleep(sleep_u);
   printf("before configure DMA");
   mlir_aie_configure_dmas(_xaie);
   int errors = 0;
-      mlir_aie_init_mems(_xaie, 8);
- 
-    printf("Finish configure");
-  #define DMA_COUNT_IN 256*INPUT_ROWS
-  #define DMA_COUNT_OUT 256*2*B_BLOCK_DEPTH
-
-      int *ddr_ptr_in_0 = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT_IN);
-   int *ddr_ptr_in_1 = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT_IN);
-   int *ddr_ptr_in_2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT_IN);
-   int *ddr_ptr_in_3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT_IN);
-   int *ddr_ptr_out_0 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT_OUT);
-   int *ddr_ptr_out_1 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT_OUT);
-   int *ddr_ptr_out_2 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT_OUT);
-   int *ddr_ptr_out_3 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT_OUT);
-   for (int i = 0; i < DMA_COUNT_IN; i++) {
-     *(ddr_ptr_in_0+ i) = i;
-     *(ddr_ptr_in_1+ i) = i;
-     *(ddr_ptr_in_2+ i) = i;
-     *(ddr_ptr_in_3+ i) = i;
-   }
-   for (int i = 0; i < DMA_COUNT_OUT; i++) {
-     *(ddr_ptr_out_0+ i) = i;
-     *(ddr_ptr_out_1+ i) = i;
-     *(ddr_ptr_out_2+ i) = i;
-     *(ddr_ptr_out_3+ i) = i;
-   }
-   mlir_aie_sync_mem_dev(_xaie, 0);
-   mlir_aie_sync_mem_dev(_xaie, 1);
-   mlir_aie_sync_mem_dev(_xaie, 2);
-   mlir_aie_sync_mem_dev(_xaie, 3);
-   mlir_aie_sync_mem_dev(_xaie, 4);
-   mlir_aie_sync_mem_dev(_xaie, 5);
-   mlir_aie_sync_mem_dev(_xaie, 6);
-   mlir_aie_sync_mem_dev(_xaie, 7);
- #ifdef LIBXAIENGINEV2
-    mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0); 
-     mlir_aie_external_set_addr_ddr_buffer_in_1((u64)ddr_ptr_in_1); 
-     mlir_aie_external_set_addr_ddr_buffer_in_2((u64)ddr_ptr_in_2); 
-     mlir_aie_external_set_addr_ddr_buffer_in_3((u64)ddr_ptr_in_3); 
-     mlir_aie_external_set_addr_ddr_buffer_out_0((u64)ddr_ptr_out_0); 
-     mlir_aie_external_set_addr_ddr_buffer_out_1((u64)ddr_ptr_out_1); 
-     mlir_aie_external_set_addr_ddr_buffer_out_2((u64)ddr_ptr_out_2); 
-     mlir_aie_external_set_addr_ddr_buffer_out_3((u64)ddr_ptr_out_3); 
-     mlir_aie_configure_shimdma_20(_xaie);
-     mlir_aie_configure_shimdma_30(_xaie);
- #endif
-
-    printf("before core start");
+  mlir_aie_init_mems(_xaie, 8);
+
+  printf("Finish configure");
+#define DMA_COUNT_IN 256 * INPUT_ROWS
+#define DMA_COUNT_OUT 256 * 2 * B_BLOCK_DEPTH
+
+  int *ddr_ptr_in_0 = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT_IN);
+  int *ddr_ptr_in_1 = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT_IN);
+  int *ddr_ptr_in_2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT_IN);
+  int *ddr_ptr_in_3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT_IN);
+  int *ddr_ptr_out_0 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT_OUT);
+  int *ddr_ptr_out_1 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT_OUT);
+  int *ddr_ptr_out_2 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT_OUT);
+  int *ddr_ptr_out_3 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT_OUT);
+  for (int i = 0; i < DMA_COUNT_IN; i++) {
+    *(ddr_ptr_in_0 + i) = i;
+    *(ddr_ptr_in_1 + i) = i;
+    *(ddr_ptr_in_2 + i) = i;
+    *(ddr_ptr_in_3 + i) = i;
+  }
+  for (int i = 0; i < DMA_COUNT_OUT; i++) {
+    *(ddr_ptr_out_0 + i) = i;
+    *(ddr_ptr_out_1 + i) = i;
+    *(ddr_ptr_out_2 + i) = i;
+    *(ddr_ptr_out_3 + i) = i;
+  }
+  mlir_aie_sync_mem_dev(_xaie, 0);
+  mlir_aie_sync_mem_dev(_xaie, 1);
+  mlir_aie_sync_mem_dev(_xaie, 2);
+  mlir_aie_sync_mem_dev(_xaie, 3);
+  mlir_aie_sync_mem_dev(_xaie, 4);
+  mlir_aie_sync_mem_dev(_xaie, 5);
+  mlir_aie_sync_mem_dev(_xaie, 6);
+  mlir_aie_sync_mem_dev(_xaie, 7);
+#ifdef LIBXAIENGINEV2
+  mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0);
+  mlir_aie_external_set_addr_ddr_buffer_in_1((u64)ddr_ptr_in_1);
+  mlir_aie_external_set_addr_ddr_buffer_in_2((u64)ddr_ptr_in_2);
+  mlir_aie_external_set_addr_ddr_buffer_in_3((u64)ddr_ptr_in_3);
+  mlir_aie_external_set_addr_ddr_buffer_out_0((u64)ddr_ptr_out_0);
+  mlir_aie_external_set_addr_ddr_buffer_out_1((u64)ddr_ptr_out_1);
+  mlir_aie_external_set_addr_ddr_buffer_out_2((u64)ddr_ptr_out_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_3((u64)ddr_ptr_out_3);
+  mlir_aie_configure_shimdma_20(_xaie);
+  mlir_aie_configure_shimdma_30(_xaie);
+#endif
+
+  printf("before core start");
   // mlir_aie_print_tile_status(_xaie, 7, 3);
 
   printf("Release lock for accessing DDR.");
@@ -140,38 +149,36 @@ int main(int argc, char *argv[]) {
   mlir_aie_release_of_69_lock_0(_xaie, 1, 0);
   mlir_aie_release_of_84_lock_0(_xaie, 0, 0);
 
-
-/*ADDD ALL THE LOCKS*/
-
-
-
+  /*ADDD ALL THE LOCKS*/
 
   printf("Start cores");
   ///// --- start counter-----
-  t = clock(); 
+  t = clock();
   mlir_aie_start_cores(_xaie);
-      mlir_aie_release_lock(_xaie, 0, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 0, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 3, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 3, 6, 14, 0, 0); // for timing
- 
+  mlir_aie_release_lock(_xaie, 0, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 0, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 3, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 3, 6, 14, 0, 0); // for timing
 
-         t = clock() - t; 
+  t = clock() - t;
 
-  printf ("It took %ld clicks (%f seconds).",t,((float)t)/CLOCKS_PER_SEC);
+  printf("It took %ld clicks (%f seconds).", t, ((float)t) / CLOCKS_PER_SEC);
 
   usleep(sleep_u);
   printf("after core start");
   // mlir_aie_print_tile_status(_xaie, 7, 3);
 
   usleep(sleep_u);
-  mlir_aie_sync_mem_cpu(_xaie, 4); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 5); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 6); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 7); //// only used in libaiev2 //sync up with output
- 
-
-      for (int i =0; i < 512; i ++ ){
+  mlir_aie_sync_mem_cpu(_xaie,
+                        4); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        5); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        6); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        7); //// only used in libaiev2 //sync up with output
+
+  for (int i = 0; i < 512; i++) {
     printf("Location %d:  %d", i, ddr_ptr_out_0[i]);
   }
 
@@ -182,12 +189,11 @@ int main(int argc, char *argv[]) {
   } else {
     printf("Fail!");
     res = -1;
-  } 
+  }
   printf("PC0 cycles: %d", pc0.diff());
-   printf("PC1 cycles: %d", pc1.diff());
-   printf("PC2 cycles: %d", pc2.diff());
-   printf("PC3 cycles: %d", pc3.diff());
- 
+  printf("PC1 cycles: %d", pc1.diff());
+  printf("PC2 cycles: %d", pc2.diff());
+  printf("PC3 cycles: %d", pc3.diff());
 
   mlir_aie_deinit_libxaie(_xaie);
 
@@ -195,7 +201,3 @@ int main(int argc, char *argv[]) {
 
   return res;
 }
-
-    
-    
-    
\ No newline at end of file
diff --git a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_8.cpp b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_8.cpp
index eb0c10b..7ab73d7 100644
--- a/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_8.cpp
+++ b/reference_designs/horizontal_diffusion/HDIFF_tri_AIE_objectFIFO_ping_pong_scaled/test_8.cpp
@@ -1,10 +1,9 @@
-// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET   
-    
+// (c) 2023 SAFARI Research Group at ETH Zurich, Gagandeep Singh, D-ITET
+
 // This file is licensed under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 
-
 #include "test_library.h"
 #include <cassert>
 #include <cmath>
@@ -14,23 +13,23 @@
 #include <stdlib.h>
 #include <sys/mman.h>
 #include <thread>
+#include <time.h>
 #include <unistd.h>
 #include <xaiengine.h>
-#include <time.h>  
 #define HIGH_ADDR(addr) ((addr & 0xffffffff00000000) >> 32)
 #define LOW_ADDR(addr) (addr & 0x00000000ffffffff)
 #define MLIR_STACK_OFFSET 4096
-#define B_BLOCK_DEPTH 4 //set how many rows
-#define HDIFF_COL 3 //columns
+#define B_BLOCK_DEPTH 4 // set how many rows
+#define HDIFF_COL 3     // columns
 #define START_ROW 1
-#define INPUT_ROWS 9   
-    
-    #define TOTAL_B_BLOCK 8
- #include "aie_inc.cpp"
+#define INPUT_ROWS 9
+
+#define TOTAL_B_BLOCK 8
+#include "aie_inc.cpp"
 
 int main(int argc, char *argv[]) {
   printf("test start.");
-  clock_t t; 
+  clock_t t;
 
   aie_libxaie_ctx_t *_xaie = mlir_aie_init_libxaie();
   mlir_aie_init_device(_xaie);
@@ -38,15 +37,14 @@ int main(int argc, char *argv[]) {
   u32 sleep_u = 100000;
   usleep(sleep_u);
   printf("before configure cores.");
-   for (int b=0; b<TOTAL_B_BLOCK;b++)
-  {
-    for (int i=0; i<HDIFF_COL;i++){
-      for (int j=START_ROW; j<START_ROW+B_BLOCK_DEPTH;j++)
+  for (int b = 0; b < TOTAL_B_BLOCK; b++) {
+    for (int i = 0; i < HDIFF_COL; i++) {
+      for (int j = START_ROW; j < START_ROW + B_BLOCK_DEPTH; j++)
         mlir_aie_clear_tile_memory(_xaie, i, j);
     }
   }
 
-//   mlir_aie_clear_tile_memory(_xaie, 6, 4);
+  //   mlir_aie_clear_tile_memory(_xaie, 6, 4);
   mlir_aie_configure_cores(_xaie);
 
   usleep(sleep_u);
@@ -54,136 +52,159 @@ int main(int argc, char *argv[]) {
   mlir_aie_configure_switchboxes(_xaie);
   mlir_aie_initialize_locks(_xaie);
 
-      mlir_aie_acquire_lock(_xaie, 0, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc0(_xaie, 2, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc0.set();
- 
+  mlir_aie_acquire_lock(_xaie, 0, 2, 14, 0, 0); // for timing
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc0(_xaie, 2, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc0.set();
+
   mlir_aie_acquire_lock(_xaie, 0, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc1(_xaie, 2, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc1.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(0, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc1(_xaie, 2, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc1.set();
+
   mlir_aie_acquire_lock(_xaie, 3, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc2(_xaie, 5, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc2.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc2(_xaie, 5, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc2.set();
+
   mlir_aie_acquire_lock(_xaie, 3, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc3(_xaie, 5, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc3.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(3, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc3(_xaie, 5, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc3.set();
+
   mlir_aie_acquire_lock(_xaie, 6, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(6,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc4(_xaie, 8, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc4.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(6, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc4(_xaie, 8, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc4.set();
+
   mlir_aie_acquire_lock(_xaie, 6, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(6,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc5(_xaie, 8, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc5.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(6, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc5(_xaie, 8, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc5.set();
+
   mlir_aie_acquire_lock(_xaie, 9, 2, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(9,2), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc6(_xaie, 11, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc6.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(9, 2), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc6(_xaie, 11, 2, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc6.set();
+
   mlir_aie_acquire_lock(_xaie, 9, 6, 14, 0, 0); // for timing
-   XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(9,6), XAIE_MEM_MOD, 2,XAIE_EVENT_LOCK_14_ACQ_MEM);
-   EventMonitor pc7(_xaie, 11, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,XAIE_MEM_MOD);
-   pc7.set();
- 
+  XAie_EventBroadcast(&(_xaie->DevInst), XAie_TileLoc(9, 6), XAIE_MEM_MOD, 2,
+                      XAIE_EVENT_LOCK_14_ACQ_MEM);
+  EventMonitor pc7(_xaie, 11, 6, 0, XAIE_EVENT_BROADCAST_2_MEM,
+                   XAIE_EVENT_LOCK_14_ACQ_MEM, XAIE_EVENT_NONE_MEM,
+                   XAIE_MEM_MOD);
+  pc7.set();
 
-    usleep(sleep_u);
+  usleep(sleep_u);
   printf("before configure DMA");
   mlir_aie_configure_dmas(_xaie);
   int errors = 0;
-      mlir_aie_init_mems(_xaie, 16);
- 
-    printf("Finish configure");
-  #define DMA_COUNT_IN 256*INPUT_ROWS
-  #define DMA_COUNT_OUT 256*2*B_BLOCK_DEPTH
-
-      int *ddr_ptr_in_0 = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT_IN);
-   int *ddr_ptr_in_1 = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT_IN);
-   int *ddr_ptr_in_2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT_IN);
-   int *ddr_ptr_in_3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT_IN);
-   int *ddr_ptr_in_4 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT_IN);
-   int *ddr_ptr_in_5 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT_IN);
-   int *ddr_ptr_in_6 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT_IN);
-   int *ddr_ptr_in_7 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT_IN);
-   int *ddr_ptr_out_0 = mlir_aie_mem_alloc(_xaie, 8, DMA_COUNT_OUT);
-   int *ddr_ptr_out_1 = mlir_aie_mem_alloc(_xaie, 9, DMA_COUNT_OUT);
-   int *ddr_ptr_out_2 = mlir_aie_mem_alloc(_xaie, 10, DMA_COUNT_OUT);
-   int *ddr_ptr_out_3 = mlir_aie_mem_alloc(_xaie, 11, DMA_COUNT_OUT);
-   int *ddr_ptr_out_4 = mlir_aie_mem_alloc(_xaie, 12, DMA_COUNT_OUT);
-   int *ddr_ptr_out_5 = mlir_aie_mem_alloc(_xaie, 13, DMA_COUNT_OUT);
-   int *ddr_ptr_out_6 = mlir_aie_mem_alloc(_xaie, 14, DMA_COUNT_OUT);
-   int *ddr_ptr_out_7 = mlir_aie_mem_alloc(_xaie, 15, DMA_COUNT_OUT);
-   for (int i = 0; i < DMA_COUNT_IN; i++) {
-     *(ddr_ptr_in_0+ i) = i;
-     *(ddr_ptr_in_1+ i) = i;
-     *(ddr_ptr_in_2+ i) = i;
-     *(ddr_ptr_in_3+ i) = i;
-     *(ddr_ptr_in_4+ i) = i;
-     *(ddr_ptr_in_5+ i) = i;
-     *(ddr_ptr_in_6+ i) = i;
-     *(ddr_ptr_in_7+ i) = i;
-   }
-   for (int i = 0; i < DMA_COUNT_OUT; i++) {
-     *(ddr_ptr_out_0+ i) = i;
-     *(ddr_ptr_out_1+ i) = i;
-     *(ddr_ptr_out_2+ i) = i;
-     *(ddr_ptr_out_3+ i) = i;
-     *(ddr_ptr_out_4+ i) = i;
-     *(ddr_ptr_out_5+ i) = i;
-     *(ddr_ptr_out_6+ i) = i;
-     *(ddr_ptr_out_7+ i) = i;
-   }
-   mlir_aie_sync_mem_dev(_xaie, 0);
-   mlir_aie_sync_mem_dev(_xaie, 1);
-   mlir_aie_sync_mem_dev(_xaie, 2);
-   mlir_aie_sync_mem_dev(_xaie, 3);
-   mlir_aie_sync_mem_dev(_xaie, 4);
-   mlir_aie_sync_mem_dev(_xaie, 5);
-   mlir_aie_sync_mem_dev(_xaie, 6);
-   mlir_aie_sync_mem_dev(_xaie, 7);
-   mlir_aie_sync_mem_dev(_xaie, 8);
-   mlir_aie_sync_mem_dev(_xaie, 9);
-   mlir_aie_sync_mem_dev(_xaie, 10);
-   mlir_aie_sync_mem_dev(_xaie, 11);
-   mlir_aie_sync_mem_dev(_xaie, 12);
-   mlir_aie_sync_mem_dev(_xaie, 13);
-   mlir_aie_sync_mem_dev(_xaie, 14);
-   mlir_aie_sync_mem_dev(_xaie, 15);
- #ifdef LIBXAIENGINEV2
-    mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0); 
-     mlir_aie_external_set_addr_ddr_buffer_in_1((u64)ddr_ptr_in_1); 
-     mlir_aie_external_set_addr_ddr_buffer_in_2((u64)ddr_ptr_in_2); 
-     mlir_aie_external_set_addr_ddr_buffer_in_3((u64)ddr_ptr_in_3); 
-     mlir_aie_external_set_addr_ddr_buffer_in_4((u64)ddr_ptr_in_4); 
-     mlir_aie_external_set_addr_ddr_buffer_in_5((u64)ddr_ptr_in_5); 
-     mlir_aie_external_set_addr_ddr_buffer_in_6((u64)ddr_ptr_in_6); 
-     mlir_aie_external_set_addr_ddr_buffer_in_7((u64)ddr_ptr_in_7); 
-     mlir_aie_external_set_addr_ddr_buffer_out_0((u64)ddr_ptr_out_0); 
-     mlir_aie_external_set_addr_ddr_buffer_out_1((u64)ddr_ptr_out_1); 
-     mlir_aie_external_set_addr_ddr_buffer_out_2((u64)ddr_ptr_out_2); 
-     mlir_aie_external_set_addr_ddr_buffer_out_3((u64)ddr_ptr_out_3); 
-     mlir_aie_external_set_addr_ddr_buffer_out_4((u64)ddr_ptr_out_4); 
-     mlir_aie_external_set_addr_ddr_buffer_out_5((u64)ddr_ptr_out_5); 
-     mlir_aie_external_set_addr_ddr_buffer_out_6((u64)ddr_ptr_out_6); 
-     mlir_aie_external_set_addr_ddr_buffer_out_7((u64)ddr_ptr_out_7); 
-     mlir_aie_configure_shimdma_20(_xaie);
-     mlir_aie_configure_shimdma_30(_xaie);
-     mlir_aie_configure_shimdma_60(_xaie);
-     mlir_aie_configure_shimdma_70(_xaie);
- #endif
-
-    printf("before core start");
+  mlir_aie_init_mems(_xaie, 16);
+
+  printf("Finish configure");
+#define DMA_COUNT_IN 256 * INPUT_ROWS
+#define DMA_COUNT_OUT 256 * 2 * B_BLOCK_DEPTH
+
+  int *ddr_ptr_in_0 = mlir_aie_mem_alloc(_xaie, 0, DMA_COUNT_IN);
+  int *ddr_ptr_in_1 = mlir_aie_mem_alloc(_xaie, 1, DMA_COUNT_IN);
+  int *ddr_ptr_in_2 = mlir_aie_mem_alloc(_xaie, 2, DMA_COUNT_IN);
+  int *ddr_ptr_in_3 = mlir_aie_mem_alloc(_xaie, 3, DMA_COUNT_IN);
+  int *ddr_ptr_in_4 = mlir_aie_mem_alloc(_xaie, 4, DMA_COUNT_IN);
+  int *ddr_ptr_in_5 = mlir_aie_mem_alloc(_xaie, 5, DMA_COUNT_IN);
+  int *ddr_ptr_in_6 = mlir_aie_mem_alloc(_xaie, 6, DMA_COUNT_IN);
+  int *ddr_ptr_in_7 = mlir_aie_mem_alloc(_xaie, 7, DMA_COUNT_IN);
+  int *ddr_ptr_out_0 = mlir_aie_mem_alloc(_xaie, 8, DMA_COUNT_OUT);
+  int *ddr_ptr_out_1 = mlir_aie_mem_alloc(_xaie, 9, DMA_COUNT_OUT);
+  int *ddr_ptr_out_2 = mlir_aie_mem_alloc(_xaie, 10, DMA_COUNT_OUT);
+  int *ddr_ptr_out_3 = mlir_aie_mem_alloc(_xaie, 11, DMA_COUNT_OUT);
+  int *ddr_ptr_out_4 = mlir_aie_mem_alloc(_xaie, 12, DMA_COUNT_OUT);
+  int *ddr_ptr_out_5 = mlir_aie_mem_alloc(_xaie, 13, DMA_COUNT_OUT);
+  int *ddr_ptr_out_6 = mlir_aie_mem_alloc(_xaie, 14, DMA_COUNT_OUT);
+  int *ddr_ptr_out_7 = mlir_aie_mem_alloc(_xaie, 15, DMA_COUNT_OUT);
+  for (int i = 0; i < DMA_COUNT_IN; i++) {
+    *(ddr_ptr_in_0 + i) = i;
+    *(ddr_ptr_in_1 + i) = i;
+    *(ddr_ptr_in_2 + i) = i;
+    *(ddr_ptr_in_3 + i) = i;
+    *(ddr_ptr_in_4 + i) = i;
+    *(ddr_ptr_in_5 + i) = i;
+    *(ddr_ptr_in_6 + i) = i;
+    *(ddr_ptr_in_7 + i) = i;
+  }
+  for (int i = 0; i < DMA_COUNT_OUT; i++) {
+    *(ddr_ptr_out_0 + i) = i;
+    *(ddr_ptr_out_1 + i) = i;
+    *(ddr_ptr_out_2 + i) = i;
+    *(ddr_ptr_out_3 + i) = i;
+    *(ddr_ptr_out_4 + i) = i;
+    *(ddr_ptr_out_5 + i) = i;
+    *(ddr_ptr_out_6 + i) = i;
+    *(ddr_ptr_out_7 + i) = i;
+  }
+  mlir_aie_sync_mem_dev(_xaie, 0);
+  mlir_aie_sync_mem_dev(_xaie, 1);
+  mlir_aie_sync_mem_dev(_xaie, 2);
+  mlir_aie_sync_mem_dev(_xaie, 3);
+  mlir_aie_sync_mem_dev(_xaie, 4);
+  mlir_aie_sync_mem_dev(_xaie, 5);
+  mlir_aie_sync_mem_dev(_xaie, 6);
+  mlir_aie_sync_mem_dev(_xaie, 7);
+  mlir_aie_sync_mem_dev(_xaie, 8);
+  mlir_aie_sync_mem_dev(_xaie, 9);
+  mlir_aie_sync_mem_dev(_xaie, 10);
+  mlir_aie_sync_mem_dev(_xaie, 11);
+  mlir_aie_sync_mem_dev(_xaie, 12);
+  mlir_aie_sync_mem_dev(_xaie, 13);
+  mlir_aie_sync_mem_dev(_xaie, 14);
+  mlir_aie_sync_mem_dev(_xaie, 15);
+#ifdef LIBXAIENGINEV2
+  mlir_aie_external_set_addr_ddr_buffer_in_0((u64)ddr_ptr_in_0);
+  mlir_aie_external_set_addr_ddr_buffer_in_1((u64)ddr_ptr_in_1);
+  mlir_aie_external_set_addr_ddr_buffer_in_2((u64)ddr_ptr_in_2);
+  mlir_aie_external_set_addr_ddr_buffer_in_3((u64)ddr_ptr_in_3);
+  mlir_aie_external_set_addr_ddr_buffer_in_4((u64)ddr_ptr_in_4);
+  mlir_aie_external_set_addr_ddr_buffer_in_5((u64)ddr_ptr_in_5);
+  mlir_aie_external_set_addr_ddr_buffer_in_6((u64)ddr_ptr_in_6);
+  mlir_aie_external_set_addr_ddr_buffer_in_7((u64)ddr_ptr_in_7);
+  mlir_aie_external_set_addr_ddr_buffer_out_0((u64)ddr_ptr_out_0);
+  mlir_aie_external_set_addr_ddr_buffer_out_1((u64)ddr_ptr_out_1);
+  mlir_aie_external_set_addr_ddr_buffer_out_2((u64)ddr_ptr_out_2);
+  mlir_aie_external_set_addr_ddr_buffer_out_3((u64)ddr_ptr_out_3);
+  mlir_aie_external_set_addr_ddr_buffer_out_4((u64)ddr_ptr_out_4);
+  mlir_aie_external_set_addr_ddr_buffer_out_5((u64)ddr_ptr_out_5);
+  mlir_aie_external_set_addr_ddr_buffer_out_6((u64)ddr_ptr_out_6);
+  mlir_aie_external_set_addr_ddr_buffer_out_7((u64)ddr_ptr_out_7);
+  mlir_aie_configure_shimdma_20(_xaie);
+  mlir_aie_configure_shimdma_30(_xaie);
+  mlir_aie_configure_shimdma_60(_xaie);
+  mlir_aie_configure_shimdma_70(_xaie);
+#endif
+
+  printf("before core start");
   // mlir_aie_print_tile_status(_xaie, 7, 3);
 
-   printf("Release lock for accessing DDR.");
+  printf("Release lock for accessing DDR.");
   mlir_aie_release_of_0_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
   mlir_aie_release_of_15_lock_0(_xaie, 0, 0);
   mlir_aie_release_of_23_lock_0(_xaie, 1, 0); // (_xaie,release_value,time_out)
@@ -204,45 +225,48 @@ int main(int argc, char *argv[]) {
   mlir_aie_release_of_161_lock_0(_xaie, 1, 0);
   mlir_aie_release_of_176_lock_0(_xaie, 0, 0);
 
-/*ADDD ALL THE LOCKS*/
-
-
-
+  /*ADDD ALL THE LOCKS*/
 
   printf("Start cores");
   ///// --- start counter-----
-  t = clock(); 
+  t = clock();
   mlir_aie_start_cores(_xaie);
-      mlir_aie_release_lock(_xaie, 0, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 0, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 3, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 3, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 6, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 6, 6, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 9, 2, 14, 0, 0); // for timing
-   mlir_aie_release_lock(_xaie, 9, 6, 14, 0, 0); // for timing
- 
+  mlir_aie_release_lock(_xaie, 0, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 0, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 3, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 3, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 6, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 6, 6, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 9, 2, 14, 0, 0); // for timing
+  mlir_aie_release_lock(_xaie, 9, 6, 14, 0, 0); // for timing
 
-         t = clock() - t; 
+  t = clock() - t;
 
-  printf ("It took %ld clicks (%f seconds).",t,((float)t)/CLOCKS_PER_SEC);
+  printf("It took %ld clicks (%f seconds).", t, ((float)t) / CLOCKS_PER_SEC);
 
   usleep(sleep_u);
   printf("after core start");
   // mlir_aie_print_tile_status(_xaie, 7, 3);
 
   usleep(sleep_u);
-  mlir_aie_sync_mem_cpu(_xaie, 8); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 9); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 10); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 11); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 12); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 13); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 14); //// only used in libaiev2 //sync up with output
-   mlir_aie_sync_mem_cpu(_xaie, 15); //// only used in libaiev2 //sync up with output
- 
-
-      for (int i =0; i < 512; i ++ ){
+  mlir_aie_sync_mem_cpu(_xaie,
+                        8); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        9); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        10); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        11); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        12); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        13); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        14); //// only used in libaiev2 //sync up with output
+  mlir_aie_sync_mem_cpu(_xaie,
+                        15); //// only used in libaiev2 //sync up with output
+
+  for (int i = 0; i < 512; i++) {
     printf("Location %d:  %d", i, ddr_ptr_out_0[i]);
   }
 
@@ -253,16 +277,15 @@ int main(int argc, char *argv[]) {
   } else {
     printf("Fail!");
     res = -1;
-  } 
+  }
   printf("PC0 cycles: %d", pc0.diff());
-   printf("PC1 cycles: %d", pc1.diff());
-   printf("PC2 cycles: %d", pc2.diff());
-   printf("PC3 cycles: %d", pc3.diff());
-   printf("PC4 cycles: %d", pc4.diff());
-   printf("PC5 cycles: %d", pc5.diff());
-   printf("PC6 cycles: %d", pc6.diff());
-   printf("PC7 cycles: %d", pc7.diff());
- 
+  printf("PC1 cycles: %d", pc1.diff());
+  printf("PC2 cycles: %d", pc2.diff());
+  printf("PC3 cycles: %d", pc3.diff());
+  printf("PC4 cycles: %d", pc4.diff());
+  printf("PC5 cycles: %d", pc5.diff());
+  printf("PC6 cycles: %d", pc6.diff());
+  printf("PC7 cycles: %d", pc7.diff());
 
   mlir_aie_deinit_libxaie(_xaie);
 
@@ -270,7 +293,3 @@ int main(int argc, char *argv[]) {
 
   return res;
 }
-
-    
-    
-    
\ No newline at end of file
